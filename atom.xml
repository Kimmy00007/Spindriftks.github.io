<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>它夏了夏天</title>
  
  <subtitle>生命中有一种遇见，就让它美如行云流水，然后一生去回味。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tokyle.com/"/>
  <updated>2018-02-07T05:32:05.887Z</updated>
  <id>http://tokyle.com/</id>
  
  <author>
    <name>Kyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nose执行顺序</title>
    <link href="http://tokyle.com/2018/02/07/nose%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://tokyle.com/2018/02/07/nose执行顺序/</id>
    <published>2018-02-07T05:30:13.000Z</published>
    <updated>2018-02-07T05:32:05.887Z</updated>
    
    <content type="html"><![CDATA[<p>nose单元测试执行顺序</p><a id="more"></a><p>nose和unittest一样，都可以在用例中指定<code>setUp()</code>和<code>tearDown()</code>（用户测试初始化以及测试结束后的操作），在nose中，package、module、class都可以设置setup()和teardown()；</p><h3 id="package中设置"><a href="#package中设置" class="headerlink" title="package中设置"></a>package中设置</h3><p>在package中设置，整个测试的运行期间只会执行一次（新建python package时，会生成一个<strong>init</strong>.py文件，在其中设置setUp()以及tearDown()即可）</p><h3 id="用例中每次都执行setup及teardown"><a href="#用例中每次都执行setup及teardown" class="headerlink" title="用例中每次都执行setup及teardown"></a>用例中每次都执行setup及teardown</h3><p>在模块、类中执行顺序示例：<br>新建Testexec.py文件，内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2018/2/7 10:39</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from nose.plugins.skip import SkipTest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestClass():</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        print(&quot;=============-My Testcase is setup-===========&quot;)</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        print(&quot;============My Testcase is teardown===========&quot;)</span><br><span class="line"></span><br><span class="line">    def test_fun1(self):</span><br><span class="line">        print(&quot;This is test_fun1*******&quot;)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def test_fun2(self):</span><br><span class="line">        print(&quot;This is test_fun2=====&quot;)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def test_fun3(self):</span><br><span class="line">        print(&quot;This is test_fun3~~~~~~~~~&quot;)</span><br><span class="line">        raise SkipTest</span><br><span class="line"></span><br><span class="line">    def test_Fun1(self):</span><br><span class="line">        print(&quot;This is test_Fun1***====***&quot;)</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></p><p>命令行执行nosetests：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nosetests -v -s Testexec.py</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; nosetests -v -s Testexec.py                                               </span><br><span class="line">Testexec.TestClass.test_Fun1 ... =============-My Testcase is setup-===========  </span><br><span class="line">This is test_Fun1***====***                                                      </span><br><span class="line">============My Testcase is teardown===========                                   </span><br><span class="line">ok                                                                               </span><br><span class="line">Testexec.TestClass.test_fun1 ... =============-My Testcase is setup-===========  </span><br><span class="line">This is test_fun1*******                                                         </span><br><span class="line">============My Testcase is teardown===========                                   </span><br><span class="line">ok                                                                               </span><br><span class="line">Testexec.TestClass.test_fun2 ... =============-My Testcase is setup-===========  </span><br><span class="line">This is test_fun2=====                                                           </span><br><span class="line">============My Testcase is teardown===========                                   </span><br><span class="line">ok                                                                               </span><br><span class="line">Testexec.TestClass.test_fun3 ... =============-My Testcase is setup-===========  </span><br><span class="line">This is test_fun3~~~~~~~~~                                                       </span><br><span class="line">============My Testcase is teardown===========                                   </span><br><span class="line">SKIP                                                                             </span><br><span class="line">                                                                                 </span><br><span class="line">----------------------------------------------------------------------           </span><br><span class="line">Ran 4 tests in 0.005s                                                            </span><br><span class="line">                                                                                 </span><br><span class="line">OK (SKIP=1)</span><br></pre></td></tr></table></figure></p><p>可以看见在对每一个函数进行测试时，都执行了一次<code>setUp()</code>以及<code>tearDown()</code>；且用例执行顺序是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_Fun1 -&gt; test_fun1 -&gt; test_fun2 -&gt; test_fun3</span><br></pre></td></tr></table></figure></p><p>其中<code>test_fun3</code>跳过了测试，执行顺序是按照先大写字母，再小写字母，然后再按阿拉伯数字排列的。</p><h3 id="用例中只执行一次setup及teardown"><a href="#用例中只执行一次setup及teardown" class="headerlink" title="用例中只执行一次setup及teardown"></a>用例中只执行一次setup及teardown</h3><p>只需要在<code>setUpClass()</code>及<code>tearDownClass()</code>前加修饰器<code>@classmethod</code>即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2018/2/7 10:39</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from nose.plugins.skip import SkipTest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestClass():</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def setUpClass(cls):</span><br><span class="line">        print(&quot;只初始化一次setup=======&quot;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def tearDownClass(cls):</span><br><span class="line">        print(&quot;只teardown一次***********&quot;)</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        print(&quot;=============-My Testcase is setup-===========&quot;)</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        print(&quot;============My Testcase is teardown===========&quot;)</span><br><span class="line"></span><br><span class="line">    def test_fun1(self):</span><br><span class="line">        print(&quot;This is test_fun1*******&quot;)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def test_fun2(self):</span><br><span class="line">        print(&quot;This is test_fun2=====&quot;)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def test_fun3(self):</span><br><span class="line">        print(&quot;This is test_fun3~~~~~~~~~&quot;)</span><br><span class="line">        raise SkipTest</span><br><span class="line"></span><br><span class="line">    def test_Fun1(self):</span><br><span class="line">        print(&quot;This is test_Fun1***====***&quot;)</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></p><p>执行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nosetests -v -s Testexec.py</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;lamb&#125; nosetests -v -s Testexec.py                                                   </span><br><span class="line">只初始化一次setup=======                                                                   </span><br><span class="line">Testexec.TestClass.test_Fun1 ... =============-My Testcase is setup-===========      </span><br><span class="line">This is test_Fun1***====***                                                          </span><br><span class="line">============My Testcase is teardown===========                                       </span><br><span class="line">ok                                                                                   </span><br><span class="line">Testexec.TestClass.test_fun1 ... =============-My Testcase is setup-===========      </span><br><span class="line">This is test_fun1*******                                                             </span><br><span class="line">============My Testcase is teardown===========                                       </span><br><span class="line">ok                                                                                   </span><br><span class="line">Testexec.TestClass.test_fun2 ... =============-My Testcase is setup-===========      </span><br><span class="line">This is test_fun2=====                                                               </span><br><span class="line">============My Testcase is teardown===========                                       </span><br><span class="line">ok                                                                                   </span><br><span class="line">Testexec.TestClass.test_fun3 ... =============-My Testcase is setup-===========      </span><br><span class="line">This is test_fun3~~~~~~~~~                                                           </span><br><span class="line">============My Testcase is teardown===========                                       </span><br><span class="line">SKIP                                                                                 </span><br><span class="line">只teardown一次***********                                                               </span><br><span class="line">                                                                                     </span><br><span class="line">----------------------------------------------------------------------               </span><br><span class="line">Ran 4 tests in 0.006s                                                                </span><br><span class="line">                                                                                     </span><br><span class="line">OK (SKIP=1)</span><br></pre></td></tr></table></figure></p><p>可以看见，<code>setUpClass()</code>以及<code>tearDownClass</code>都只执行了一次。在自动化测试中，可用来加载配置信息，只需要加载一次即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nose单元测试执行顺序&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://tokyle.com/categories/python/"/>
    
    
      <category term="nose" scheme="http://tokyle.com/tags/nose/"/>
    
      <category term="单元测试" scheme="http://tokyle.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基于python3的appium UI自动化框架搭建系列（一）</title>
    <link href="http://tokyle.com/2018/02/07/%E5%9F%BA%E4%BA%8Epython3%E7%9A%84appium-UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://tokyle.com/2018/02/07/基于python3的appium-UI自动化框架搭建系列（一）/</id>
    <published>2018-02-07T01:40:24.000Z</published>
    <updated>2018-02-07T02:28:52.952Z</updated>
    
    <content type="html"><![CDATA[<p>基于python3搭建appium ui自动化测试框架尝试系列（一）</p><a id="more"></a><h3 id="框架实现目标"><a href="#框架实现目标" class="headerlink" title="框架实现目标"></a>框架实现目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">自动找设备，连接设备</span><br><span class="line">自动启动appium server</span><br><span class="line">使用yml编写用例</span><br><span class="line">配置信息储存在ini文件或conf文件中</span><br><span class="line">自定义log，断言失败截图</span><br><span class="line">用例框架使用unittest或者nose</span><br><span class="line">用例报告html，用例执行完成邮件发送，附件测试报告</span><br><span class="line">多线程执行用例，失败重跑机制</span><br><span class="line">android自动监控权限弹窗</span><br><span class="line">执行过程红性能捕获（adb或者其他形式）</span><br></pre></td></tr></table></figure><h3 id="基于ddt和nose的简单尝试"><a href="#基于ddt和nose的简单尝试" class="headerlink" title="基于ddt和nose的简单尝试"></a>基于ddt和nose的简单尝试</h3><p>当前我能实现的appium自动化测试还是需要手动去起<code>appium server</code>，这点后面需要改善，github上有很多已经实现了的框架，但是不是很想直接拿来用，还是希望能够自己去一点一点的搭建。</p><p>即使是简单的尝试，还是想尽量实现多模块。</p><h4 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h4><p>邮箱配置：包含邮件收发件人，密码，服务器等信息配置；<br>日志配置：包含日志级别，时间格式，流处理器等；<br>文件夹创建：包含获取当前日期，时间，创建文件夹等；</p><p>其实在之前的博客中已经实现，就不再贴代码了：</p><blockquote><p><a href="http://tokyle.com/2018/02/01/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB/">邮箱配置</a><br><a href="http://tokyle.com/2018/02/02/logging%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/">日志配置</a></p></blockquote><p>文件夹创建是为了在测试过程中，出现断言失败的场景进行截图保存，文件夹使用两层，上一层为当前日期，下一层为当前时间，截图保存名字为断言失败的名字：<br><code>MakeDirs.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: kyle</span><br><span class="line">@time: 2018/2/7 10:17</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import time,os</span><br><span class="line">import traceback</span><br><span class="line">from datetime import datetime as dt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getCurrentDate():</span><br><span class="line">    &quot;&quot;&quot;获取当前日期&quot;&quot;&quot;</span><br><span class="line">    date  = time.localtime()</span><br><span class="line">    today = str(date.tm_year) + &quot;-&quot; + str(date.tm_mon) + &quot;-&quot; + str(date.tm_mday)</span><br><span class="line">    return today</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getCurrentTime():</span><br><span class="line">    &quot;&quot;&quot;获取当前时间&quot;&quot;&quot;</span><br><span class="line">    time_str = dt.now()</span><br><span class="line">    now = time_str.strftime(&apos;%H-%M-%S&apos;)</span><br><span class="line">    return now</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def createDir():</span><br><span class="line">    &quot;&quot;&quot;获取当前文件所在路径绝对路径&quot;&quot;&quot;</span><br><span class="line">    current_path = os.path.abspath(&apos;.&apos;)</span><br><span class="line">    # 获取当前日期</span><br><span class="line">    today = getCurrentDate()</span><br><span class="line">    # 构造以今天日期命名的目录的绝对路径</span><br><span class="line">    date_dir = os.path.join(current_path, today)</span><br><span class="line">    print(date_dir)</span><br><span class="line"></span><br><span class="line">    if not os.path.exists(date_dir):</span><br><span class="line">        # 如果以今天日期命名的目录不存在则创建</span><br><span class="line">        os.mkdir(date_dir)</span><br><span class="line">        # 获取当前时间字符串</span><br><span class="line">        now = getCurrentTime()</span><br><span class="line">        # 构造以当前时间命名的目录的绝对路径</span><br><span class="line">        time_dir = os.path.join(date_dir, now)</span><br><span class="line">        print(time_dir)</span><br><span class="line">        if not os.path.exists(time_dir):</span><br><span class="line">            # 如果以当前时间命名的目录不存在则创建</span><br><span class="line">            os.mkdir(time_dir)</span><br><span class="line">        return time_dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def takeScreenShot(driver, save_path, pic_name):</span><br><span class="line">    &quot;&quot;&quot;截屏&quot;&quot;&quot;</span><br><span class="line">    pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;)</span><br><span class="line">    try:</span><br><span class="line">        driver.get_screenshot_as_file(pic_path)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(traceback.print_exc(), e)</span><br></pre></td></tr></table></figure><h4 id="执行模块"><a href="#执行模块" class="headerlink" title="执行模块"></a>执行模块</h4><p>实现思路是<code>ddt</code>获取数据对象，进行测试数据和代码分离，数据对象包含输入数据以及预期结果，对预期结果进行断言，实现测试实现。<br>以百度搜索测试为例:<br><code>DataDriverByObj.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import ddt,time</span><br><span class="line">import traceback,logging</span><br><span class="line">from DdtTools.Log import *</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from nose.tools import assert_true</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">from datetime import datetime as dt</span><br><span class="line">from DdtTools.MailSend import MailSend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ddt.ddt</span><br><span class="line">class TestDDTByObj():</span><br><span class="line">    &quot;&quot;&quot;数据驱动测试&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;初始化&quot;&quot;&quot;</span><br><span class="line">        self.browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    @ddt.data(</span><br><span class="line">        [u&quot;龙猫&quot;, &quot;宫崎骏&quot;],</span><br><span class="line">        [u&quot;大话西游之月光宝盒&quot;, &quot;周星驰&quot;],</span><br><span class="line">        [u&quot;卧虎藏龙&quot;, &quot;李安&quot;]</span><br><span class="line">    )</span><br><span class="line">    @ddt.unpack</span><br><span class="line">    def test_dataDrivenByObj(self, testdata, expectdata):</span><br><span class="line">        url = &quot;https://www.baidu.com&quot;</span><br><span class="line">        self.browser.get(url)</span><br><span class="line">        # 隐式等待10s</span><br><span class="line">        self.browser.implicitly_wait(10)</span><br><span class="line">        try:</span><br><span class="line">            # 定位搜索输入框，并输入测试数据</span><br><span class="line">            self.browser.find_element_by_id(&apos;kw&apos;).send_keys(testdata)</span><br><span class="line">            # 定位搜索按键，单击</span><br><span class="line">            self.browser.find_element_by_id(&apos;su&apos;).click()</span><br><span class="line">            time.sleep(3)</span><br><span class="line">            # 断言期望结果是否出现在页面源码中</span><br><span class="line">            assert_true(expectdata in self.browser.page_source)</span><br><span class="line">        except NoSuchElementException as e:</span><br><span class="line">            logging.error(u&quot;查找的页面元素不存在，异常堆栈信息：&quot; + str(traceback.print_exc()))</span><br><span class="line"></span><br><span class="line">        except AssertionError as e:</span><br><span class="line">            info(u&quot;搜索：&#123;0&#125;，期望：&#123;1&#125;，失败&quot;.format(testdata, expectdata))</span><br><span class="line">        except Exception as e:</span><br><span class="line">            logging.error(u&quot;未知错误，错误信息：&quot; + str(traceback.print_exc()))</span><br><span class="line">        else:</span><br><span class="line">            info(u&quot;搜索：&#123;0&#125;，期望：&#123;1&#125;，通过&quot;.format(testdata, expectdata))</span><br><span class="line"></span><br><span class="line">        time.sleep(2)</span><br><span class="line">        self.browser.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # mail_subject, report_file</span><br><span class="line">    mail_subject = &apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;))</span><br><span class="line">    report_file = &apos;D:/bug_things/selenium/report/DDTByObj.html&apos;</span><br><span class="line">    mailsend = MailSend(mail_subject, report_file)</span><br><span class="line"></span><br><span class="line">    print(&apos;开始执行自动化测试...&apos;)</span><br><span class="line">    os.system(&apos;nosetests -v &#123;0&#125; --with-html --html-file=&#123;1&#125;&apos;.format(__file__, report_file))</span><br><span class="line">    # 发送测试报告邮件</span><br><span class="line">    print(&apos;开始发送测试报告...&apos;)</span><br><span class="line">    mailsend.sendMail()</span><br><span class="line">    print(&apos;测试报告发送完成...&apos;)</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>差不多现在还是实现到现在的程度，后面至少可以优化，测试数据从<code>xls</code>，<code>xml</code>，<code>excel</code>，<code>mysql</code>中读取。<br>（感觉自己现在实现的还是好弱。。。）</p><p>附上github上已经实现的框架，供参考，建议还是自己去一点一点的搭建，直接用个人觉得是有点功利的做法了，写代码，还是慢慢来的好。</p><blockquote><p><a href="https://github.com/NetEaseGame/ATX" target="_blank" rel="noopener">ATX</a><br><a href="https://github.com/ztwo/Auto_Analysis" target="_blank" rel="noopener">Auto_Analysis</a><br><a href="https://github.com/Louis-me/appium" target="_blank" rel="noopener">APPIUM</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于python3搭建appium ui自动化测试框架尝试系列（一）&lt;/p&gt;
    
    </summary>
    
      <category term="appium ui框架" scheme="http://tokyle.com/categories/appium-ui%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="nose" scheme="http://tokyle.com/tags/nose/"/>
    
      <category term="ddt" scheme="http://tokyle.com/tags/ddt/"/>
    
  </entry>
  
  <entry>
    <title>【转】python实现chrome伪装成M站</title>
    <link href="http://tokyle.com/2018/02/06/%E3%80%90%E8%BD%AC%E3%80%91python%E5%AE%9E%E7%8E%B0chrome%E4%BC%AA%E8%A3%85%E6%88%90M%E7%AB%99/"/>
    <id>http://tokyle.com/2018/02/06/【转】python实现chrome伪装成M站/</id>
    <published>2018-02-06T03:29:28.000Z</published>
    <updated>2018-02-06T03:32:14.938Z</updated>
    
    <content type="html"><![CDATA[<p>selenium实现Chrome伪装成M站，模拟手机端浏览器，并完成页面操作</p><a id="more"></a><p>原理：<br>通过<code>--user-agent=&quot;xxx&quot;</code>来修改HTTP请求头部的Agent字符串，设置个人代理，使得PC端的Chrome浏览器伪装成手机浏览器，可以在地址栏输入”about:version”查看修改效果。</p><p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from Log import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestMobile():</span><br><span class="line">    &quot;&quot;&quot;测试chrome伪装成手机M站&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def test_iPadChrome(self):</span><br><span class="line">        # 添加chrome设置</span><br><span class="line">        info(u&quot;===========伪装成ipad==========&quot;)</span><br><span class="line">        info(u&quot;=====开始设置ipad个人代理=====&quot;)</span><br><span class="line">        options = webdriver.ChromeOptions()</span><br><span class="line">        options.add_argument(</span><br><span class="line">            &apos;--user-agent=Mozilla/5.0(iPad; CPU OS 5_0 like Mac OS X)&apos;</span><br><span class="line">            &apos;AppleWebKit/534.46(KHTML, like Gecko) Version/5.1&apos;</span><br><span class="line">            &apos;Mobile/9A334 Safari/7534.48.3&apos;</span><br><span class="line">        )</span><br><span class="line">        browser = webdriver.Chrome(chrome_options=options)</span><br><span class="line">        browser.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        browser.find_element_by_id(&apos;kw&apos;).send_keys(&quot;iPad&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        # 通过在Chrome浏览器地址栏输入about:version，查看伪装效果</span><br><span class="line">        browser.get(&quot;about:version&quot;)</span><br><span class="line">        # 人工确认“用户代理”项配置信息是否和设置一致</span><br><span class="line">        time.sleep(10)</span><br><span class="line">        info(u&quot;==========伪装ipad成功==========&quot;)</span><br><span class="line">        browser.quit()</span><br><span class="line"></span><br><span class="line">    def test_iPhoneChrome(self):</span><br><span class="line">        # 添加chrome配置</span><br><span class="line">        info(u&quot;==========测伪装成iphone==========&quot;)</span><br><span class="line">        info(u&quot;=====设置iphone个人代理=====&quot;)</span><br><span class="line">        options = webdriver.ChromeOptions()</span><br><span class="line">        options.add_argument(</span><br><span class="line">            &apos;--user-agent=Mozilla/5.0 (iPhone; CPU iPhone OS 5_0 like Mac OS X)&apos;</span><br><span class="line">            &apos;AppleWebKit/534.46(KHTML, like Gecko) Version/5.1&apos;</span><br><span class="line">            &apos;Mobile/9A334 Safari/7534.48.3&apos;</span><br><span class="line">        )</span><br><span class="line">        browser = webdriver.Chrome(chrome_options=options)</span><br><span class="line">        browser.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        # 定位搜索框</span><br><span class="line">        browser.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;iPhone&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        browser.get(&quot;about:version&quot;)</span><br><span class="line">        time.sleep(10)</span><br><span class="line">        info(u&quot;==========伪装成iphone成功==========&quot;)</span><br><span class="line">        browser.quit()</span><br><span class="line"></span><br><span class="line">    def testAndroid236Chrome(self):</span><br><span class="line">        info(u&quot;==========测试伪装成android2.3.6==========&quot;)</span><br><span class="line">        info(u&quot;=====设置android2.3.6个人代理=====&quot;)</span><br><span class="line">        options = webdriver.ChromeOptions()</span><br><span class="line">        options.add_argument(</span><br><span class="line">            &apos;--user-agent=Mozilla/5.0 (Linux; U; Android 2.3.5; en-us)&apos;</span><br><span class="line">            &apos;Nexus S Build/GRK39F) AppleWebKit/533.1&apos;</span><br><span class="line">            &apos;(KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&apos;</span><br><span class="line">        )</span><br><span class="line">        brower = webdriver.Chrome(chrome_options=options)</span><br><span class="line">        brower.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">        # 定位搜索输入框</span><br><span class="line">        brower.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;Android 2.3.6&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        brower.get(&quot;about:version&quot;)</span><br><span class="line">        time.sleep(10)</span><br><span class="line">        info(u&quot;==========伪装成android2.3.6成功==========&quot;)</span><br><span class="line">        brower.quit()</span><br><span class="line"></span><br><span class="line">    def testAndroid402Chrome(self):</span><br><span class="line">        info(u&quot;==========测试伪装成android4.0.2==========&quot;)</span><br><span class="line">        info(u&quot;=====设置android4.0.2个人代理&quot;)</span><br><span class="line">        options = webdriver.ChromeOptions()</span><br><span class="line">        options.add_argument(</span><br><span class="line">            &apos;--user-agent=Mozilla/5.0 (Linux; U; Android 4.0.2;&apos;</span><br><span class="line">            &apos;en-us; Galaxy Nexus Build/ICL53F) AppleWebKit/534.30&apos;</span><br><span class="line">            &apos;(KHTML, like Gecko) Version/4.0 Mobile Safari/534.30&apos;</span><br><span class="line">        )</span><br><span class="line">        browser = webdriver.Chrome(chrome_options=options)</span><br><span class="line">        browser.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        browser.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;Android 4.0.2&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        browser.get(&quot;about:version&quot;)</span><br><span class="line">        time.sleep(10)</span><br><span class="line">        info(u&quot;==========伪装成android4.0.2成功==========&quot;)</span><br><span class="line">        browser.quit()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    testmobile = TestMobile()</span><br><span class="line">    testmobile.testAndroid402Chrome()</span><br><span class="line">    testmobile.testAndroid236Chrome()</span><br><span class="line">    testmobile.test_iPhoneChrome()</span><br><span class="line">    testmobile.test_iPadChrome()</span><br></pre></td></tr></table></figure></p><p>偶然看见这个实现，目前没想到应用场景。。直接使用appium进行移动自动化好像也能实现啊。。（可能工作中遇见的太少了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;selenium实现Chrome伪装成M站，模拟手机端浏览器，并完成页面操作&lt;/p&gt;
    
    </summary>
    
      <category term="selenium" scheme="http://tokyle.com/categories/selenium/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>logging模块使用简介</title>
    <link href="http://tokyle.com/2018/02/02/logging%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://tokyle.com/2018/02/02/logging模块使用简介/</id>
    <published>2018-02-02T09:17:58.000Z</published>
    <updated>2018-02-05T03:47:02.809Z</updated>
    
    <content type="html"><![CDATA[<p>python3日志模块，logging使用简介</p><a id="more"></a><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>python3使用<code>logging</code>进行日志打印，很简单，直接引<code>logging</code>包即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">logging.warning(&quot;This is warning message&quot;)</span><br><span class="line">logging.critical(&quot;This is critical message&quot;)</span><br><span class="line">logging.error(&quot;This is error message&quot;)</span><br><span class="line"># 打印结果</span><br><span class="line">WARNING:root:This is warning message</span><br><span class="line">CRITICAL:root:This is critical message</span><br><span class="line">ERROR:root:This is error message</span><br></pre></td></tr></table></figure></p><p>默认情况下只显示了大于等于WARNING级别的日志。<br><strong>日志级别</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">critical(50) &gt; error(40) &gt; warning(30) &gt; info(20) &gt; debug(10)</span><br></pre></td></tr></table></figure></p><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>通过<code>logging.basicConfig</code>函数对日志的输出格式及方式做相关配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=&apos;test.log&apos;,</span><br><span class="line">    format=&apos;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&apos;,</span><br><span class="line">    datefmt=&apos;%Y-%m-%d %H-%M-%S&apos;,</span><br><span class="line">    level=logging.DEBUG,</span><br><span class="line">    #level=10</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.critical(&quot;This ia critical message&quot;)</span><br><span class="line">logging.error(&quot;This is error message&quot;)</span><br><span class="line">logging.warning(&quot;This is warning message&quot;)</span><br><span class="line">logging.info(&quot;This is info message&quot;)</span><br><span class="line">logging.debug(&quot;This is debug message&quot;)</span><br></pre></td></tr></table></figure></p><p><strong>logging.basicConfig</strong>函数各参数</p><p>1.filename：指定日志文件名<br>2.filemode：和file函数意义相同，指定日志文件的打开模式，’w’或’a’；默认为’a’表示“append”。<br>3.format：指定输出的格式和内容，format可以输出很多有用信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">format参数中可能用到的格式化串：</span><br><span class="line">%(name)s Logger的名字</span><br><span class="line">%(levelno)s 数字形式的日志级别</span><br><span class="line">%(levelname)s 文本形式的日志级别</span><br><span class="line">%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line">%(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line">%(module)s 调用日志输出函数的模块名</span><br><span class="line">%(funcName)s 调用日志输出函数的函数名</span><br><span class="line">%(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line">%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line">%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line">%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</span><br><span class="line">%(thread)d 线程ID。可能没有</span><br><span class="line">%(threadName)s 线程名。可能没有</span><br><span class="line">%(process)d 进程ID。可能没有</span><br><span class="line">%(message)s用户输出的消息</span><br></pre></td></tr></table></figure><p>4.datefmt：指定时间格式，同time.strftime()<br>5.level：设置日志级别，默认为logging.WARNING<br>6.stream：指定将日志的输出流，可以指定输出到<code>sys.stderr</code>，<code>sys.stdout</code>或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略</p><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><p>若要对logging进行更多灵活的控制，必须了解Logger，Handler，Formatter，Filter的概念：<br>logger提供了应用程序可以直接使用的接口；<br>handle将（logger创建的）日志记录发送到合适的目的输出；<br>filter提供了细度设备来决定输出哪条日志记录；<br>formatter决定日志记录的最终输出格式；</p><h4 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h4><p>每个程序在输出信息之前都要获得一个Logger。Logger通常对应了程序的模块名，比如聊天工具的图形界面模块可以这样获得它的Logger：<br>LOG=logging.getLogger(”chat.gui”)<br>而核心模块可以这样：<br>LOG=logging.getLogger(”chat.kernel”)</p><p>Logger.setLevel(lel):指定最低的日志级别，低于lel的级别将被忽略。debug是最低的内置级别，critical为最高<br>Logger.addFilter(filt)、Logger.removeFilter(filt):添加或删除指定的filter<br>Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)：增加或删除指定的handler<br>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()：可以设置的日志级别</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>handler对象负责发送相关的信息到指定目的地。Python的日志系统有多种Handler可以使用。有些Handler可以把信息输出到控制台，有些Logger可以把信息输出到文件，还有些Handler可以把信息发送到网络上。如果觉得不够用，还可以编写自己的Handler。可以通过addHandler()方法添加多个多handler<br>Handler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略<br>Handler.setFormatter()：给这个handler选择一个格式<br>Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象</p><p>每个Logger可以附加多个Handler。接下来我们就来介绍一些常用的Handler：</p><h5 id="1-logging-StreamHandler"><a href="#1-logging-StreamHandler" class="headerlink" title="1) logging.StreamHandler"></a>1) logging.StreamHandler</h5><p>使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息。它的构造函数是:StreamHandler([strm])<br>其中strm参数是一个文件对象。默认是sys.stderr</p><h5 id="2-logging-FileHandler"><a href="#2-logging-FileHandler" class="headerlink" title="2) logging.FileHandler"></a>2) logging.FileHandler</h5><p>和StreamHandler类似，用于向一个文件输出日志信息。不过FileHandler会帮你打开这个文件。它的构造函数是：FileHandler(filename[,mode])<br>filename是文件名，必须指定一个文件名。<br>mode是文件的打开方式。参见Python内置函数open()的用法。默认是’a’，即添加到文件末尾。</p><h5 id="3-logging-handlers-RotatingFileHandler"><a href="#3-logging-handlers-RotatingFileHandler" class="headerlink" title="3) logging.handlers.RotatingFileHandler"></a>3) logging.handlers.RotatingFileHandler</h5><p>这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。它的构造函数是：<br>RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])<br>其中filename和mode两个参数和FileHandler一样。<br>maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。<br>backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。</p><h5 id="4-logging-handlers-TimedRotatingFileHandler"><a href="#4-logging-handlers-TimedRotatingFileHandler" class="headerlink" title="4) logging.handlers.TimedRotatingFileHandler"></a>4) logging.handlers.TimedRotatingFileHandler</h5><p>这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。它的构造函数是：<br>TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])<br>其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。<br>interval是时间间隔。<br>when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：<br>S 秒<br>M 分<br>H 小时<br>D 天<br>W 每星期（interval==0时代表星期一）<br>midnight 每天凌晨</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>日志的一般操作顺序为：<br>1.创建一个流类型handler用于输出日志到控制台(控制器)<br>2.定义输出日志级别<br>3.定义handler的输出格式formatter<br>4.将handler添加到logging对象</p><h4 id="同时输出日志到控制台和文件"><a href="#同时输出日志到控制台和文件" class="headerlink" title="同时输出日志到控制台和文件"></a>同时输出日志到控制台和文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=&apos;test.log&apos;,</span><br><span class="line">    format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&apos;,</span><br><span class="line">    datefmt=&apos;%Y-%m-%d %H-%M-%S&apos;,</span><br><span class="line">    level=10</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 定义一个StreamHandler(日志流处理器)，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象</span><br><span class="line">console = logging.StreamHandler()</span><br><span class="line">console.setLevel(logging.INFO)</span><br><span class="line"># 格式化，设置控制台的日志输出格式</span><br><span class="line">formatter = logging.Formatter(&apos;%(name)-12s: %(levelname)-8s %(message)s&apos;)</span><br><span class="line"># 定义控制器的日志输出格式</span><br><span class="line">console.setFormatter(formatter)</span><br><span class="line"># 将控制器添加到logging对象</span><br><span class="line">logging.getLogger(&apos;&apos;).addHandler(console)</span><br><span class="line"></span><br><span class="line">logging.critical(&quot;This is critical message&quot;)</span><br><span class="line">logging.error(&quot;This is error message&quot;)</span><br><span class="line">logging.warning(&quot;This is warning message&quot;)</span><br><span class="line">logging.info(&quot;This is info message&quot;)</span><br><span class="line">logging.debug(&quot;This is debug message&quot;)</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>用法类似于java中的log4j的logging.config，我们也可以自己配置<code>logger.conf</code>文件：</p><h4 id="Logger-conf"><a href="#Logger-conf" class="headerlink" title="Logger.conf"></a>Logger.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">###############################################</span><br><span class="line">[loggers]</span><br><span class="line">keys=root,example01,example02</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line"></span><br><span class="line">handlers=hand01,hand02</span><br><span class="line"></span><br><span class="line">[logger_example01]</span><br><span class="line">handlers=hand01,hand02</span><br><span class="line">qualname=example01</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[logger_example02]</span><br><span class="line">handlers=hand01,hand03</span><br><span class="line">qualname=example02</span><br><span class="line">propagate=0</span><br><span class="line">###############################################</span><br><span class="line">[handlers]</span><br><span class="line">keys=hand01,hand02,hand03</span><br><span class="line"></span><br><span class="line">[handler_hand01]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form02</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line">[handler_hand02]</span><br><span class="line">class=FileHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=form01</span><br><span class="line">args=(&apos;D:/bug_things/selenium/logs/AutoTest.log&apos;, &apos;a&apos;, &apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">[handler_hand03]</span><br><span class="line">class=handlers.RotatingFileHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form02</span><br><span class="line">args=(&apos;D:/bug_things/selenium/logs/AutoTest.log&apos;, &apos;a&apos;, 10*1024*1024, 5, &apos;utf-8&apos;)</span><br><span class="line">###############################################</span><br><span class="line">[formatters]</span><br><span class="line">keys=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br><span class="line">datefmt=%a, %d %b %Y %H:%M:%S</span><br><span class="line"></span><br><span class="line">[formatter_form02]</span><br><span class="line">format=%(name)-12s: %(levelname)-8s %(message)s</span><br><span class="line">datefmt=%Y %m %d %H %M %S</span><br></pre></td></tr></table></figure><h4 id="封装方法"><a href="#封装方法" class="headerlink" title="封装方法"></a>封装方法</h4><p>将配置文件中定义的日志打印的配置进行封装，生成<code>debug</code>，<code>info</code>，<code>message</code>方法：<br>Log.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import logging.config</span><br><span class="line"></span><br><span class="line">logging.config.fileConfig(&quot;Logger.conf&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def debug(message):</span><br><span class="line">    # 打印debug级别的日志方法</span><br><span class="line">    logging.debug(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def warning(message):</span><br><span class="line">    # 打印warning级别的日志方法</span><br><span class="line">    logging.warning(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def info(message):</span><br><span class="line">    # 打印info级别的日志方法</span><br><span class="line">    logging.info(message)</span><br></pre></td></tr></table></figure></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>以百度搜索为例:<br>BaiDu.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from Log import *</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestBaiDuSearch():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 启动浏览器</span><br><span class="line">        self.browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    def test_baidu_search(self):</span><br><span class="line">        info(u&quot;===================搜索====================&quot;)</span><br><span class="line">        url = &quot;https://www.baidu.com&quot;</span><br><span class="line">        self.browser.get(url)</span><br><span class="line">        info(u&quot;访问百度首页&quot;)</span><br><span class="line">        self.browser.find_element_by_id(&apos;kw&apos;).send_keys(u&quot;自动化测试&quot;)</span><br><span class="line">        info(u&quot;在输入框中搜索关键字“自动化测试”&quot;)</span><br><span class="line">        self.browser.find_element_by_id(&apos;su&apos;).click()</span><br><span class="line">        info(u&quot;单击搜索按键&quot;)</span><br><span class="line">        info(u&quot;=================测试执行结束================&quot;)</span><br><span class="line"></span><br><span class="line">        time.sleep(3)</span><br><span class="line">        self.browser.quit()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    testbaidu = TestBaiDuSearch()</span><br><span class="line">    testbaidu.test_baidu_search()</span><br></pre></td></tr></table></figure></p><p>执行BaiDu.py文件，在<code>D:/bug_things/selenium/logs</code>目录下会生成<code>AutoTest.log</code>日志文件，文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fri, 02 Feb 2018 17:10:52 Log.py[line:20] INFO ===================搜索====================</span><br><span class="line">Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 访问百度首页</span><br><span class="line">Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 在输入框中搜索关键字“自动化测试”</span><br><span class="line">Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 单击搜索按键</span><br><span class="line">Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO =================测试执行结束================</span><br></pre></td></tr></table></figure></p><p>同时控制台打印信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root        : INFO     ===================搜索====================</span><br><span class="line">root        : INFO     访问百度首页</span><br><span class="line">root        : INFO     在输入框中搜索关键字“自动化测试”</span><br><span class="line">root        : INFO     单击搜索按键</span><br><span class="line">root        : INFO     =================测试执行结束================</span><br></pre></td></tr></table></figure></p><blockquote><p><a href="http://blog.csdn.net/a953713428/article/details/78648298" target="_blank" rel="noopener">参考文章</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python3日志模块，logging使用简介&lt;/p&gt;
    
    </summary>
    
      <category term="python黑科技" scheme="http://tokyle.com/categories/python%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
    
      <category term="selenium" scheme="http://tokyle.com/tags/selenium/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="logging" scheme="http://tokyle.com/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>字符编码简单总结</title>
    <link href="http://tokyle.com/2018/02/02/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://tokyle.com/2018/02/02/字符编码简单总结/</id>
    <published>2018-02-02T05:14:36.000Z</published>
    <updated>2018-02-02T05:17:17.899Z</updated>
    
    <content type="html"><![CDATA[<p>python字符串和编码</p><a id="more"></a><p>首先，字符串是一种数据类型，我们还经常会用到，然后，最常见的字符串问题就是字符编码问题，经常会看见文件打开一堆乱码，然后手工转<code>utf-8</code>啥的。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><h4 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h4><p>计算机能够处理的只有数字，所以其他类型的数据想要被计算机识别并处理，首先要进行的就是字符编码，转换成数字之后处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是(11111111,二进制的255)，如果要表示更大的整数，就必须更多的字节，比如两个字节可以表示最大整数是65535。</p><p>上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。<br>ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。</p><h4 id="字库表"><a href="#字库表" class="headerlink" title="字库表"></a>字库表</h4><p>字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。</p><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>字符集是一个系统支持的所有抽象字符的集合。常见的字符集有<code>ASCII</code>，<code>UTF-8</code>，<code>UTG-16</code>，<code>GB2313</code>等。</p><h4 id="字符编码-1"><a href="#字符编码-1" class="headerlink" title="字符编码"></a>字符编码</h4><p>字符编码可以看成是一套规则，目的就是在符号集合和数字系统直接建立对应关系。常见的字符编码有<code>Unicode</code>，<code>ASCII</code>，<code>UTF-8</code>等</p><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><p>字库表可以看成是一个全球统一的可读可用的字符库，但是实际使用过程中，很少需要用到这么多字符，例如，中文系统基本就用不到日文的字符，所以也就不需要日文字符的那一部分集合；因此就会诞生一个个的类似于定制的字符集合，这就是字符集，集合中包含了数据和字母的一个个对应关系，这就是字符编码。以ASCII为例：</p><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。它是现今最通用的单字节编码系统（但是有被Unicode追上的迹象），并等同于国际标准ISO/IEC 646。</p><p>ASCII字符集：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p>ASCII编码：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。</p><h3 id="python字符编码"><a href="#python字符编码" class="headerlink" title="python字符编码"></a>python字符编码</h3><p>ASCII是出现比较早的字符编码，但是其中只包含了数字和英文大小写字符，对于中文，日文等字符就不适用了，国内学者为了能够完成中文编码，就指定了<code>GB2312</code>编码，同样的，很多国家都有指定自己的编码，这样就会遇到一个问题，中文编码到日文编码的环境查看，会发生乱码，因为根本就不支持这样的字符，为了解决这个问题，一个统一的编码就诞生了<code>Unicode</code>，Unicode编码不同于ASCII的使用一个字节表示一个字符，它使用的是两个字节表示一个字符（中文至少需要两个字节），生僻字符就需要4个字符。<br>字母’A’用ASCII编码，十进制是<code>65</code>，二进制是<code>01000001</code>；用Unicode编码结果是<code>00000000 01000001</code>。<br>当全部都使用Unicode编码时，乱码问题肯定是得到解决了，但是有个问题，Unicode编码时连个字节表示的一个字符，那么就会比原来使用ASCII编码多出了至少一倍的内存空间占用，怎么都觉得很亏。<br>所以，为了节约内存空间，又出现了把Unicode编码转换为“可变长编码”的<code>utf-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。</p><p>下面来弄清楚python的字符编码：<br>在python3中，字符串是以Unicode编码的，也就是说，支持多语言。由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。<br><strong>Python对bytes类型的数据用带b前缀的单引号或双引号表示</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b&apos;ABC&apos;</span><br></pre></td></tr></table></figure></p><p>注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。<br>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</p><h3 id="编码及解码"><a href="#编码及解码" class="headerlink" title="编码及解码"></a>编码及解码</h3><p>首先python使用的是Unicode编码，字符串进行网络或者磁盘存储时，需要先编码成指定类型<code>bytes</code>，使用<code>encode()</code>方法即可。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure></p><p>反过来，从网络或者磁盘上读取字节流，那么读到的数据是<code>bytes</code>，要把<code>bytes</code>转换为<code>str</code>，就需要使用<code>decode()</code>方法进行解码，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;))</span><br><span class="line">中文</span><br></pre></td></tr></table></figure></p><p>在进行日常python编程中，在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure></p><p>pycharm设置方法：<br><code>File-Settings-Editor-File and Code Templates-Python Script</code>设置中添加上这两行即可。</p><p>以前曾经写过一篇博，关于设置python编码的:<a href="http://tokyle.com/2017/12/13/python%E7%BC%96%E7%A0%81/">python编码</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">廖雪峰的python教程</a><br><a href="https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="noopener">字符集合字符编码</a></p></blockquote><p>后记：由于昨天公司发生的很无语加无理取闹的一些事，整个办公室氛围都是压抑的，网上的教程资料也没怎么细致的看进去，写出来的总结也就是乱七八糟的，估计静下来之后我自己都看不懂。。。以后再来修改吧。唉，做技术的，干嘛不追求技术的进步，弄一些有的没的办公室政治呢，有意思吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python字符串和编码&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://tokyle.com/categories/python/"/>
    
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>实现断言失败截图</title>
    <link href="http://tokyle.com/2018/02/02/%E5%AE%9E%E7%8E%B0%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5%E6%88%AA%E5%9B%BE/"/>
    <id>http://tokyle.com/2018/02/02/实现断言失败截图/</id>
    <published>2018-02-02T02:18:12.000Z</published>
    <updated>2018-02-02T02:27:54.635Z</updated>
    
    <content type="html"><![CDATA[<p>python基于selenium进行自动化测试，实现断言失败进行截图</p><a id="more"></a><p>进行自动化测试过程中，经常会遇见断言失败，时候补查失败的场景，要么是保存日志，要么就是保存失败的截图。尝试实现，在断言失败时候，加入实时截图：</p><h3 id="编码出错"><a href="#编码出错" class="headerlink" title="编码出错"></a>编码出错</h3><p>遇到问题：<br>截图文件名编码格式转换时候，会报错（以下写法在python 2.7可以使用）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pic_path = os.path.join(save_path, str(pic_name).decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;) + &quot;.png&quot;)</span><br></pre></td></tr></table></figure></p><p>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: &apos;str&apos; object has no attribute &apos;decode&apos;</span><br></pre></td></tr></table></figure></p><p>查找原因：<br>既然<code>python 2.7</code>可以正常执行，那就应该是<code>python 3</code>对于编码进行了变更。</p><p><code>Stack Overflow</code>上大家好像都是经常踩我踩过的所有坑..又找到答案了：<br>这位大哥的回答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Begin with Python 3, all string is unicode object.</span><br><span class="line">  a = &apos;Happy New Year&apos; # Python 3</span><br><span class="line">  b = unicode(&apos;Happy New Year&apos;) # Python 2</span><br><span class="line">the code before are same. So I think you should remove the .decode(&apos;utf-8&apos;). Because you have already get the unicode object.</span><br></pre></td></tr></table></figure></p><p>python3的普通字符串是str，所以python3的str就相当于python2的Unicode。大致意思好像就是python3使用的str类型并不关心你最终是什么编码，无论是utf-8还是gb2312，它只是用Unicode字符集编码来表示每一个字符，直到输出到文件流，需要转换为<code>bytes</code>类型时，才用encode指定具体的编码实现方式。</p><p>python的中间编码是Unicode，所以python2就需要先进行解码（decode）到中间编码，再进行编码（encode）到指定编；，而python3直接可以转换到指定编码（encode）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在python3中，str-- encode -&gt; bytes-- decode -&gt; str</span><br></pre></td></tr></table></figure></p><h3 id="python3编码"><a href="#python3编码" class="headerlink" title="python3编码"></a>python3编码</h3><p>系统编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"># 系统默认编码</span><br><span class="line">print(sys.getdefaultencoding())</span><br><span class="line"># 字符串编码</span><br><span class="line">s = &quot;中文&quot;</span><br><span class="line">s_utf8 = s.encode(&apos;utf-8&apos;)</span><br><span class="line">print(type(s))</span><br><span class="line">print(type(s_utf8))</span><br><span class="line"></span><br><span class="line">utf-8</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&lt;class &apos;bytes&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到，python3的系统编码就是<code>utf-8</code>，为了避免自找麻烦，牢记使用<code>utf-8</code>即可！<br>所以上述报错代码可以更改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="断言失败截图实例"><a href="#断言失败截图实例" class="headerlink" title="断言失败截图实例"></a>断言失败截图实例</h3><p>实现目标是在进行自动化测试过程中，一旦发生断言失败，就根据当前时间，在工程下创建名称为当前日期的目录，，目录下创建名称为当前时间的文件夹，文件夹中保存断言失败的屏幕截图</p><h4 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import time</span><br><span class="line">from datetime import datetime as dt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">用于获取当前的日期以及时间</span><br><span class="line">用于生成保存截图文件目录名</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def current_date():</span><br><span class="line">    date = time.localtime()</span><br><span class="line">    # 构造今天的日期字符串</span><br><span class="line">    today = str(date.tm_year) + &quot;-&quot; + str(date.tm_mon) + &quot;-&quot; + str(date.tm_mday)</span><br><span class="line">    return today</span><br><span class="line"></span><br><span class="line">def current_time():</span><br><span class="line">    time_str = dt.now()</span><br><span class="line">    # 构建当期时间字符串</span><br><span class="line">    now = time_str.strftime(&apos;%H-%M-%S&apos;)</span><br><span class="line">    return now</span><br></pre></td></tr></table></figure><h4 id="创建目录和文件夹"><a href="#创建目录和文件夹" class="headerlink" title="创建目录和文件夹"></a>创建目录和文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from DateUtil import current_time, current_date</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">用于创建目录，用于存放异常截图</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def create_dir():</span><br><span class="line">    # 获得当前文件所在目录的绝对路径</span><br><span class="line">    current_path = os.path.abspath(&apos;.&apos;)</span><br><span class="line">    # 获取今天的日期字符串</span><br><span class="line">    today = current_date()</span><br><span class="line">    # 构造以今天日期命名的目录的绝对路径</span><br><span class="line">    date_dir = os.path.join(current_path, today)</span><br><span class="line">    print(date_dir)</span><br><span class="line"></span><br><span class="line">    if not os.path.exists(date_dir):</span><br><span class="line">        # 如果以今天日期命名的目录不存在则创建</span><br><span class="line">        os.mkdir(date_dir)</span><br><span class="line">        # 获取当前的时间字符串</span><br><span class="line">        now = current_time()</span><br><span class="line">        # 构造以当前时间命名的目录的绝对路径</span><br><span class="line">        time_dir = os.path.join(date_dir, now)</span><br><span class="line">        print(time_dir)</span><br><span class="line">        if not os.path.exists(time_dir):</span><br><span class="line">            # 如果以当前时间命名的目录不存在则创建</span><br><span class="line">            os.mkdir(time_dir)</span><br><span class="line">        return time_dir</span><br></pre></td></tr></table></figure><h4 id="百度搜索示例"><a href="#百度搜索示例" class="headerlink" title="百度搜索示例"></a>百度搜索示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from FileUtil import create_dir</span><br><span class="line">from nose.tools import assert_true</span><br><span class="line">import time,os</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建存放异常截图的目录，并得到本次实例中存放图片目录的绝对路径，作为全局变量，供本次所有测试用例调用</span><br><span class="line">pic_dir = create_dir()</span><br><span class="line"></span><br><span class="line">def take_screenshot(driver, save_path, pic_name):</span><br><span class="line">    # 封装截屏方法</span><br><span class="line">    # 构造屏幕截图路径及图片名</span><br><span class="line">    # 因为windows默认编码是GBK，而传入的图片名是utf-8编码，所以需要进行转码，以便让图片名中的中文字符能够正常显示</span><br><span class="line">    pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;)</span><br><span class="line">    try:</span><br><span class="line">        # 调用webdriver提供的get_screenshot_as_file()方法，将截取的屏幕图片保存为本地文件</span><br><span class="line">        driver.get_screenshot_as_file(pic_path)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(traceback.print_exc(), e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestFailCaptureScreen():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        &quot;&quot;&quot;启动浏览器&quot;&quot;&quot;</span><br><span class="line">        self.browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    def test_baidu_search(self):</span><br><span class="line">        url = &quot;https://www.baidu.com&quot;</span><br><span class="line">        self.browser.get(url)</span><br><span class="line">        try:</span><br><span class="line">            self.browser.find_element_by_id(&apos;kw&apos;).send_keys(u&quot;自动化测试&quot;)</span><br><span class="line">            self.browser.find_element_by_id(&apos;su&apos;).click()</span><br><span class="line">            time.sleep(3)</span><br><span class="line">            # 断言页面的代码中是否存在“自动化测试框架_百度百科”这几个字</span><br><span class="line">            assert_true(u&quot;纯净方糖&quot; in self.browser.page_source)</span><br><span class="line">            # 页面中没有断言的几个字，所以会触发except语句的执行，并触发截图操作</span><br><span class="line">        except AssertionError as e:</span><br><span class="line">            take_screenshot(self.browser, pic_dir, e)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            take_screenshot(self.browser, pic_dir, e)</span><br><span class="line"></span><br><span class="line">        time.sleep(2)</span><br><span class="line">        self.browser.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    testfailscreen = TestFailCaptureScreen()</span><br><span class="line">    testfailscreen.test_baidu_search()</span><br></pre></td></tr></table></figure><p>感觉是时候研究一波python字符编码了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python基于selenium进行自动化测试，实现断言失败进行截图&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>实现自动化测试数据分离</title>
    <link href="http://tokyle.com/2018/02/01/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB/"/>
    <id>http://tokyle.com/2018/02/01/实现自动化测试数据分离/</id>
    <published>2018-02-01T05:48:19.000Z</published>
    <updated>2018-02-06T06:35:10.813Z</updated>
    
    <content type="html"><![CDATA[<p>使用数据分离自动化测试，测试执行完成自动邮件发送</p><a id="more"></a><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件中的内容为工程所有配置信息，各个模块的元素定位的方法以及值，服务器（应用服务器和数据库服务器）配置信息，用户账号密码等信息</p><p>实例，cashier.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[login]</span><br><span class="line">storeNo = id &gt; com.anmav.cashierdesk:id/etStoreNo</span><br><span class="line">username = id &gt; com.anmav.cashierdesk:id/login_accountEdt</span><br><span class="line">pwd = id &gt; com.anmav.cashierdesk:id/login_paswEdt</span><br><span class="line">login = id &gt; com.anmav.cashierdesk:id/tvLogin</span><br><span class="line">login_store = ***</span><br><span class="line">login_user = ***</span><br><span class="line">login_pwd = ***</span><br><span class="line"></span><br><span class="line">[mailmsg]</span><br><span class="line">mail_user = ***</span><br><span class="line">mail_pwd = ***</span><br><span class="line">mail_to = ***</span><br><span class="line">mail_host = ***</span><br></pre></td></tr></table></figure><p>该配置文件包含了<code>login</code>模块进行元素定位需要的方法以及值，在工程中进行元素定位值，只需要使用<code>configparser</code>模块完成配置文件读取即可。</p><h3 id="邮件发送数据分离"><a href="#邮件发送数据分离" class="headerlink" title="邮件发送数据分离"></a>邮件发送数据分离</h3><p>封装数据分离之后的邮件发送类(MailSend.py)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">import smtplib</span><br><span class="line">import configparser</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MailSend():</span><br><span class="line">    &quot;&quot;&quot;邮件发送&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, mail_subject, report_file):</span><br><span class="line">        self.mail_subject = mail_subject</span><br><span class="line">        self.report_file = report_file</span><br><span class="line">        self.settings = os.path.abspath(&apos;..&apos;) + &quot;\cashier_conf\cashier_setting.ini&quot;</span><br><span class="line"></span><br><span class="line">    def send_mail(self):</span><br><span class="line">        &quot;&quot;&quot;读取测试报告&quot;&quot;&quot;</span><br><span class="line">        cf = configparser.ConfigParser()</span><br><span class="line">        cf.read(self.settings)</span><br><span class="line">        cf.sections()</span><br><span class="line"></span><br><span class="line">        # 获取邮箱发件人，密码，收件人，邮件服务器</span><br><span class="line">        mail_user = cf.get(&apos;mailmsg&apos;, &apos;mail_user&apos;)</span><br><span class="line">        mail_pwd = cf.get(&apos;mailmsg&apos;, &apos;mail_pwd&apos;)</span><br><span class="line">        mail_to = cf.get(&apos;mailmsg&apos;, &apos;mail_to&apos;)</span><br><span class="line">        mail_host = cf.get(&apos;mailmsg&apos;, &apos;mail_host&apos;)</span><br><span class="line"></span><br><span class="line">        # 发送邮件配置</span><br><span class="line">        with open(self.report_file, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f_obj:</span><br><span class="line">            content = f_obj.read()</span><br><span class="line">        msg = MIMEMultipart(&apos;mixed&apos;)</span><br><span class="line">        # 添加邮件内容</span><br><span class="line">        msg_html = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;)</span><br><span class="line">        msg.attach(msg_html)</span><br><span class="line"></span><br><span class="line">        # 添加附件</span><br><span class="line">        msg_attachment = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;)</span><br><span class="line">        msg_attachment[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&#123;0&#125;&apos;.format(self.report_file)</span><br><span class="line">        msg.attach(msg_attachment)</span><br><span class="line"></span><br><span class="line">        msg[&apos;Subject&apos;] = self.mail_subject</span><br><span class="line">        msg[&apos;Form&apos;] = mail_user</span><br><span class="line">        msg[&apos;To&apos;] = mail_to</span><br><span class="line">        try:</span><br><span class="line">            # 连接邮箱服务器</span><br><span class="line">            s = smtplib.SMTP()</span><br><span class="line">            s.connect(mail_host)</span><br><span class="line">            # 登录</span><br><span class="line">            s.login(mail_user, mail_pwd)</span><br><span class="line">            # 发送邮件</span><br><span class="line">            s.sendmail(mail_user, mail_to, msg.as_string())</span><br><span class="line">            s.quit()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;发送邮件异常：&quot;, e)</span><br></pre></td></tr></table></figure></p><h3 id="元素定位数据分离"><a href="#元素定位数据分离" class="headerlink" title="元素定位数据分离"></a>元素定位数据分离</h3><p>封装了元素定位的方法（find_element_by…），实现在工程中进行元素定位时，直接调用方法(GetElement.py)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">import os</span><br><span class="line">import configparser</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GetElement():</span><br><span class="line">    &quot;&quot;&quot;获取元素定位方法和值&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 读取配置文件</span><br><span class="line">        self.settings = os.path.abspath(&apos;..&apos;) + &quot;/cashier_conf/cashier_setting.ini&quot;</span><br><span class="line">        self.cf = configparser.ConfigParser()</span><br><span class="line">        self.cf.read(self.settings)</span><br><span class="line">        self.cf.sections()</span><br><span class="line"></span><br><span class="line">    def get_elementId(self, driver, webSiteName, webelement):</span><br><span class="line">        try:</span><br><span class="line">            # 获取配置文件中的定位方法以及定位元素</span><br><span class="line">            webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;)</span><br><span class="line">            webelement_method = webElemnt[0].strip()</span><br><span class="line">            webelement_expression = webElemnt[1].strip()</span><br><span class="line">            element = WebDriverWait(driver, 10).until\</span><br><span class="line">                (lambda x: x.find_element(webelement_method, webelement_expression))</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(traceback.print_exc(), e)</span><br><span class="line">        else:</span><br><span class="line">            return element</span><br></pre></td></tr></table></figure></p><h3 id="自动化测试实现数据分离"><a href="#自动化测试实现数据分离" class="headerlink" title="自动化测试实现数据分离"></a>自动化测试实现数据分离</h3><p>使用数据分离的方式完成<strong>系统登录</strong>的自动化测试，方便维护，后期只需要维护<code>cashier_setting.ini</code>文件即可(testlogin.py)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import configparser, os</span><br><span class="line">import traceback</span><br><span class="line">from datetime import datetime as dt</span><br><span class="line">from appium import webdriver</span><br><span class="line">from nose.tools import assert_true</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException,TimeoutException</span><br><span class="line">from cashier_tools.GetElement import GetElement</span><br><span class="line">from cashier_tools.MailSend import MailSend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Login():</span><br><span class="line">    &quot;&quot;&quot;登录&quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化，配置环境</span><br><span class="line">        self.desired_caps = &#123;&#125;</span><br><span class="line">        self.desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">        self.desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos;</span><br><span class="line">        self.desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;</span><br><span class="line">        self.desired_caps[&apos;noReset&apos;] = True</span><br><span class="line">        self.desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos;</span><br><span class="line">        self.desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.login.activity.LoginActivity&apos;</span><br><span class="line"></span><br><span class="line">        self.driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, self.desired_caps)</span><br><span class="line">        self.elementid = GetElement()</span><br><span class="line"></span><br><span class="line">    def test_login(self):</span><br><span class="line">        settings = os.path.abspath(&apos;..&apos;) + &quot;/cashier_conf/cashier_setting.ini&quot;</span><br><span class="line">        cf = configparser.ConfigParser()</span><br><span class="line">        cf.read(settings)</span><br><span class="line">        cf.sections()</span><br><span class="line"></span><br><span class="line">        # 定位门店编号输入框</span><br><span class="line">        storeno = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;storeNo&apos;)</span><br><span class="line">        storeno.click()</span><br><span class="line">        storeno.clear()</span><br><span class="line">        store_no = cf.get(&apos;login&apos;, &apos;login_store&apos;)</span><br><span class="line">        storeno.send_keys(store_no)</span><br><span class="line">        self.driver.hide_keyboard()</span><br><span class="line"></span><br><span class="line">        # 定位用户名</span><br><span class="line">        username = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;username&apos;)</span><br><span class="line">        username.click()</span><br><span class="line">        username.clear()</span><br><span class="line">        user = cf.get(&apos;login&apos;, &apos;login_user&apos;)</span><br><span class="line">        username.send_keys(user)</span><br><span class="line">        self.driver.hide_keyboard()</span><br><span class="line"></span><br><span class="line">        # 定位密码</span><br><span class="line">        pwd = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;pwd&apos;)</span><br><span class="line">        pwd.click()</span><br><span class="line">        pwd.clear()</span><br><span class="line">        password = cf.get(&apos;login&apos;, &apos;login_pwd&apos;)</span><br><span class="line">        pwd.send_keys(password)</span><br><span class="line">        self.driver.hide_keyboard()</span><br><span class="line"></span><br><span class="line">        # 登录</span><br><span class="line">        self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;login&apos;).click()</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            # 显示等待，门店名称出现</span><br><span class="line">            WebDriverWait(self.driver, 10).until(lambda x:x.find_element_by_id(cf.get(&apos;order&apos;, &apos;store_name&apos;)))</span><br><span class="line">            # 断言登录成功</span><br><span class="line">            assert_true(u&quot;点餐&quot; in self.driver.page_source)</span><br><span class="line">        except NoSuchElementException as e:</span><br><span class="line">            print(traceback.print_exc(), e)</span><br><span class="line">        except TimeoutException as e:</span><br><span class="line">            print(traceback.print_exc(), e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    mail_subject = &apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;))</span><br><span class="line">    report_file = &apos;Login.html&apos;</span><br><span class="line">    mailsend = MailSend(mail_subject, report_file)</span><br><span class="line"></span><br><span class="line">    print(&apos;开始执行自动化测试...&apos;)</span><br><span class="line">    os.system(&apos;nosetests -v &#123;0&#125; --with-html --html-file=&#123;1&#125;&apos;.format(__file__, report_file))</span><br><span class="line"></span><br><span class="line">    # 发送测试报告邮件</span><br><span class="line">    print(&apos;开始发送测试报告...&apos;)</span><br><span class="line">    mailsend.send_mail()</span><br><span class="line">    print(&apos;测试报告发送成功&apos;)</span><br></pre></td></tr></table></figure></p><p>单独的邮件发送模块可参照之前一篇：<a href="http://tokyle.com/2018/01/23/python%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E9%82%AE%E4%BB%B6%E5%AE%9E%E6%97%B6%E5%8F%91%E9%80%81/">python实现自动化测试报告邮件实时发送</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用数据分离自动化测试，测试执行完成自动邮件发送&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="数据分离" scheme="http://tokyle.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>【转】python元类介绍</title>
    <link href="http://tokyle.com/2018/01/31/%E3%80%90%E8%BD%AC%E3%80%91python%E5%85%83%E7%B1%BB%E4%BB%8B%E7%BB%8D/"/>
    <id>http://tokyle.com/2018/01/31/【转】python元类介绍/</id>
    <published>2018-01-31T07:26:59.000Z</published>
    <updated>2018-01-31T07:31:07.839Z</updated>
    
    <content type="html"><![CDATA[<p>python元类</p><p>转自<code>stackoverflow</code> 神级人物<strong>e-satis</strong>的神级回复，以及国内翻译组汉化结果：</p><a id="more"></a><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>经常在<code>stackoverflow</code>上看见一些神一般的回答，也看到过很多次创建<code>Foo</code>类，特意上<a href="https://zh.wikipedia.org/wiki/Foobar" target="_blank" rel="noopener">维基百科</a>搜了，解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foobar是计算机程序领域里的术语炒作，并无实际用途和参考意义。 在计算机程序设计与计算机技术的相关文档中，术语foobar是一个常见的无名氏化名，常被作为“伪变量”使用。单词“foobar”或分离的“foo”与“bar”常出现于程序设计的案例中，如同Hello World程序一样，它们常被用于向学习者介绍某种程序语言。</span><br><span class="line"></span><br><span class="line">“foo”常被作为函数／方法的名称，而“bar”则常被用作变量名。</span><br></pre></td></tr></table></figure></p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h3 id="类也是对象（Classes-as-objects）"><a href="#类也是对象（Classes-as-objects）" class="headerlink" title="类也是对象（Classes as objects）"></a>类也是对象（Classes as objects）</h3><p>在理解元类之前，需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ObjectCreator(object):</span><br><span class="line">    pass</span><br><span class="line">my_object = ObjectCreator()</span><br><span class="line">print(my_object)</span><br><span class="line"></span><br><span class="line">&lt;__main__.ObjectCreator object at 0x000001899B36E550&gt;</span><br></pre></td></tr></table></figure></p><p>但是python中的类远不止如此。类同样也是一种对象 <strong>这个对象（类）自身用创建对象（类实例）的能力，而这就是为什么它是一个类的原因</strong>。但是，它本质上仍然是一个对象，所以，你可以对它进行如下操作：<br>1、将它赋值给一个变量<br>2、拷贝它<br>3、为它增加属性<br>4、将它作为函数参数进行传递</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ObjectCreator(object):</span><br><span class="line">    pass</span><br><span class="line"># 打印一个类，因为它其实也是一个对象</span><br><span class="line">print(ObjectCreator)</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line"># 将类作为参数传给函数</span><br><span class="line">def echo(o):</span><br><span class="line">    print(o)</span><br><span class="line">echo(ObjectCreator)</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line"># 为类增加属性</span><br><span class="line">print(hasattr(ObjectCreator, &apos;new_attribute&apos;))</span><br><span class="line">ObjectCreator.new_attribute = &apos;foo&apos;</span><br><span class="line">print(hasattr(ObjectCreator, &apos;new_attribute&apos;))</span><br><span class="line">print(ObjectCreator.new_attribute)</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">foo</span><br><span class="line"># 将类赋值给一个变量</span><br><span class="line">ObjectCreatorMirror = ObjectCreator</span><br><span class="line">print(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator object at 0x000002C21DF1E550&gt;</span><br></pre></td></tr></table></figure></p><h3 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h3><p>因为类也是对象，你可以在运行时动态地创建它们，就想其他任何时候一样。首先，你可以在函数中创建类，使用class关键字即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def choose_class(name):</span><br><span class="line">    if name == &apos;foo&apos;:</span><br><span class="line">        class Foo(object):</span><br><span class="line">            pass</span><br><span class="line">        return Foo</span><br><span class="line">    else:</span><br><span class="line">        class Bar(object):</span><br><span class="line">            pass</span><br><span class="line">        return Bar</span><br><span class="line">MyClass = choose_class(&apos;foo&apos;)</span><br><span class="line">print(MyClass)</span><br><span class="line">print(MyClass())</span><br><span class="line">&lt;class &apos;__main__.choose_class.&lt;locals&gt;.Foo&apos;&gt;</span><br><span class="line">&lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x000002B57928B518&gt;</span><br></pre></td></tr></table></figure></p><p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是用过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象，但就和python中的大多数事情一样，python仍然提供给你手动处理的方法。內建函数type，可以让你知道一个对象的类型是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(type(1))</span><br><span class="line">print(type(&quot;1&quot;))</span><br><span class="line">print(type(ObjectCreator))</span><br><span class="line">print(type(ObjectCreator()))</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类（同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后的兼容性）</p><p>type可以像这样工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称知道）)</span><br></pre></td></tr></table></figure></p><p>比如如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyShinyClass(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p>可以手动像这样创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 返回一个对象</span><br><span class="line">MyShinyClass = type(&apos;MyShinyClASS&apos;, (), &#123;&#125;)</span><br><span class="line">print(MyShinyClass)</span><br><span class="line">print(MyShinyClass())</span><br><span class="line">&lt;class &apos;__main__.MyShinyClASS&apos;&gt;</span><br><span class="line">&lt;__main__.MyShinyClASS object at 0x00000214ED6FE5F8&gt;</span><br></pre></td></tr></table></figure></p><p>type接受一个字典来为类定义属性，因此<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    bar = True</span><br></pre></td></tr></table></figure></p><p>可以翻译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo = type(&apos;Foo&apos;, (), &#123;&apos;bar&apos;:True&#125;)</span><br></pre></td></tr></table></figure></p><p>并且可以将Foo当做一个普通的类一样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(Foo)</span><br><span class="line">print(Foo.bar)</span><br><span class="line">f = Foo()</span><br><span class="line">print(f)</span><br><span class="line">print(f.bar)</span><br><span class="line">&lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">True</span><br><span class="line">&lt;__main__.Foo object at 0x000002C77F0FD4E0&gt;</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>当然，你可以向这个类继承，所以，如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class FooChild(Foo):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p>就可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FooChild = type(&apos;FooChild&apos;, (Foo,), &#123;&#125;)</span><br><span class="line">print(FooChild)</span><br><span class="line">print(FooChild.bar)</span><br></pre></td></tr></table></figure></p><h3 id="到底什么是元类"><a href="#到底什么是元类" class="headerlink" title="到底什么是元类"></a>到底什么是元类</h3><p>元类就是用来创建类的“东西”，你创建类就是为了创建类的实例对象，但是我们知道python中的类也是对象，而元类就是用来创建这些类（对象）的，所以，元类就是类的类，可以这样理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass = MetaClass()</span><br><span class="line">MyObject = MyClass()</span><br></pre></td></tr></table></figure></p><p>你可以看到了type可以让你像这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = type(&apos;MyClass&apos;, (), &#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>这是因为函数type实际上是一个元类，type就是python背后用来创建所有类的元类，所以type为什么不写成Type也就知道了吧，或许就是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type即使创建类对象的类。你可以通过<strong>class</strong>属性来看到这一点。Python中的所有的东西，注意，所有的东西——都是对象。这包含整数、字符串、函数和类。它们都是对象，而且它们都是从一个类创建来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = 24</span><br><span class="line">print(age.__class__)</span><br><span class="line">name = &apos;bob&apos;</span><br><span class="line">print(name.__class__)</span><br><span class="line">def foo():</span><br><span class="line">    pass</span><br><span class="line">print(foo.__class__)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&lt;class &apos;function&apos;&gt;</span><br></pre></td></tr></table></figure><p>现在，对于任何一个<strong>class</strong>的<strong>class</strong>属性又是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(age.__class__.__class__)</span><br><span class="line">print(name.__class__.__class__)</span><br><span class="line">print(foo.__class__.__class__)</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br><span class="line">&lt;class &apos;type&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>因此，元类就是窗累类这种对象的东西，如果你喜欢的话，可以把元类称谓”类工厂”（不是工厂类）,<code>type</code>就是python內建的元类，当然了，你也可以创建自己的元类。</p><h3 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a><code>__metaclass__</code>属性</h3><p>你可以在写一个类的时候为其添加<strong>metaclass</strong>属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    __metaclass__ = somethind,.,</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>如果你这么做了，python就会用元类来创建类Foo。这里面有技巧，你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找<code>__metaclass__</code>属性，如果找到了，Python就会用它创建类Foo，如果没找到，就会用內建的type来创建这个类。</p><p>当你写下如下代码时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Foo(Bar):</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>Python做了如下的操作：</p><p>Foo中有<code>__metaclass__</code>这个属性吗？如果有，python会在内存中通过<code>__metaclass__</code>创建一个名字为Foo的类对象（注意是类对象）。如果python没有找到<code>__metaclass__</code>，它会继续在Bar（父类）中寻找<code>__metaclass__</code>属性，并尝试做和前面同样的操作。如果python在任何父类中都找不到<code>__metaclass__</code>，它就会在模块层面中去寻找<code>__metaclass__</code>，并尝试做同样的操作。如果还是找不到<code>__metaclass__</code>，python就会用内置的type来创建这个类对象。</p><p>现在的问题就是，你可以在<code>__metaclass__</code>中放置些什么代码呢？答案是：可以是可以创建一个类的东西。那什么可以用来创建一个类呢？<strong>type</strong>，或者任何使用到type或者子类化type的东西都可以。</p><h3 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h3><p>元类的主要目的就是为了<strong>当创建类时能够自动地改变类</strong>。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定你的模块里所有的类的属性都应该是大写形式，有好几种方法可以实现，单其中一种就是通过在模块级别设定<code>__metaclass__</code>，采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改写成大写形式就解决了。</p><p>幸运的是，<code>__metaclass__</code>实际上可以被任意调用，它并不需要是一个正式的类（我们都知道，名字里面带’class’的东西，并不一定是个class）</p><p>我们这里先以一个简单的函数作为例子开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 元类会自动将你通常传给&apos;type&apos;的参数作为自己的参数传入</span><br><span class="line">def upper_attr(future_class_name, future_class_parents, future_class_attr):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    返回一个类对象，将属性都转为大写形式</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 识别所有不以&apos;__&apos;开头的属性，将它转换为大写</span><br><span class="line">    uppercase_attr = &#123;&#125;</span><br><span class="line">    for name, val in future_class_attr.items():</span><br><span class="line">        if not name.startswith(&apos;__&apos;):</span><br><span class="line">            uppercase_attr[name.upper()] = val</span><br><span class="line">        else:</span><br><span class="line">            uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">    # type创建这个类</span><br><span class="line">    return type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line"># 这行会影响模块中的所有类</span><br><span class="line">__metaclass__ = upper_attr</span><br><span class="line"></span><br><span class="line">class Foo():</span><br><span class="line">    # 全局 __metaclass__不会和&apos;object&apos;一起生效，但是我们可以在这里定义__metaclass__来只对这个类生效</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br></pre></td></tr></table></figure></p><p>现在让我们再做一次，这一次用一个真正的class来当元类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 请记住，&apos;type&apos;实际上是一个类，就像&apos;str&apos;和&apos;int&apos;一样</span><br><span class="line"># 所以，你可以从type继承</span><br><span class="line">class UpperAttrMetaclass(type):</span><br><span class="line">    # __new__ 是在 __init__之前被调用的特殊方法</span><br><span class="line">    # __new__是用来创建对象并返回的方法</span><br><span class="line">    # __init__只是用来把传入的参数初始化给对象</span><br><span class="line">    # 你很少用到__new__，除非你希望能够控制对象的创建</span><br><span class="line">    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span><br><span class="line">    # 如果你希望的话，你也可以在__init__中做些事情</span><br><span class="line">    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span><br><span class="line">    def __new__(upperattr_metaclass, future_class_name,</span><br><span class="line">                future_class_parents, future_class_attr):</span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        for name, val in future_class_attr.items():</span><br><span class="line">            if not name.startswith(&apos;__&apos;):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            else:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        return type(future_class_name, future_class_parents, uppercase_at</span><br></pre></td></tr></table></figure></p><p>但是这不是OOP（Object-oriented programming，面向对象编程）。我们直接调用了type，而且我们没有改写父类的<strong>new</strong>方法。现在，我们这样去处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class UpperAttrMetaclass(type): </span><br><span class="line"></span><br><span class="line">    def __new__(upperattr_metaclass, future_class_name, </span><br><span class="line">                future_class_parents, future_class_attr):</span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        for name, val in future_class_attr.items():</span><br><span class="line">            if not name.startswith(&apos;__&apos;):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            else:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        # 复用type.__new__方法</span><br><span class="line">        # 这就是基本的OOP编程，没什么魔法</span><br><span class="line">        return type.__new__(upperattr_metaclass, future_class_name, </span><br><span class="line">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure></p><p>你可以已经注意到了有个额外的参数uppersttr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就想在普通的类方法中的self参数一样。当然了，为了清晰起见，这边将名字起的比较长。但是就想self一样，所有的参数都有它们的传统名称。因此，在真是的产品代码中一个元类应该像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class UpperAttrMetaclass(type): </span><br><span class="line"></span><br><span class="line">    def __new__(cls, clsname, bases, dct):</span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        for name, val in dct.items():</span><br><span class="line">            if not name.startswith(&apos;__&apos;):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            else:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        return type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure></p><p>如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class UpperAttrMetaclass(type): </span><br><span class="line"></span><br><span class="line">    def __new__(cls, clsname, bases, dct):</span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        for name, val in dct.items():</span><br><span class="line">            if not name.startswith(&apos;__&apos;):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            else:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure></p><p>就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒不是因为元类本身，二十因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑魔法”是特别有用的，因而会搞出些复杂的东西来。但是元类本身而言，它们其实是很简单的：</p><p>1，拦截类的创建<br>2，修改类<br>3，返回修改之后的类</p><h3 id="为什么要用metaclass类而不是函数"><a href="#为什么要用metaclass类而不是函数" class="headerlink" title="为什么要用metaclass类而不是函数"></a>为什么要用metaclass类而不是函数</h3><p>由于<code>__metaclass__</code>可以接受任何可调用的对象，那为什么还要使用类呢，因为很显然使用类会更加复杂，这里有好几个原因：</p><p>1，意图会更加清晰，当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么<br>2，你可以使用OOP编程。元类可以从元类中继承，改写父类方法，甚至可以使用元类<br>3，你可以把代码组织的更好，当你使用元类的时候肯定不会像上述的简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。<br>4，你可以使用<code>__new__</code>，<code>__init__</code>以及<code>__call__</code>这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在<code>__new__</code>里处理掉，有些人还是觉得用<code>__init__</code>更舒服点。</p><h3 id="究竟为什么要使用元类"><a href="#究竟为什么要使用元类" class="headerlink" title="究竟为什么要使用元类"></a>究竟为什么要使用元类</h3><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，根本用不上它：</p><p>“元类就是深度的魔法，99%的用户根本不必为此操心。如果你想搞清楚究竟是否需要用来元类，那么你就不需要它。那么实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类”  ——Python界的领袖Tim Peters</p><p>元类的主要用途是创建API，一个典型的例子是Django ORM。它允许你像这样定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(models.Model):</span><br><span class="line">  name = models.CharField(max_length=30)</span><br><span class="line">  age = models.IntegerField()</span><br></pre></td></tr></table></figure></p><p>但是如果你像这样做的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy  = Person(name=&apos;bob&apos;, age=&apos;35&apos;)</span><br><span class="line">print guy.age</span><br></pre></td></tr></table></figure></p><p>这并不会返回一个IntegerFied对象，而是会放回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了<code>__metaclass__</code>，并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>首先，你知道了类其实是能够创建出类实例的对象。事实上，类本身也是实例，当然，它们是元类的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line">print(id(Foo))</span><br><span class="line">1973075749880</span><br></pre></td></tr></table></figure></p><p>Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Monkey patching</span><br><span class="line">class decorators</span><br></pre></td></tr></table></figure></p><p>当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然，其实在99%的时间里你根本就不需要动态修改类。</p><h3 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a>原链接</h3><blockquote><p><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">stackoverflow原链接</a><br><a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener">国内翻译站</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python元类&lt;/p&gt;
&lt;p&gt;转自&lt;code&gt;stackoverflow&lt;/code&gt; 神级人物&lt;strong&gt;e-satis&lt;/strong&gt;的神级回复，以及国内翻译组汉化结果：&lt;/p&gt;
    
    </summary>
    
      <category term="python黑科技" scheme="http://tokyle.com/categories/python%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>VPS重建记</title>
    <link href="http://tokyle.com/2018/01/24/VPS%E9%87%8D%E5%BB%BA%E8%AE%B0/"/>
    <id>http://tokyle.com/2018/01/24/VPS重建记/</id>
    <published>2018-01-24T07:07:13.000Z</published>
    <updated>2018-01-24T07:08:47.139Z</updated>
    
    <content type="html"><![CDATA[<p>VPS重新部署日常环境，及hexo博客快速重建</p><a id="more"></a><h3 id="VPS受灾记"><a href="#VPS受灾记" class="headerlink" title="VPS受灾记"></a>VPS受灾记</h3><p>大早上来发现<code>stackoverflow</code>首页都打不开，对于天天科学上网的我来说，简直莫名其妙。</p><h4 id="本地网络原因"><a href="#本地网络原因" class="headerlink" title="本地网络原因"></a>本地网络原因</h4><p>本地windows PC机，控制台ping IP：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping VPS_IP</span><br></pre></td></tr></table></figure></p><p>直接就超时了，匪夷所思。。VPS服务器 ping自己：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>好歹能通，那就是中间路由断了。</p><p>手机下载个网络工具，尝试在手机端ping VPS的IP（排除公司DNS搞的鬼），手机上ping也直接超时了，好吧，可以去检查是不是在某个不知名的时候自己把防火墙开了，还把22等端口关了。。</p><h4 id="VPS排查"><a href="#VPS排查" class="headerlink" title="VPS排查"></a>VPS排查</h4><p>我的VPS是在LA的<code>CENTOS7</code>主机，centos7查看防火墙状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd    --state</span><br></pre></td></tr></table></figure></p><p>发现是关着的。。。为了排除自己之前装过<code>iptables</code>的服务，查看<code>iptables.service</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status iptables.service</span><br></pre></td></tr></table></figure></p><p>这个果然是开着的，查看启用的端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure></p><p>该开的端口也都开了，好吧，无语了。</p><h4 id="大环境排查"><a href="#大环境排查" class="headerlink" title="大环境排查"></a>大环境排查</h4><p>基于大家都懂的网络环境，怀疑是IP被墙了，检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ping.chinaz.com</span><br></pre></td></tr></table></figure></p><p>果然，除了香港和国外，其他都ping不通VPS，好吧，可以下结论了:IP被墙了…</p><p>真的很想骂人啊！到底是哪个JR没事瞎玩，搞出个异常流量，害的无辜躺枪！！！<br>hexo还在VPS上，小飞机也在VPS上，没有梯子，科学上网个鬼啊！！！</p><p>骂人几轮，该弄得还是得弄，方案嘛，无非就是换IP，还好<code>Vultr</code>重建台服务还是很方便的。</p><h3 id="VPS重建"><a href="#VPS重建" class="headerlink" title="VPS重建"></a>VPS重建</h3><p><code>Vultr</code>重买服务器，这次比较幸运，居然有$2.5的，直接买：<br><a href="https://www.vultr.com/" target="_blank" rel="noopener">Vultr官网</a><br>拿到IP之后，第一件事，肯定是ping IP，还好，可以ping通，就是你了！</p><p>VPS简单设置</p><h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><p><code>xshell</code>远程连接上VPS之后，习惯性操作，第一步，更新<code>yum</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure></p><h5 id="firewall设置"><a href="#firewall设置" class="headerlink" title="firewall设置"></a>firewall设置</h5><p>由于centos7默认的防火墙服务时<code>firewalld</code>的，很不习惯，改！</p><p>查看防火墙状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd    --state</span><br></pre></td></tr></table></figure></p><p>关闭防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl  stop   firewalld.service</span><br></pre></td></tr></table></figure></p><p>禁止开机启动启动防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl   disable   firewalld.service</span><br></pre></td></tr></table></figure></p><h5 id="iptables设置"><a href="#iptables设置" class="headerlink" title="iptables设置"></a>iptables设置</h5><p>安装iptables服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install  iptables-services</span><br></pre></td></tr></table></figure></p><p>开启iptables防火墙:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start  iptables.service</span><br></pre></td></tr></table></figure></p><p>开启特定端口：<br>编辑文件：/etc/sysconfig/iptables，加入想要开放的端口即可，例如开放8090端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A INPUT -p tcp -m tcp --dport 8090 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>保存，退出之后，重启防火墙完成设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl  restart  iptables.service</span><br></pre></td></tr></table></figure></p><h4 id="ShadowsocksR（小飞机）配置"><a href="#ShadowsocksR（小飞机）配置" class="headerlink" title="ShadowsocksR（小飞机）配置"></a>ShadowsocksR（小飞机）配置</h4><p>科学上网必不可少的工具，<code>ShadowsocksR</code></p><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure></p><p>完成配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务器端口：自己设定（如不设定，默认为 8989）</span><br><span class="line">密码：自己设定（如不设定，默认为 teddysun.com）</span><br><span class="line">加密方式：自己设定（如不设定，默认为 aes-256-cfb）</span><br><span class="line">协议（Protocol）：自己设定（如不设定，默认为 origin）</span><br><span class="line">混淆（obfs）：自己设定（如不设定，默认为 plain）</span><br></pre></td></tr></table></figure></p><p>附上我的配置，仅供参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Your Server IP        :  ***.***.***.*** </span><br><span class="line">Your Server Port      :  ***** </span><br><span class="line">Your Password         :  ******* </span><br><span class="line">Your Protocol         :  auth_sha1_v4 </span><br><span class="line">Your obfs             :  tls1.2_ticket_auth </span><br><span class="line">Your Encryption Method:  aes-256-cfb</span><br></pre></td></tr></table></figure></p><p>配置完成之后就可以在本地PC机使用客户端进行梯子配置，完了就可以科学上网啦！！！<br><a href="https://pan.baidu.com/s/1dMkFYe" target="_blank" rel="noopener">客户端度娘盘链接</a></p><h3 id="Hexo重建"><a href="#Hexo重建" class="headerlink" title="Hexo重建"></a>Hexo重建</h3><p>预备动作：<strong>原来VPS上面的hexo所在目录，直接打成压缩包scp出来</strong></p><h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>首先安装gcc用于编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ kernel-devel</span><br></pre></td></tr></table></figure></p><p>开始安装node.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gz</span><br><span class="line">tar -xf node-v4.5.0.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压缩之后，进入目录，编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd node-v4.5.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>完成！<br>验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm</span><br></pre></td></tr></table></figure></p><p>安装完成的是4.5的版本，升级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br><span class="line">n stable</span><br></pre></td></tr></table></figure></p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>由于买的VPS已经集成了git，所以怎么安装，怎么配置环境变量啥的就不废话了。<br>1、VPS设置git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure></p><p>邮箱和用户名都对应于github</p><p>2、生成ssh秘钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C example@163.com</span><br></pre></td></tr></table></figure></p><p>默认保存路径是/root/.ssh下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>获取秘钥，然后到<code>github</code>的web页面将秘钥配置进去，完成！</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>1、安装hexo<br>创建目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">#初始化</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>2、安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></p><p>3、修改Hexo配置文件，完成！</p><p>或者，直接把原来VPS上面hexo的压缩包解压，再配置安装hexo即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure></p><h4 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;安装测试&quot;</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>执行不报错，进入博客可以看见<code>安装测试</code>该文章，部署成功！</p><p>真的是坑啊，又重布环境，国内的网络环境啊，ε=(´ο｀*)))唉~</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://www.jianshu.com/p/0823e387c019" target="_blank" rel="noopener">centos搭建hexo博客</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VPS重新部署日常环境，及hexo博客快速重建&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="Hexo" scheme="http://tokyle.com/tags/Hexo/"/>
    
      <category term="Centos7" scheme="http://tokyle.com/tags/Centos7/"/>
    
  </entry>
  
  <entry>
    <title>python实现自动化测试报告邮件实时发送</title>
    <link href="http://tokyle.com/2018/01/23/python%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E9%82%AE%E4%BB%B6%E5%AE%9E%E6%97%B6%E5%8F%91%E9%80%81/"/>
    <id>http://tokyle.com/2018/01/23/python实现自动化测试报告邮件实时发送/</id>
    <published>2018-01-23T09:11:37.000Z</published>
    <updated>2018-01-23T09:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现自动化用例执行完成之后，自动发送带html附件的邮件到邮箱</p><a id="more"></a><p>实现思路：<br>读取html附件内容，添加到邮件正文中，添加html附件，实现用例执行完成，测试报告自动发送到邮箱。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import os</span><br><span class="line">import smtplib</span><br><span class="line">from datetime import datetime as dt</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">from nose.tools import assert_equal</span><br><span class="line"></span><br><span class="line">def send_mail():</span><br><span class="line">    &quot;&quot;&quot;读取测试报告&quot;&quot;&quot;</span><br><span class="line">    with open(report_file, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f_obj:</span><br><span class="line">        content = f_obj.read()</span><br><span class="line"></span><br><span class="line">    msg = MIMEMultipart(&apos;mixed&apos;)</span><br><span class="line">    # 添加邮件内容</span><br><span class="line">    msg_html = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;)</span><br><span class="line">    msg.attach(msg_html)</span><br><span class="line"></span><br><span class="line">    #添加附件</span><br><span class="line">    msg_attachment = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;)</span><br><span class="line">    msg_attachment[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;&#123;0&#125;&quot;&apos;.format(report_file)</span><br><span class="line">    msg.attach(msg_attachment)</span><br><span class="line"></span><br><span class="line">    msg[&apos;Subject&apos;] = mail_subject</span><br><span class="line">    msg[&apos;Form&apos;] = mail_user</span><br><span class="line">    msg[&apos;To&apos;] = mail_to</span><br><span class="line">    try:</span><br><span class="line">        # 连接邮件服务器</span><br><span class="line">        s = smtplib.SMTP()</span><br><span class="line">        s.connect(mail_host)</span><br><span class="line">        # 登录</span><br><span class="line">        s.login(mail_user, mail_pwd)</span><br><span class="line">        # 发送邮件</span><br><span class="line">        s.sendmail(mail_user, mail_to, msg.as_string())</span><br><span class="line">        # 退出</span><br><span class="line">        s.quit()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;Exception&quot;, e)</span><br><span class="line"></span><br><span class="line">class Mailsend():</span><br><span class="line"></span><br><span class="line">    def test_mul(self):</span><br><span class="line">        a = 1</span><br><span class="line">        b = 2</span><br><span class="line">        res = 3</span><br><span class="line">        assert_equal(res, a+b)</span><br><span class="line"></span><br><span class="line">if  __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 邮件服务器</span><br><span class="line">    mail_host = &apos;smtp.163.com&apos;</span><br><span class="line">    # 发件人地址</span><br><span class="line">    mail_user = &apos;***&apos;</span><br><span class="line">    # 发件人密码</span><br><span class="line">    mail_pwd = &apos;***&apos;</span><br><span class="line">    # 邮件标题</span><br><span class="line">    mail_subject = u&apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;))</span><br><span class="line">    # 收件人地址</span><br><span class="line">    mail_to = &apos;***&apos;</span><br><span class="line">    # 测试报告名称</span><br><span class="line">    report_file = &apos;NoseTestReport.html&apos;</span><br><span class="line"></span><br><span class="line">    # 运行nosetests进行自动化测试并生成测试报告</span><br><span class="line">    print(&apos;Run NoseTests Now...&apos;)</span><br><span class="line">    os.system(&apos;nosetests -v mail_html.py:Mailsend --with-html --html-file=NoseTestReport.html&apos;)</span><br><span class="line"></span><br><span class="line">    # 发送测试报告邮件</span><br><span class="line">    print(&apos;Send Test Report Mail Now...&apos;)</span><br><span class="line">    send_mail()</span><br></pre></td></tr></table></figure><p>tips:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python客户端进行163,126邮箱邮件发送前，需要在web版邮箱中设置允许客户端访问，设置客户端授权码</span><br><span class="line"></span><br><span class="line">设置完授权码之后，此时的客户端登录密码为授权码，不是原来的邮箱密码</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现自动化用例执行完成之后，自动发送带html附件的邮件到邮箱&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="smtplib" scheme="http://tokyle.com/tags/smtplib/"/>
    
  </entry>
  
  <entry>
    <title>python数据分离</title>
    <link href="http://tokyle.com/2018/01/20/python%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB/"/>
    <id>http://tokyle.com/2018/01/20/python数据分离/</id>
    <published>2018-01-20T08:10:58.000Z</published>
    <updated>2018-01-20T09:04:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>python数据分离——读取配置文件</p><a id="more"></a><p>版本：<br><code>python 3.6</code></p><p>进行数据/配置和代码分离时，python3.6 可以使用<code>configparser</code>进行配置信息读取或创建。可以实现程序和数据的分离，便于后期维护程序，也能在一定程序上满足不会编码的人进行自动化测试（只需改配置文件。）</p><p>以创建/读取<code>ini</code>格式配置文件为例：</p><h3 id="创建配置文件："><a href="#创建配置文件：" class="headerlink" title="创建配置文件："></a>创建配置文件：</h3><p>每个ini文件都是有n个<code>sections</code>组成（可以理解为组成部分或者是段落。。我是这么理解的），每个<code>sections</code>包含若干个键值对（keys:values），所以某种程度上，你可以把每个section看成是个字典（dictionary），虽然这俩意义上完全无关。<br>python3.6创建ini配置文件代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import configparser</span><br><span class="line"></span><br><span class="line">cf = configparser.ConfigParser()</span><br><span class="line">cf[&apos;DEFAULT&apos;] = &#123;&quot;browser&quot; : &quot;Chrome&quot;,</span><br><span class="line">                 &quot;version&quot; : &quot;63.0.3239.132&quot;,</span><br><span class="line">                 &quot;driver&quot; : &quot;chromedriver.exe&quot;,</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">cf[&apos;tokyle.com&apos;] = &#123;&#125;</span><br><span class="line">cf[&apos;tokyle.com&apos;][&apos;Author&apos;] = &apos;kyle&apos;</span><br><span class="line"></span><br><span class="line">cf[&apos;baidu.com&apos;] = &#123;&#125;</span><br><span class="line">baiduSearch = cf[&apos;baidu.com&apos;]</span><br><span class="line">baiduSearch[&apos;searchBox&apos;] = &apos;id &gt; kw&apos;</span><br><span class="line">baiduSearch[&apos;searchButton&apos;] = &apos;id &gt; su&apos;</span><br><span class="line"></span><br><span class="line">cf[&apos;DEFAULT&apos;][&apos;noRetry&apos;] = &apos;yes&apos;</span><br><span class="line"></span><br><span class="line">with open(&apos;test.ini&apos;, &apos;w&apos;) as configfile:</span><br><span class="line">    cf.write(configfile)</span><br></pre></td></tr></table></figure></p><p>上述代码执行完成之后会在该.py文件所在目录下创建一个<code>test.ini</code>的配置文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">browser = Chrome</span><br><span class="line">version = 63.0.3239.132</span><br><span class="line">driver = chromedriver.exe</span><br><span class="line">noretry = yes</span><br><span class="line"></span><br><span class="line">[tokyle.com]</span><br><span class="line">author = kyle</span><br><span class="line"></span><br><span class="line">[baidu.com]</span><br><span class="line">searchbox = id &gt; kw</span><br><span class="line">searchbutton = id &gt; su</span><br></pre></td></tr></table></figure></p><p>每个ini文件可以包含一个<code>[&#39;DEFAULT&#39;]</code> section，也可以没有，<code>[&#39;DEFAULT&#39;]</code>部分定义了默认设置，例如默认使用的浏览器，浏览器版本等。</p><h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import configparser</span><br><span class="line"></span><br><span class="line">cf = configparser.ConfigParser()</span><br><span class="line">cf.read(&apos;test.ini&apos;)</span><br></pre></td></tr></table></figure><p>获取所有<code>sections</code>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cf.sections()</span><br></pre></td></tr></table></figure></p><p>即可，需要注意的是，这样，是默认不会获取都[‘DEFAULT’]的，可以实验一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">section = cf.sections()</span><br><span class="line">print(section)</span><br></pre></td></tr></table></figure></p><p>打印出的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;tokyle.com&apos;, &apos;baidu.com&apos;]</span><br></pre></td></tr></table></figure></p><p>可以看见默认不包含[‘DEFAULT’]。</p><p>其实读取配置信息就和读取字典里的数据做法一样，使用for循环就可以打印出全部信息，例如进行自动化测试时想获取[‘baidu.com’]里存的<code>百度搜索输入框</code>以及<code>百度一下按键</code>，可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baidu_msg = cf[&apos;baidu.com&apos;]</span><br><span class="line">for key,value in baidu_msg.items():</span><br><span class="line">    print(key + &apos; : &apos; + value)</span><br></pre></td></tr></table></figure></p><p>打印出的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">searchbox : id &gt; kw</span><br><span class="line">searchbutton : id &gt; su</span><br><span class="line">browser : Chrome</span><br><span class="line">version : 63.0.3239.132</span><br><span class="line">driver : chromedriver.exe</span><br><span class="line">noretry : yes</span><br></pre></td></tr></table></figure></p><p>可以看见，这样不仅会把[‘baidu.com’]模块的信息全部打印，[‘DEFAULT’]模块的信息也会被打印出来。</p><h3 id="使用配置文件实例-简单的数据分离-："><a href="#使用配置文件实例-简单的数据分离-：" class="headerlink" title="使用配置文件实例(简单的数据分离)："></a>使用配置文件实例(简单的数据分离)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import configparser</span><br><span class="line">import traceback,time</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from nose.tools import assert_true</span><br><span class="line"></span><br><span class="line">class ElementId():</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        #读取配置文件</span><br><span class="line">        self.cf = configparser.ConfigParser()</span><br><span class="line">        self.cf.read(&apos;test.ini&apos;)</span><br><span class="line">        self.cf.sections()</span><br><span class="line"></span><br><span class="line">    def get_elementId(self, driver, webSiteName, webelement):</span><br><span class="line">        try:</span><br><span class="line">            #获取配置文件中的定位方法以及定位元素</span><br><span class="line">            webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;)</span><br><span class="line">            webelement_method = webElemnt[0].strip()</span><br><span class="line">            webelement_expression = webElemnt[1].strip()</span><br><span class="line">            element = WebDriverWait(driver, 10).until\</span><br><span class="line">                (lambda x: x.find_element(webelement_method, webelement_expression))</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(traceback.print_exc(), e)</span><br><span class="line">        else:</span><br><span class="line">            return element</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    &quot;&quot;&quot;测试百度搜索&quot;&quot;&quot;</span><br><span class="line">    #打开百度首页</span><br><span class="line">    browser = webdriver.Chrome()</span><br><span class="line">    browser.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">    #获取定位元素</span><br><span class="line">    elementid = ElementId()</span><br><span class="line">    searchBox = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbox&apos;)</span><br><span class="line">    searchBox.send_keys(&apos;selenium&apos;)</span><br><span class="line">    searchButton = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbutton&apos;)</span><br><span class="line">    searchButton.click()</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    #断言完成百度搜索&quot;selenium&quot;</span><br><span class="line">    assert_true(u&quot;Selenium - Web Browser Automation&quot; in browser.page_source)</span><br><span class="line">    browser.quit()</span><br></pre></td></tr></table></figure><p>（我在执行上述示例之前，把<code>test.ini</code>中的[‘DEFAULT’]注释掉了，此例不需要[‘DEFAULT’]中的信息）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python数据分离——读取配置文件&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://tokyle.com/categories/python/"/>
    
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>自娱自乐一</title>
    <link href="http://tokyle.com/2018/01/20/%E8%87%AA%E5%A8%B1%E8%87%AA%E4%B9%90%E4%B8%80/"/>
    <id>http://tokyle.com/2018/01/20/自娱自乐一/</id>
    <published>2018-01-20T01:37:02.000Z</published>
    <updated>2018-01-20T03:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>自娱自乐系列一：</p><p>为了过年提前回家，周六过来加班调休，又不大想干活，就想着捣鼓点自娱自乐的东西：</p><a id="more"></a><h3 id="输入年龄判断是否有投票资格："><a href="#输入年龄判断是否有投票资格：" class="headerlink" title="输入年龄判断是否有投票资格："></a>输入年龄判断是否有投票资格：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def judge_age():</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            age = int(input(&quot;\nPlease enter your age：&quot;))</span><br><span class="line">        except ValueError:</span><br><span class="line">            print(&quot;Sorry,I can&apos;t understand what you entered.Please enter a correct number.&quot;)</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    if age &gt;= 18:</span><br><span class="line">        print(&quot;You are able to vote in the United States!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;You are too young to vote in the United States!&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    judge_age()</span><br></pre></td></tr></table></figure><h3 id="判断输入的正整数"><a href="#判断输入的正整数" class="headerlink" title="判断输入的正整数:"></a>判断输入的正整数:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">def get_non_negative_int(prompt):</span><br><span class="line">    try:</span><br><span class="line">        value = int(input(prompt))</span><br><span class="line">    except ValueError:</span><br><span class="line">        print(&quot;Sorry,I can&apos;t understand that.&quot;)</span><br><span class="line">        return get_non_negative_int(prompt)</span><br><span class="line"></span><br><span class="line">    if value &lt; 0:</span><br><span class="line">        print(&quot;Sorry,your response must not be negative.&quot;)</span><br><span class="line">        return get_non_negative_int(prompt)</span><br><span class="line">    else:</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">def guess_number():</span><br><span class="line">    number = get_non_negative_int(&quot;Please enter a number to guess: (only positive integer can work,thanks!)&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        guess = get_non_negative_int(&quot;guess the number.&quot;)</span><br><span class="line">        if guess &gt; number:</span><br><span class="line">            print(&quot;You could enter a lower one.&quot;)</span><br><span class="line">        elif guess &lt; number:</span><br><span class="line">            print(&quot;I think it could be higher.&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;Congratulations! You got it!&quot;)</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    guess_number()</span><br></pre></td></tr></table></figure><p>纯属自娱自乐，毫无技术含量 Thanks?(?ω?)?</p><h4 id="顺便贴个常识坑："><a href="#顺便贴个常识坑：" class="headerlink" title="顺便贴个常识坑："></a>顺便贴个常识坑：</h4><p>文件夹不能取名是<strong><em>code</em></strong>，否则pycharm的debug模式会报错！！！（stackoverflow真是个好网站！什么坑都能找到填的办法。。）<br>原因：<br>debug模式会引个包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from code import InteractiveConsole</span><br></pre></td></tr></table></figure></p><p>工程中有code文件夹，会找不到debug需要的方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自娱自乐系列一：&lt;/p&gt;
&lt;p&gt;为了过年提前回家，周六过来加班调休，又不大想干活，就想着捣鼓点自娱自乐的东西：&lt;/p&gt;
    
    </summary>
    
      <category term="just for fun" scheme="http://tokyle.com/categories/just-for-fun/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
      <category term="lives" scheme="http://tokyle.com/tags/lives/"/>
    
  </entry>
  
  <entry>
    <title>appium应用简介</title>
    <link href="http://tokyle.com/2018/01/19/appium%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://tokyle.com/2018/01/19/appium应用简介/</id>
    <published>2018-01-19T03:02:46.000Z</published>
    <updated>2018-01-19T03:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>appium应用篇，简单介绍自己工作中用到的一些appium应用。</p><a id="more"></a><h2 id="Appium等待类型"><a href="#Appium等待类型" class="headerlink" title="Appium等待类型"></a>Appium等待类型</h2><h3 id="固定时间等待"><a href="#固定时间等待" class="headerlink" title="固定时间等待"></a>固定时间等待</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br></pre></td></tr></table></figure><p>固定等待时间3秒，强制等待，必须等完3秒之后才会进行下一步操作。</p><h3 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.implicitly_wait(5)</span><br></pre></td></tr></table></figure><p>隐式等待的好处是不用想固定时间（time.sleep()）一样死等固定时间，可以在一定程度上提高执行效率，但是这种等待方式也是需要等页面所有元素都加载完成才会去进行下一步操作，例如有的时候，页面你需要的元素已经加载完成，但是必须还是要等待个别资源加载完才会执行下一步，一定程度上来说还是效率降低。</p><h3 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line"></span><br><span class="line">WebDriverWait(driver, 10).\</span><br><span class="line">        until(lambda x:x.find_element_by_id(&apos;com.anmav.cashierdesk:id/tvOpenTable&apos;))</span><br></pre></td></tr></table></figure><p>显示等待原理是每隔一段时间（默认0.5秒），执行一次判断条件，如果条件成立，就执行下一步，直到超过设定的最大等待时间，抛出TimeoutException异常</p><h2 id="Appium定位弹窗"><a href="#Appium定位弹窗" class="headerlink" title="Appium定位弹窗"></a>Appium定位弹窗</h2><h3 id="切换webview"><a href="#切换webview" class="headerlink" title="切换webview"></a>切换webview</h3><p>原理和<code>selenium</code>一样，类似于selenium中先获取页面句柄，再切换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver.contexts</span><br><span class="line"></span><br><span class="line">方法一：driver.switch_to.context(&quot;contextname&quot;)     #contextname为想切换到的上下文</span><br><span class="line">方法二：driver.switch_to.context(contexts[1])      # 从contexts里取第二个参数</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium应用篇，简单介绍自己工作中用到的一些appium应用。&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://tokyle.com/categories/appium/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="appium" scheme="http://tokyle.com/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>python项目依赖管理工具-pipenv</title>
    <link href="http://tokyle.com/2018/01/18/python%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pipenv/"/>
    <id>http://tokyle.com/2018/01/18/python项目依赖管理工具-pipenv/</id>
    <published>2018-01-18T02:06:43.000Z</published>
    <updated>2018-01-18T02:08:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然发现一个很好用的python项目包管理工具<strong>pipenv</strong><br><a id="more"></a></p><p>github上简介是一句话<code>Pipenv: Python Development Workflow for Humans</code></p><p>现在已经是<a href="https://packaging.python.org/tutorials/managing-dependencies/#managing-dependencies" target="_blank" rel="noopener">python.org</a>官方推荐的工具。</p><h2 id="具体功能："><a href="#具体功能：" class="headerlink" title="具体功能："></a>具体功能：</h2><p>pipenv能够自动创建和管理你工程的虚拟环境，当你安装/卸载包时，会自动从你的Pipfile中添加/移除包；为啥要用这个工具，python的特点，python进行工程环境创建，一般是创建一个<code>Virtualenv</code>虚拟环境，然后列出所需要的工具包，pip安装，但是这样你就要手动去添加你需要的包，删除你已经不需要的包，并且由于工具包的更新，你可能还需要手动去更新你的工具包，而且，类似于单元测试这样的场景，需要安装<code>nose</code>包，但是生产环境又不需要该包，也就无法做到生产环境和开发环境安装包的分离，而以上这些，pipenv都可以解决。</p><h2 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h2><h3 id="首先安装pipenv"><a href="#首先安装pipenv" class="headerlink" title="首先安装pipenv"></a>首先安装pipenv</h3><p>使用pip安装pipenv及其依赖项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure></p><p>macOS安装则使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pipenv</span><br></pre></td></tr></table></figure></p><p>进入你项目所在文件夹，启动Pipenv<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your_project</span><br><span class="line">pipenv install</span><br></pre></td></tr></table></figure></p><p>启动之后，项目文件夹下会多出两个文件<code>Pipfile</code>，<code>Pipfile.lock</code><br>Pipfile文件包含项目的依赖包信息。</p><h3 id="管理依赖包"><a href="#管理依赖包" class="headerlink" title="管理依赖包"></a>管理依赖包</h3><p>要为项目安装依赖包，跟pip类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install nose</span><br></pre></td></tr></table></figure></p><p>卸载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv uninstall nose</span><br></pre></td></tr></table></figure></p><p>可以通过更新<code>Pipfile.lock</code>来冻结软件包名称及其版本以及其自己的依赖关系的列表。 这是使用lock关键字完成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv lock</span><br></pre></td></tr></table></figure></p><p>如果你同事或者朋友想clone你的依赖库，直接拿你的<code>Pipfile</code>，然后他本地安装pipenv之后，<code>pipenv install</code>即可完成依赖库安装</p><h3 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h3><p>只为开发环境安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install --dev nose</span><br></pre></td></tr></table></figure></p><p>这样，在生产环境执行<code>pipenv install</code>是不会安装<code>nose</code>的，想要安装开发环境的依赖，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install --dev</span><br></pre></td></tr></table></figure></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><strong>pipenv</strong>所有关键字及解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">$ pipenv</span><br><span class="line">Usage: pipenv [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --update         Update Pipenv &amp; pip to latest.</span><br><span class="line">  --where          Output project home information.</span><br><span class="line">  --venv           Output virtualenv information.</span><br><span class="line">  --py             Output Python interpreter information.</span><br><span class="line">  --envs           Output Environment Variable options.</span><br><span class="line">  --rm             Remove the virtualenv.</span><br><span class="line">  --bare           Minimal output.</span><br><span class="line">  --completion     Output completion (to be eval&apos;d).</span><br><span class="line">  --man            Display manpage.</span><br><span class="line">  --three / --two  Use Python 3/2 when creating virtualenv.</span><br><span class="line">  --python TEXT    Specify which version of Python virtualenv should use.</span><br><span class="line">  --site-packages  Enable site-packages for the virtualenv.</span><br><span class="line">  --jumbotron      An easter egg, effectively.</span><br><span class="line">  --version        Show the version and exit.</span><br><span class="line">  -h, --help       Show this message and exit.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage Examples:</span><br><span class="line">   Create a new project using Python 3.6, specifically:</span><br><span class="line">   $ pipenv --python 3.6</span><br><span class="line"></span><br><span class="line">   Install all dependencies for a project (including dev):</span><br><span class="line">   $ pipenv install --dev</span><br><span class="line"></span><br><span class="line">   Create a lockfile containing pre-releases:</span><br><span class="line">   $ pipenv lock --pre</span><br><span class="line"></span><br><span class="line">   Show a graph of your installed dependencies:</span><br><span class="line">   $ pipenv graph</span><br><span class="line"></span><br><span class="line">   Check your installed dependencies for security vulnerabilities:</span><br><span class="line">   $ pipenv check</span><br><span class="line"></span><br><span class="line">   Install a local setup.py into your virtual environment/Pipfile:</span><br><span class="line">   $ pipenv install -e .</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  check      Checks for security vulnerabilities and...</span><br><span class="line">  graph      Displays currently–installed dependency graph...</span><br><span class="line">  install    Installs provided packages and adds them to...</span><br><span class="line">  lock       Generates Pipfile.lock.</span><br><span class="line">  open       View a given module in your editor.</span><br><span class="line">  run        Spawns a command installed into the...</span><br><span class="line">  shell      Spawns a shell within the virtualenv.</span><br><span class="line">  uninstall  Un-installs a provided package and removes it...</span><br><span class="line">  update     Uninstalls all packages, and re-installs...</span><br></pre></td></tr></table></figure></p><h3 id="定位工程"><a href="#定位工程" class="headerlink" title="定位工程"></a>定位工程</h3><p>展示工程路径以及环境路径，进入工程(类似于linux)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --where</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --venv</span><br></pre></td></tr></table></figure><p>定位python解释器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --py</span><br></pre></td></tr></table></figure></p><h3 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h3><h4 id="激活工程环境"><a href="#激活工程环境" class="headerlink" title="激活工程环境"></a>激活工程环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><h4 id="运行python脚本"><a href="#运行python脚本" class="headerlink" title="运行python脚本"></a>运行python脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv run python main.py</span><br></pre></td></tr></table></figure><h4 id="展示依赖关系图"><a href="#展示依赖关系图" class="headerlink" title="展示依赖关系图"></a>展示依赖关系图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv graph</span><br></pre></td></tr></table></figure><h4 id="卸载所有"><a href="#卸载所有" class="headerlink" title="卸载所有"></a>卸载所有</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv uninstall --all</span><br></pre></td></tr></table></figure><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><blockquote><p><a href="https://github.com/pypa/pipenv" target="_blank" rel="noopener">github项目地址</a><br><a href="https://packaging.python.org/tutorials/managing-dependencies/#managing-dependencies" target="_blank" rel="noopener">python.org官网推荐地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然发现一个很好用的python项目包管理工具&lt;strong&gt;pipenv&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://tokyle.com/categories/python/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
      <category term="pipenv" scheme="http://tokyle.com/tags/pipenv/"/>
    
  </entry>
  
  <entry>
    <title>cmder简介</title>
    <link href="http://tokyle.com/2018/01/18/cmder%E7%AE%80%E4%BB%8B/"/>
    <id>http://tokyle.com/2018/01/18/cmder简介/</id>
    <published>2018-01-18T01:46:51.000Z</published>
    <updated>2018-01-18T02:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>windows小工具介绍</p><p>windows系统cmd工具，说实话，用的还是有点不舒服的，用习惯<code>vim</code>之后，真的是很想在windows上用类似的，还好，找到个小工具<code>cmder</code>。</p><a id="more"></a><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><p>照旧，官方下载地址是托管在github上</p><blockquote><p><a href="https://github.com/cmderdev/cmder/releases/" target="_blank" rel="noopener">github下载地址</a></p></blockquote><p>但是不知道最近抽什么疯，github上n多项目下载页面直接404，索性提供本地度娘盘地址：</p><blockquote><p><a href="https://pan.baidu.com/s/1ghb9lvl" target="_blank" rel="noopener">度娘盘地址</a></p></blockquote><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>下载完成之后，解压缩，然后将<code>cmder.exe</code>所在目录添加到系统环境变量中，完成~双击打开即可使用。</p><h2 id="简单设置"><a href="#简单设置" class="headerlink" title="简单设置"></a>简单设置</h2><h3 id="解决中文乱码问题："><a href="#解决中文乱码问题：" class="headerlink" title="解决中文乱码问题："></a>解决中文乱码问题：</h3><p>类似于linux，alias文件中添加设置即可；alias文件位置：<code>cmder/config/aliases</code><br>添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l=ls --show-control-chars</span><br><span class="line">la=ls -aF --show-control-chars</span><br><span class="line">ll=ls -alF --show-control-chars</span><br></pre></td></tr></table></figure></p><h3 id="中文字重叠在一起"><a href="#中文字重叠在一起" class="headerlink" title="中文字重叠在一起"></a>中文字重叠在一起</h3><p>cmder进入设置（快捷键<code>win+alt+p</code>），找到<code>main</code>，取消<code>monospace(固定宽度)</code>勾选</p><p>基本就是设置完成了，可以进行使用了，后续再发现什么其他的好功能再更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#切换盘</span><br><span class="line">D:</span><br><span class="line">#展示文件</span><br><span class="line">ls</span><br><span class="line">ll</span><br><span class="line">#查看文件内容</span><br><span class="line">cat xxx.txt</span><br><span class="line">#编辑文件内容</span><br><span class="line">vim xxx.txt</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;windows小工具介绍&lt;/p&gt;
&lt;p&gt;windows系统cmd工具，说实话，用的还是有点不舒服的，用习惯&lt;code&gt;vim&lt;/code&gt;之后，真的是很想在windows上用类似的，还好，找到个小工具&lt;code&gt;cmder&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://tokyle.com/categories/skill/"/>
    
    
      <category term="cmder" scheme="http://tokyle.com/tags/cmder/"/>
    
  </entry>
  
  <entry>
    <title>appium键盘事件</title>
    <link href="http://tokyle.com/2018/01/17/appium%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/"/>
    <id>http://tokyle.com/2018/01/17/appium键盘事件/</id>
    <published>2018-01-17T09:26:13.000Z</published>
    <updated>2018-01-17T09:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>appium键盘事件</p><a id="more"></a><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.keyevent(keyCode)</span><br></pre></td></tr></table></figure></p><h2 id="电话键"><a href="#电话键" class="headerlink" title="电话键"></a>电话键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KEYCODE_CALL 拨号键 5</span><br><span class="line">KEYCODE_ENDCALL 挂机键 6</span><br><span class="line">KEYCODE_HOME 按键Home 3</span><br><span class="line">KEYCODE_MENU 菜单键 82</span><br><span class="line">KEYCODE_BACK 返回键 4</span><br><span class="line">KEYCODE_SEARCH 搜索键 84</span><br><span class="line">KEYCODE_CAMERA 拍照键 27</span><br><span class="line">KEYCODE_FOCUS 拍照对焦键 80</span><br><span class="line">KEYCODE_POWER 电源键 26</span><br><span class="line">KEYCODE_NOTIFICATION 通知键 83</span><br><span class="line">KEYCODE_MUTE 话筒静音键 91</span><br><span class="line">KEYCODE_VOLUME_MUTE 扬声器静音键 164</span><br><span class="line">KEYCODE_VOLUME_UP 音量增加键 24</span><br><span class="line">KEYCODE_VOLUME_DOWN 音量减小键 25</span><br></pre></td></tr></table></figure><h2 id="控制键"><a href="#控制键" class="headerlink" title="控制键"></a>控制键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">KEYCODE_ENTER 回车键 66</span><br><span class="line">KEYCODE_ESCAPE ESC键 111</span><br><span class="line">KEYCODE_DPAD_CENTER 导航键 确定键 23</span><br><span class="line">KEYCODE_DPAD_UP 导航键 向上 19</span><br><span class="line">KEYCODE_DPAD_DOWN 导航键 向下 20</span><br><span class="line">KEYCODE_DPAD_LEFT 导航键 向左 21</span><br><span class="line">KEYCODE_DPAD_RIGHT 导航键 向右 22</span><br><span class="line">KEYCODE_MOVE_HOME 光标移动到开始键 122</span><br><span class="line">KEYCODE_MOVE_END 光标移动到末尾键 123</span><br><span class="line">KEYCODE_PAGE_UP 向上翻页键 92</span><br><span class="line">KEYCODE_PAGE_DOWN 向下翻页键 93</span><br><span class="line">KEYCODE_DEL 退格键 67</span><br><span class="line">KEYCODE_FORWARD_DEL 删除键 112</span><br><span class="line">KEYCODE_INSERT 插入键 124</span><br><span class="line">KEYCODE_TAB Tab键 61</span><br><span class="line">KEYCODE_NUM_LOCK 小键盘锁 143</span><br><span class="line">KEYCODE_CAPS_LOCK 大写锁定键 115</span><br><span class="line">KEYCODE_BREAK Break/Pause键 121</span><br><span class="line">KEYCODE_SCROLL_LOCK 滚动锁定键 116</span><br><span class="line">KEYCODE_ZOOM_IN 放大键 168</span><br><span class="line">KEYCODE_ZOOM_OUT 缩小键 169</span><br></pre></td></tr></table></figure><h2 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KEYCODE_ALT_LEFT Alt+Left</span><br><span class="line">KEYCODE_ALT_RIGHT Alt+Right</span><br><span class="line">KEYCODE_CTRL_LEFT Control+Left</span><br><span class="line">KEYCODE_CTRL_RIGHT Control+Right</span><br><span class="line">KEYCODE_SHIFT_LEFT Shift+Left</span><br><span class="line">KEYCODE_SHIFT_RIGHT Shift+Right</span><br></pre></td></tr></table></figure><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">KEYCODE_0 按键&apos;0&apos; 7</span><br><span class="line">KEYCODE_1 按键&apos;1&apos; 8</span><br><span class="line">KEYCODE_2 按键&apos;2&apos; 9</span><br><span class="line">KEYCODE_3 按键&apos;3&apos; 10</span><br><span class="line">KEYCODE_4 按键&apos;4&apos; 11</span><br><span class="line">KEYCODE_5 按键&apos;5&apos; 12</span><br><span class="line">KEYCODE_6 按键&apos;6&apos; 13</span><br><span class="line">KEYCODE_7 按键&apos;7&apos; 14</span><br><span class="line">KEYCODE_8 按键&apos;8&apos; 15</span><br><span class="line">KEYCODE_9 按键&apos;9&apos; 16</span><br><span class="line">KEYCODE_A 按键&apos;A&apos; 29</span><br><span class="line">KEYCODE_B 按键&apos;B&apos; 30</span><br><span class="line">KEYCODE_C 按键&apos;C&apos; 31</span><br><span class="line">KEYCODE_D 按键&apos;D&apos; 32</span><br><span class="line">KEYCODE_E 按键&apos;E&apos; 33</span><br><span class="line">KEYCODE_F 按键&apos;F&apos; 34</span><br><span class="line">KEYCODE_G 按键&apos;G&apos; 35</span><br><span class="line">KEYCODE_H 按键&apos;H&apos; 36</span><br><span class="line">KEYCODE_I 按键&apos;I&apos; 37</span><br><span class="line">KEYCODE_J 按键&apos;J&apos; 38</span><br><span class="line">KEYCODE_K 按键&apos;K&apos; 39</span><br><span class="line">KEYCODE_L 按键&apos;L&apos; 40</span><br><span class="line">KEYCODE_M 按键&apos;M&apos; 41</span><br><span class="line">KEYCODE_N 按键&apos;N&apos; 42</span><br><span class="line">KEYCODE_O 按键&apos;O&apos; 43</span><br><span class="line">KEYCODE_P 按键&apos;P&apos; 44</span><br><span class="line">KEYCODE_Q 按键&apos;Q&apos; 45</span><br><span class="line">KEYCODE_R 按键&apos;R&apos; 46</span><br><span class="line">KEYCODE_S 按键&apos;S&apos; 47</span><br><span class="line">KEYCODE_T 按键&apos;T&apos; 48</span><br><span class="line">KEYCODE_U 按键&apos;U&apos; 49</span><br><span class="line">KEYCODE_V 按键&apos;V&apos; 50</span><br><span class="line">KEYCODE_W 按键&apos;W&apos; 51</span><br><span class="line">KEYCODE_X 按键&apos;X&apos; 52</span><br><span class="line">KEYCODE_Y 按键&apos;Y&apos; 53</span><br><span class="line">KEYCODE_Z 按键&apos;Z&apos; 54</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium键盘事件&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://tokyle.com/categories/appium/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="android" scheme="http://tokyle.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>appium定位</title>
    <link href="http://tokyle.com/2018/01/17/appium%E5%AE%9A%E4%BD%8D/"/>
    <id>http://tokyle.com/2018/01/17/appium定位/</id>
    <published>2018-01-17T09:18:04.000Z</published>
    <updated>2018-01-19T08:23:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>appium的常用操作以及元素定位的简单介绍</p><a id="more"></a><h2 id="appium常用操作"><a href="#appium常用操作" class="headerlink" title="appium常用操作"></a>appium常用操作</h2><h3 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.lock(5)</span><br></pre></td></tr></table></figure><h3 id="切换应用至后台"><a href="#切换应用至后台" class="headerlink" title="切换应用至后台"></a>切换应用至后台</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.background_app(5)  # 置于后台，持续5秒</span><br><span class="line">driver.background_app(-1) # 持续置于后台</span><br><span class="line">driver.background_app(&#123;&apos;timeout&apos;: None&#125;) # 持续置于后台</span><br></pre></td></tr></table></figure><h3 id="收起键盘"><a href="#收起键盘" class="headerlink" title="收起键盘"></a>收起键盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.hide_keyboard()</span><br></pre></td></tr></table></figure><h3 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.start_activity(&apos;com.example.android.apis&apos;, &apos;.Foo&apos;)</span><br></pre></td></tr></table></figure><h3 id="检测应用是否被安装"><a href="#检测应用是否被安装" class="headerlink" title="检测应用是否被安装"></a>检测应用是否被安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.is_app_installed(&apos;com.example.android.apis&apos;)</span><br></pre></td></tr></table></figure><h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.install_app(&apos;path/to/my.apk&apos;)</span><br></pre></td></tr></table></figure><h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.remove_app(&apos;com.example.android.apis&apos;)</span><br></pre></td></tr></table></figure><h3 id="模拟设备摇一摇"><a href="#模拟设备摇一摇" class="headerlink" title="模拟设备摇一摇"></a>模拟设备摇一摇</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.shake()</span><br></pre></td></tr></table></figure><h3 id="关闭应用"><a href="#关闭应用" class="headerlink" title="关闭应用"></a>关闭应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.close_app()</span><br></pre></td></tr></table></figure><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p>使用前提是<code>desired capabilities</code>设置了 <code>autoLaunch=false</code> 关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.launch_app()</span><br></pre></td></tr></table></figure></p><h3 id="操作上下文（Contexts）"><a href="#操作上下文（Contexts）" class="headerlink" title="操作上下文（Contexts）"></a>操作上下文（Contexts）</h3><h4 id="获取所有"><a href="#获取所有" class="headerlink" title="获取所有"></a>获取所有</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.contexts</span><br></pre></td></tr></table></figure><h4 id="获取当前"><a href="#获取当前" class="headerlink" title="获取当前"></a>获取当前</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.current_context</span><br></pre></td></tr></table></figure><h4 id="切换至默认"><a href="#切换至默认" class="headerlink" title="切换至默认"></a>切换至默认</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.context(None)</span><br></pre></td></tr></table></figure><h3 id="按键事件"><a href="#按键事件" class="headerlink" title="按键事件"></a>按键事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.keyevent(176)</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://tokyle.com/2018/01/17/appium%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/">具体键值</a></p></blockquote><h3 id="点击操作-多点触控操作"><a href="#点击操作-多点触控操作" class="headerlink" title="点击操作/多点触控操作"></a>点击操作/多点触控操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action = TouchAction(driver)</span><br><span class="line">action.press(element=el, x=10, y=10).release().perform()</span><br></pre></td></tr></table></figure><h3 id="滑动屏幕"><a href="#滑动屏幕" class="headerlink" title="滑动屏幕"></a>滑动屏幕</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.swipe(start_x=75, start_y=500, end_x=75, end_y=0, duration=800)</span><br></pre></td></tr></table></figure><h3 id="从设备拉去文件"><a href="#从设备拉去文件" class="headerlink" title="从设备拉去文件"></a>从设备拉去文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.pull_file(&apos;Library/AddressBook/AddressBook.sqlitedb&apos;)</span><br></pre></td></tr></table></figure><h3 id="推送文件到设备"><a href="#推送文件到设备" class="headerlink" title="推送文件到设备"></a>推送文件到设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &quot;some data for the file&quot;</span><br><span class="line">path = &quot;/data/local/tmp/file.txt&quot;</span><br><span class="line">driver.push_file(path, data.encode(&apos;base64&apos;))</span><br></pre></td></tr></table></figure><h2 id="appium元素定位"><a href="#appium元素定位" class="headerlink" title="appium元素定位"></a>appium元素定位</h2><p>使用id，class等和selenium基本没差别的定位就不介绍了，主要介绍appium独有<code>uiautomator UiSelector</code></p><p>页面class和id等都不能唯一确定元素，但是元素有text属性时，可以使用以下进行定位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().text(&quot;Custom View&quot;)&apos;).click()         #text</span><br><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().textContains(&quot;View&quot;)&apos;).click()        #textContains</span><br><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().textStartsWith(&quot;Custom&quot;)&apos;).click()    #textStartsWith</span><br><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().textMatches(&quot;^Custom.*&quot;)&apos;).click()    #textMatches</span><br></pre></td></tr></table></figure></p><p>也可以加上class属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.TextView&quot;).text(&quot;Custom View&quot;)&apos;).click()     #className</span><br><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().classNameMatches(&quot;.*TextView$&quot;).text(&quot;Custom View&quot;)&apos;).click()          #classNameMatches</span><br></pre></td></tr></table></figure></p><p>多条件精准定位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.EditText&quot;).resourceId(&quot;com.anmav.cashierdesk:id/etToPayPrice&quot;)&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="操作坐标"><a href="#操作坐标" class="headerlink" title="操作坐标"></a>操作坐标</h2><p>appium在进行元素定位时，定位不到唯一标志的元素，可以获取元素的坐标，使用坐标进行操作</p><p><code>appium</code>以及<code>uiautomatorviewer</code>都可以很容易获取到坐标</p><p>appium操作坐标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.tap([(100, 20), (100, 60), (100, 100)], 500)</span><br></pre></td></tr></table></figure><p>三个坐标表示模拟三根手指，只需要一个手指，改成一个坐标即可，500表示持续时间500ms</p><p>或者使用adb命令也可实现同样效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.popen(&quot;adb shell input tap &quot; + str(100) + &quot; &quot; + str(20))</span><br></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://testerhome.com/topics/799" target="_blank" rel="noopener">appium 基础之键盘处理</a><br><a href="https://github.com/appium/appium/blob/master/docs/cn/writing-running-appium/appium-bindings.md" target="_blank" rel="noopener">appium-bindings</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium的常用操作以及元素定位的简单介绍&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://tokyle.com/categories/appium/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>app安装卸载</title>
    <link href="http://tokyle.com/2018/01/17/app%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/"/>
    <id>http://tokyle.com/2018/01/17/app安装卸载/</id>
    <published>2018-01-17T02:54:00.000Z</published>
    <updated>2018-01-24T07:34:55.713Z</updated>
    
    <content type="html"><![CDATA[<p>appium-模拟器安装卸载app</p><a id="more"></a><p>模拟器安装apk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install XXX.apk</span><br></pre></td></tr></table></figure></p><p>卸载apk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall your_package</span><br></pre></td></tr></table></figure></p><p>例子：</p><p>启动android模拟器，参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.view.LoginActivity&apos;</span><br></pre></td></tr></table></figure></p><p>win10打开控制台，进入apk文件所在目录，执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install cashierdesk.apk</span><br></pre></td></tr></table></figure></p><p>在模拟器中可以发现该app已完成安装。</p><p>控制台执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.anmav.cashierdesk</span><br></pre></td></tr></table></figure></p><p>模拟器中可以看见该app完成卸载</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium-模拟器安装卸载app&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://tokyle.com/categories/appium/"/>
    
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="appium" scheme="http://tokyle.com/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>appium入门篇</title>
    <link href="http://tokyle.com/2018/01/16/appium%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <id>http://tokyle.com/2018/01/16/appium入门篇/</id>
    <published>2018-01-16T08:37:10.000Z</published>
    <updated>2018-01-16T08:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>appium环境搭建及简单使用</p><p>测试人员进行app自动化测试的可选框架之一—— <strong>appium</strong></p><a id="more"></a><p>平台说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WIN10_64</span><br><span class="line">python 3.6</span><br></pre></td></tr></table></figure></p><h2 id="appium环境安装"><a href="#appium环境安装" class="headerlink" title="appium环境安装"></a>appium环境安装</h2><h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><p>网上之前的教程基本都是安装SDK或者ADT来进行安装，开始我也是这么装的，在最后创建完虚拟机，开启虚拟机时候报错了，报错信息只记得是建议安装Android Studio，索性也就换成了Android Studio。</p><blockquote><p><a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">Android Studio下载链接</a></p></blockquote><p>如果下载的是不包含SDK的版本，还需要另外下载SDK。安装Android Studio很简单，和Pycharm一模一样，有使用Pycharm经验或者IntelliJ IDEA的应该很熟悉，安装完成之后，找到SDK Manager<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File-Settings-Appearance&amp;Behavior &gt; System Settings &gt; Android SDK</span><br></pre></td></tr></table></figure></p><p>如果本地有SDK，可以在此选择本地的SDK路径，该设置页也支持下载各种SDK Platforms。<br>对应的SDK安装完成之后就可以进行创建虚拟机，找到<code>AVD Manager</code>按键，点击创建。</p><h3 id="安装Android-SDK（和安装Android-Studio任选一种方式即可）"><a href="#安装Android-SDK（和安装Android-Studio任选一种方式即可）" class="headerlink" title="安装Android SDK（和安装Android Studio任选一种方式即可）"></a>安装Android SDK（和安装Android Studio任选一种方式即可）</h3><p><a href="http://developer.android.com/sdk/index.html" target="_blank" rel="noopener">官方下载地址</a></p><p>但是由于国内众所周知的某种原因，不能科学上网貌似无法保证可以下载~</p><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">国内优质android工具网站</a></p><p>搜索<code>android-sdk</code>找到对应系统版本，进行下载。</p><h4 id="配置android环境变量"><a href="#配置android环境变量" class="headerlink" title="配置android环境变量"></a>配置android环境变量</h4><p>与配置JAVA环境变量类似，新增系统变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量名：ANDROID_HOME </span><br><span class="line">变量值：D:\android\android-sdk-windows</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">变量名：PATH</span><br><span class="line">变量值：;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools;</span><br></pre></td></tr></table></figure></p><h4 id="SDK-Manager安装模拟器"><a href="#SDK-Manager安装模拟器" class="headerlink" title="SDK Manager安装模拟器"></a>SDK Manager安装模拟器</h4><p>在你本地解压完成之后的<code>android-sdk-windows</code>目录下找到<code>SDK Manager.exe</code>，双击打开；</p><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">配置参考</a></p><h4 id="安装SDK-Platform-Tools"><a href="#安装SDK-Platform-Tools" class="headerlink" title="安装SDK Platform-Tools"></a>安装SDK Platform-Tools</h4><p>在AndroidDevTools.cn 网站上找到Android SDK Platform-tools下载链接，下载，解压，把解压出来的 platform-tools 文件夹放在<code>android-sdk-windows</code>目录下</p><h3 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h3><h4 id="安装方式一：-使用NodeJS-安装"><a href="#安装方式一：-使用NodeJS-安装" class="headerlink" title="安装方式一： 使用NodeJS 安装"></a>安装方式一： 使用NodeJS 安装</h4><p>1，首先到<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">官网</a>下载安装最新的NodeJS，Windows下属于傻瓜安装。<br>安装完成验证<code>npm</code>或者<code>node -v</code>不报错表明安装完成</p><p>2，安装appium，<code>npm install -g appium</code>命令安装appium（个人实验的效果不好，太慢了，建议采用第二种，安装包安装）</p><h4 id="安装方式二：安装包安装"><a href="#安装方式二：安装包安装" class="headerlink" title="安装方式二：安装包安装"></a>安装方式二：安装包安装</h4><p>建议直接安装appium-desktop，appium server在2015年就不再更新，取而代之的是appium-desktop的出现。</p><p>Appium安装包托管在github上，<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">下载地址</a></p><p>但是个人实验，很多版本都是跳转404页面。。。无语。。。</p><p><a href="https://pan.baidu.com/s/1dmsyiM" target="_blank" rel="noopener">个人网盘地址</a>，密码：<code>v3lt</code>（版本1.2.7）</p><p>下载完成后，安装即可。</p><h4 id="appium环境检查"><a href="#appium环境检查" class="headerlink" title="appium环境检查"></a>appium环境检查</h4><p>可以使用<code>appium-doctor</code>工具进行环境检查，<code>npm install -g appium-doctor</code>进行安装。</p><h2 id="Appium-desktop使用简介"><a href="#Appium-desktop使用简介" class="headerlink" title="Appium-desktop使用简介"></a>Appium-desktop使用简介</h2><p>打开appium-desktop，点击“放大镜”图标进行设置，</p><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1fnij5mz213j21an0qs40e.jpg" alt="示例"><br>设置完成后点击 Start Session</p><p><img src="http://ww1.sinaimg.cn/large/a025e134gy1fnij7beapkj21cr0qm77r.jpg" alt="完成之后"></p><p>直接单击最左栏的元素，在中间和右边会显示该元素属性，找到对应的ID值等，定位方式和selenium类似。</p><h2 id="查找appPackage和appActivity"><a href="#查找appPackage和appActivity" class="headerlink" title="查找appPackage和appActivity"></a>查找appPackage和appActivity</h2><p>appium进行自动化测试，需要<code>appPackage</code>和<code>appActivity</code>两个参数，下面是从apk文件获取的方法：</p><h3 id="apk反编译"><a href="#apk反编译" class="headerlink" title="apk反编译"></a>apk反编译</h3><h4 id="apktool"><a href="#apktool" class="headerlink" title="apktool"></a>apktool</h4><blockquote><p>地址： <a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">apktool</a></p></blockquote><p>用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool.jar d yourApkFile.apk</span><br></pre></td></tr></table></figure></p><h3 id="获取appPackage和appActivity"><a href="#获取appPackage和appActivity" class="headerlink" title="获取appPackage和appActivity"></a>获取appPackage和appActivity</h3><p>打开apk反编译之后的文件夹，打开<code>AndroidManifest.xml</code>文件</p><p><code>package</code>获取 <code>appPackage</code>，<code>activity</code>获取<code>appActivity</code>。</p><h2 id="appium-Demo"><a href="#appium-Demo" class="headerlink" title="appium Demo"></a>appium Demo</h2><p>实现计算器计算，代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from appium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">desired_caps = &#123;&#125;</span><br><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.android.calculator2&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;.Calculator&apos;</span><br><span class="line">desired_caps[&apos;noReset&apos;] = True</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, desired_caps)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()</span><br><span class="line">driver.find_element_by_accessibility_id(&apos;multiply&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;com.android.calculator2:id/digit_9&apos;).click()</span><br><span class="line">driver.find_element_by_accessibility_id(&apos;plus&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;com.android.calculator2:id/digit_1&apos;).click()</span><br><span class="line">driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()</span><br><span class="line">driver.find_element_by_accessibility_id(&apos;equals&apos;).click()</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium环境搭建及简单使用&lt;/p&gt;
&lt;p&gt;测试人员进行app自动化测试的可选框架之一—— &lt;strong&gt;appium&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="appium" scheme="http://tokyle.com/categories/appium/"/>
    
    
      <category term="python" scheme="http://tokyle.com/tags/python/"/>
    
      <category term="自动化测试" scheme="http://tokyle.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="appium" scheme="http://tokyle.com/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>smtp发邮件</title>
    <link href="http://tokyle.com/2018/01/12/smtp%E5%8F%91%E9%82%AE%E4%BB%B6/"/>
    <id>http://tokyle.com/2018/01/12/smtp发邮件/</id>
    <published>2018-01-12T09:53:14.000Z</published>
    <updated>2018-01-12T09:54:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用python3发送网易邮箱邮件</p><a id="more"></a><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.header import Header</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_email(mail_host, from_account, from_passwd, to_account, subject, content):</span><br><span class="line">    mail = smtplib.SMTP()</span><br><span class="line">    mail.connect(mail_host)</span><br><span class="line">    mail.login(from_account, from_passwd)</span><br><span class="line"></span><br><span class="line">    # 发送邮件</span><br><span class="line">    message = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)</span><br><span class="line">    message[&apos;From&apos;] = from_account</span><br><span class="line">    message[&apos;To&apos;] = to_account</span><br><span class="line">    message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)</span><br><span class="line">    mail.sendmail(from_account, to_account, message.as_string())</span><br></pre></td></tr></table></figure></p><p>菜鸟教程上有一种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.header import Header</span><br><span class="line"> </span><br><span class="line"># 第三方 SMTP 服务</span><br><span class="line">mail_host=&quot;smtp.XXX.com&quot;  #设置服务器</span><br><span class="line">mail_user=&quot;XXXX&quot;    #用户名</span><br><span class="line">mail_pass=&quot;XXXXXX&quot;   #口令 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sender = &apos;from@runoob.com&apos;</span><br><span class="line">receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱</span><br><span class="line"> </span><br><span class="line">message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)</span><br><span class="line">message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)</span><br><span class="line">message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)</span><br><span class="line"> </span><br><span class="line">subject = &apos;Python SMTP 邮件测试&apos;</span><br><span class="line">message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">try:</span><br><span class="line">    smtpObj = smtplib.SMTP() </span><br><span class="line">    smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号</span><br><span class="line">    smtpObj.login(mail_user,mail_pass)</span><br><span class="line">    smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">    print (&quot;邮件发送成功&quot;)</span><br><span class="line">except smtplib.SMTPException:</span><br><span class="line">    print (&quot;Error: 无法发送邮件&quot;)</span><br></pre></td></tr></table></figure></p><p>这样执行，会报错<br><code>smtplib.SMTPDataError: (554, &#39;DT:SPM 126 smtp5,jtKowAD3MJz2c1JXLcK2AA--.52114S2 1465021431,please see http://mail.163.com/help/help_spam_16.htm?ip=123.114.121.110&amp;hostid=smtp5&amp;time=1465021431&#39;)</code></p><p>解决办法就是指定收发件人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message[&apos;From&apos;] = from_account</span><br><span class="line">message[&apos;To&apos;] = to_account</span><br></pre></td></tr></table></figure></p><p>p.s 网易邮箱客户端默认授权码是关闭的，直接执行python调用会失败，要先进客户端，把客户授权码打开<br>位置：<code>设置-客户端授权密码</code><br>设置完成之后，登录密码就使用你设置的授权码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用python3发送网易邮箱邮件&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://tokyle.com/categories/python/"/>
    
    
      <category term="python3" scheme="http://tokyle.com/tags/python3/"/>
    
      <category term="smtplib" scheme="http://tokyle.com/tags/smtplib/"/>
    
  </entry>
  
</feed>
