<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>它夏了夏天</title>
  
  <subtitle>生命中有一种遇见，就让它美如行云流水，然后一生去回味。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tokyle.com/"/>
  <updated>2017-12-28T08:50:30.946Z</updated>
  <id>http://www.tokyle.com/</id>
  
  <author>
    <name>Kyle</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python3.6安装pywin32</title>
    <link href="http://www.tokyle.com/2017/12/28/python3-6%E5%AE%89%E8%A3%85pywin32/"/>
    <id>http://www.tokyle.com/2017/12/28/python3-6安装pywin32/</id>
    <published>2017-12-28T08:47:55.000Z</published>
    <updated>2017-12-28T08:50:30.946Z</updated>
    
    <content type="html"><![CDATA[<p>python3.6装载win32api模块</p><a id="more"></a><p>使用pip安装win32报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find a version that satisfies the requirement win32api (from versions: )No matching distribution found for win32api</span><br></pre></td></tr></table></figure><p>stack overflow上面有两种回答</p><ol><li><code>pip install pypiwin32</code></li><li>从<a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20220/" target="_blank" rel="noopener">windowsapi官网</a>下载安装程序，点击安装</li></ol><p>首先尝试了第一种方式，没啥用，还是找不到win32api<br>尝试第二种方法，直接报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python version 3.6-32 required, which was not found in the registry.</span><br></pre></td></tr></table></figure></p><p>找半天问题，首先本地python是64位版本，下载的也是64位安装包，报这莫名其妙的注册表错误。<br>后来在注册表里加了个python3.6-32就能安装了，莫名其妙。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\3.6-32</span><br></pre></td></tr></table></figure></p><p>导入了个奇奇怪怪的win32api，貌似用不了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import win32.win32api</span><br><span class="line">import win32.win32clipboard</span><br><span class="line">import win32com</span><br></pre></td></tr></table></figure></p><p>根据以往踩坑经验，改注册表好像都没什么好下场，于是乎，把装好的win32全部删除，注册表还原，重新下载更新版本的pywin32：<a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/" target="_blank" rel="noopener">下载链接</a></p><p>重新安装之后，重启pycharm，这次好像是成功了。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import win32api</span><br><span class="line">import win32con</span><br><span class="line"></span><br><span class="line">def keyDown(keyName):</span><br><span class="line">    win32api.keybd_event()</span><br><span class="line">    win32con.KEYEVENTF_KEYUP</span><br></pre></td></tr></table></figure></p><p>反正过程是挺无语的，莫名其妙的就好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python3.6装载win32api模块&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://www.tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="pywin32" scheme="http://www.tokyle.com/tags/pywin32/"/>
    
  </entry>
  
  <entry>
    <title>python3_map()函数</title>
    <link href="http://www.tokyle.com/2017/12/27/python3-map-%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tokyle.com/2017/12/27/python3-map-函数/</id>
    <published>2017-12-27T09:47:09.000Z</published>
    <updated>2017-12-27T09:56:54.371Z</updated>
    
    <content type="html"><![CDATA[<p>坑爹python3改动之map()函数</p><a id="more"></a><p>做自动化测试，获取并校验下拉列表中所有值，由于实在不想先写个空列表，再来个for循环全部加到列表中，就想到了map()函数，折腾半天，各种报错，墙里墙外翻半天，终于找到跟我一样入坑的人。</p><p>map()函数，python3改动</p><p>在python2中，以下代码可输出一个列表<code>[1, 2, 3, 4, 5]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = map(lambda x:x, [1, 2, 3, 4, 5])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>但是python3，这玩意只能输出个map对象：<code>&lt;map object at 0x00000278CB45D4E0&gt;</code></p><p>遇到这玩意也很多次了，直接加list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = list(map(lambda x: x, [1, 2, 3, 4, 5]))</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p><p>这样，在python3就可以输出<code>[1, 2, 3, 4, 5]</code></p><p>附自动化测试比较下拉列表值是否符合预期示例代码（百度新闻高级设置-显示条数为例）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.support.ui import Select</span><br><span class="line">import unittest</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class News_Baidu(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        #打开浏览器</span><br><span class="line">        self.brower = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    def test_Checklist(self):</span><br><span class="line">        #打开百度新闻页面</span><br><span class="line">        self.brower.get(&quot;http://news.baidu.com/&quot;)</span><br><span class="line">        #定位“高级设置”，并点击</span><br><span class="line">        self.brower.find_element_by_link_text(&quot;高级搜索&quot;).click()</span><br><span class="line">        #定位“搜索结果显示条数”</span><br><span class="line">        select_element = Select(self.brower.find_element_by_name(&apos;rn&apos;))</span><br><span class="line">        #获取下拉列表所有元素对象</span><br><span class="line">        select_options = select_element.options</span><br><span class="line">        #声明一个期望下拉列表值的列表(百度也是够坑的，值前面还有一个空格)</span><br><span class="line">        expect_optionlist = [&apos; 每页显示10条&apos;, &apos; 每页显示20条&apos;, &apos; 每页显示50条&apos;]</span><br><span class="line">        #获取实际的下拉列表值的列表</span><br><span class="line">        actual_optionlist = list(map(lambda option:option.text, select_options))</span><br><span class="line">        #断言结果是否适合期望</span><br><span class="line">        self.assertListEqual(actual_optionlist, expect_optionlist)</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        #休眠</span><br><span class="line">        time.sleep(5)</span><br><span class="line">        #退出浏览器</span><br><span class="line">        self.brower.quit()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;坑爹python3改动之map()函数&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://www.tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="selenium" scheme="http://www.tokyle.com/tags/selenium/"/>
    
      <category term="python3" scheme="http://www.tokyle.com/tags/python3/"/>
    
  </entry>
  
  <entry>
    <title>html报告乱码</title>
    <link href="http://www.tokyle.com/2017/12/26/html%E6%8A%A5%E5%91%8A%E4%B9%B1%E7%A0%81/"/>
    <id>http://www.tokyle.com/2017/12/26/html报告乱码/</id>
    <published>2017-12-26T06:03:49.000Z</published>
    <updated>2017-12-26T06:06:58.444Z</updated>
    
    <content type="html"><![CDATA[<p>使用HTMLTestRunner进行测试报告输出时，错误说明，中午乱码，版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3.6</span><br><span class="line">HTMLTestRunner 1.1.1</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>网上搜了一堆，全是用python2.x的，心痛，2.X到2020年不就不支持了嘛，为啥一个个的都在2.X上面，没办法，自己去捣鼓源码。</p><p>报告输出的html文件，使用类似于notepad的编辑器打开，编码格式改为UTF-8，重新在浏览器中打开，错误描述的中文显示就是正常文字。所以，只要在输出时，设置编码为“utf-8”应该就可以。</p><p>找到本地的HTMLTestRunner安装路径，一般都是在<code>G:\skills\python36\Lib\site-packages\HtmlTestRunner</code>类似这样的路径下，毕竟扩展包。下面有三个文件，和一个文件夹，文件夹里是报告的模板，不考虑，三个文件，一个是HtmlTestRunner的介绍，一个是<code>runner.py</code>，一个是<code>result.py</code>，输出报告，应该就在<code>result.py</code>文件中。</p><p>编辑器打开<code>result.py</code>，找到第350行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with open(path_file, &apos;w&apos;) as report_file:</span><br></pre></td></tr></table></figure></p><p>只要修改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with open(path_file, &apos;w&apos;,encoding=&apos;utf-8&apos;) as report_file:</span><br></pre></td></tr></table></figure></p><p>即可。</p><p>附上<code>百度搜索自动化测试</code>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import unittest</span><br><span class="line">import time</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from HtmlTestRunner import HTMLTestRunner</span><br><span class="line"></span><br><span class="line">class GloryRoad(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        #启动chrome浏览器</span><br><span class="line">        self.brower = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">    def test_baidu(self):</span><br><span class="line">        #访问百度首页</span><br><span class="line">        self.brower.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">        #清空输入框内容</span><br><span class="line">        self.brower.find_element_by_id(&apos;kw&apos;).clear()</span><br><span class="line">        #搜索框输入“selenium3”</span><br><span class="line">        self.brower.find_element_by_id(&apos;kw&apos;).send_keys(&apos;selenium3&apos;)</span><br><span class="line">        #点击“百度一下”按键</span><br><span class="line">        self.brower.find_element_by_id(&apos;su&apos;).click()</span><br><span class="line">        #休眠3s</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        assert &quot;google&quot; in self.brower.page_source, &quot;页面中不存在要寻找的关键字！&quot;</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        #退出浏览器</span><br><span class="line">        self.brower.quit()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    suite = unittest.TestLoader().loadTestsFromTestCase(GloryRoad)</span><br><span class="line">    runner = HTMLTestRunner(output=&apos;G:/workstation/report&apos;, report_title=&apos;Test Result&apos;)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用HTMLTestRunner进行测试报告输出时，错误说明，中午乱码，版本：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python3.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HTMLTestRunner 1.1.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://www.tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="selenium" scheme="http://www.tokyle.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>pycharm单元测试</title>
    <link href="http://www.tokyle.com/2017/12/25/pycharm%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.tokyle.com/2017/12/25/pycharm单元测试/</id>
    <published>2017-12-25T08:26:03.000Z</published>
    <updated>2017-12-25T08:29:43.883Z</updated>
    
    <content type="html"><![CDATA[<p>使用pycharm编写/执行单元测试用例</p><a id="more"></a><p>python单元测试用例，调用方式使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unittest.main()</span><br></pre></td></tr></table></figure></p><p>该方式，在python shell中可执行成功，在pycharm中会一直报错，参考网上的写法，最后校验调用改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if _name_ == &apos;_main_&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure></p><p>结果一直报错，<code>NameError: name &#39;_name_&#39; is not defined</code></p><p>简直了，找了半天，还是在墙外找到跟我有一样经历的哥们的求救，报错原因是<br><code>_name_</code>和<code>_main</code>都是双下划线，正确写法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>真是日常坑自己…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用pycharm编写/执行单元测试用例&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://www.tokyle.com/categories/skill/"/>
    
    
      <category term="pycharm" scheme="http://www.tokyle.com/tags/pycharm/"/>
    
      <category term="unittest" scheme="http://www.tokyle.com/tags/unittest/"/>
    
  </entry>
  
  <entry>
    <title>selenium3+python3.6搭建测试</title>
    <link href="http://www.tokyle.com/2017/12/25/selenium3-python3-6%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.tokyle.com/2017/12/25/selenium3-python3-6搭建测试/</id>
    <published>2017-12-25T05:26:29.000Z</published>
    <updated>2017-12-26T06:09:13.282Z</updated>
    
    <content type="html"><![CDATA[<p>python3.6<br>selenium3<br>chrome64<br>firefox57</p><a id="more"></a><p>selenium3开始，需要浏览器驱动，加载驱动方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，驱动放在任意位置，代码中，引驱动，打开浏览器（webdriver.Chrome(executable_path=&quot;驱动路径&quot;）</span><br><span class="line">2，将驱动放到浏览器安装目录下，和浏览器启动程序同级，将浏览器安装路径加到环境变量Path中，重启pycharm</span><br></pre></td></tr></table></figure></p><p>自动化测试示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加载驱动程序</span><br><span class="line">#firefox(驱动放到浏览器安装目录，目录加到Path)</span><br><span class="line">#driver = webdriver.Firefox()</span><br><span class="line">#chrome(驱动放到浏览器安装目录，目录加到Path)</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">#chrome默认安装路径，驱动指定路径</span><br><span class="line">#driver = webdriver.Chrome(executable_path=&quot;G:/Selenium/drivers/chromedriver.exe&quot;)</span><br><span class="line">#打开百度首页</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line">#清空搜索输入框默认内容</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).clear()</span><br><span class="line">#输入框中输入“自动化测试”</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;自动化测试&quot;)</span><br><span class="line">#单击搜索按钮</span><br><span class="line">driver.find_element_by_id(&quot;su&quot;).click()</span><br><span class="line"></span><br><span class="line">#等待3秒</span><br><span class="line">time.sleep(3)</span><br><span class="line"></span><br><span class="line">#退出浏览器</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python3.6&lt;br&gt;selenium3&lt;br&gt;chrome64&lt;br&gt;firefox57&lt;/p&gt;
    
    </summary>
    
      <category term="自动化测试" scheme="http://www.tokyle.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="selenium" scheme="http://www.tokyle.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>world_map</title>
    <link href="http://www.tokyle.com/2017/12/21/world-map/"/>
    <id>http://www.tokyle.com/2017/12/21/world-map/</id>
    <published>2017-12-21T09:32:33.000Z</published>
    <updated>2017-12-27T09:54:39.671Z</updated>
    
    <content type="html"><![CDATA[<p>pygal-2.4<br>pygal-maps-world-1.0.2    世界地图模块位置变更</p><a id="more"></a><p>pygal内置世界地图模块，包括国别码模块<code>COUNTRIES</code>以及世界地图模块<code>World</code>。</p><p>当前版本下，绘制世界地图，需要从<code>pygal_maps_world.i18n</code>中引国别码，需要从<code>pygal_maps_world.maps</code>中引世界地图。</p><p>参考代码如下：</p><h2 id="countries-py"><a href="#countries-py" class="headerlink" title="countries.py"></a><code>countries.py</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pygal_maps_world.i18n import COUNTRIES</span><br><span class="line"></span><br><span class="line">def get_country_code(country_name):</span><br><span class="line">    &quot;&quot;&quot;根据指定国家，返回国别码&quot;&quot;&quot;</span><br><span class="line">    for code, name in COUNTRIES.items():</span><br><span class="line">        if name == country_name or name == country_name.title():</span><br><span class="line">            return code</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure><h2 id="population-data-py"><a href="#population-data-py" class="headerlink" title="population_data.py"></a><code>population_data.py</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from settings import Settings</span><br><span class="line">from countries import get_country_code</span><br><span class="line">from pygal.style import RotateStyle as RS,LightColorizedStyle as LCS</span><br><span class="line">import pygal_maps_world.maps</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_setting = Settings()</span><br><span class="line">filename = data_setting.json_population</span><br><span class="line"></span><br><span class="line">with open(filename) as f_obj:</span><br><span class="line">    pop_data = json.load(f_obj)</span><br><span class="line"></span><br><span class="line">#打印每个国家2010年的人口</span><br><span class="line">cc_population = &#123;&#125;</span><br><span class="line">for pop_dict in pop_data:</span><br><span class="line">    if pop_dict[&apos;Year&apos;] == &apos;2010&apos;:</span><br><span class="line">        country_name = pop_dict[&apos;Country Name&apos;]</span><br><span class="line">        population = int(float(pop_dict[&apos;Value&apos;]))</span><br><span class="line">        code = get_country_code(country_name)</span><br><span class="line">        if code:</span><br><span class="line">            cc_population[code] = population</span><br><span class="line">#按人口给国家分组</span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line">for cc, pop in cc_population.items():</span><br><span class="line">    if pop &lt; 10000000:</span><br><span class="line">        cc_pops_1[cc] = pop</span><br><span class="line">    elif pop &lt; 1000000000:</span><br><span class="line">        cc_pops_2[cc] = pop</span><br><span class="line">    else:</span><br><span class="line">        cc_pops_3[cc] = pop</span><br><span class="line"></span><br><span class="line">wm_style = RS(&apos;#336699&apos;,base_style=LCS)</span><br><span class="line">wm = pygal_maps_world.maps.World(style=wm_style)</span><br><span class="line">wm.title = &quot;World Population in 2010.by Country&quot;</span><br><span class="line">wm.add(&apos;0-10m&apos;, cc_pops_1)</span><br><span class="line">wm.add(&apos;10m-1bn&apos;, cc_pops_2)</span><br><span class="line">wm.add(&apos;&gt;1bn&apos;, cc_pops_3)</span><br><span class="line"></span><br><span class="line">wm.render_to_file(&apos;world_population.svg&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pygal-2.4&lt;br&gt;pygal-maps-world-1.0.2    世界地图模块位置变更&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.tokyle.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="pygal" scheme="http://www.tokyle.com/tags/pygal/"/>
    
  </entry>
  
  <entry>
    <title>绘制随机漫步图</title>
    <link href="http://www.tokyle.com/2017/12/20/%E7%BB%98%E5%88%B6%E9%9A%8F%E6%9C%BA%E6%BC%AB%E6%AD%A5%E5%9B%BE/"/>
    <id>http://www.tokyle.com/2017/12/20/绘制随机漫步图/</id>
    <published>2017-12-20T09:04:26.000Z</published>
    <updated>2017-12-27T09:54:55.942Z</updated>
    
    <content type="html"><![CDATA[<p>matplotlib可绘制随机漫步图，取随机X个数，在画布上绘制，并加入渐变颜色，效果还是挺好看的</p><a id="more"></a><p>代码如下：</p><h3 id="random-walk-py"><a href="#random-walk-py" class="headerlink" title="random_walk.py"></a><code>random_walk.py</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from random import choice</span><br><span class="line"></span><br><span class="line">class RandomWalk():</span><br><span class="line">    &quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self,num_point=5000):</span><br><span class="line">        &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot;</span><br><span class="line">        self.num_point = num_point</span><br><span class="line"></span><br><span class="line">        #所有随机漫步的点都始于（0,0）</span><br><span class="line">        self.x_values = [0]</span><br><span class="line">        self.y_values = [0]</span><br><span class="line"></span><br><span class="line">    def get_step(self):</span><br><span class="line">        &quot;&quot;&quot;设置前进方向及距离&quot;&quot;&quot;</span><br><span class="line">        direction = choice([1, -1])</span><br><span class="line">        distance = choice([0, 1, 2, 3, 4])</span><br><span class="line">        step = distance * direction</span><br><span class="line">        return step</span><br><span class="line"></span><br><span class="line">    def fill_walk(self):</span><br><span class="line">        &quot;&quot;&quot;计算随机漫步的所有点&quot;&quot;&quot;</span><br><span class="line">        while len(self.x_values) &lt; self.num_point:</span><br><span class="line">            x_step = self.get_step()</span><br><span class="line">            y_step = self.get_step()</span><br><span class="line"></span><br><span class="line">            #排除原地踏步情况</span><br><span class="line">            if x_step == 0 and y_step == 0:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            #计算下一个点的位置</span><br><span class="line">            next_x = self.x_values[-1] + x_step</span><br><span class="line">            next_y = self.y_values[-1] + y_step</span><br><span class="line"></span><br><span class="line">            self.x_values.append(next_x)</span><br><span class="line">            self.y_values.append(next_y)</span><br></pre></td></tr></table></figure><h3 id="rw-visual-py"><a href="#rw-visual-py" class="headerlink" title="rw_visual.py"></a><code>rw_visual.py</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from random_walk import RandomWalk</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    #创建一个随机漫步实例，并将所有包含的点绘制出</span><br><span class="line">    rw = RandomWalk(30000)</span><br><span class="line">    rw.fill_walk()</span><br><span class="line"></span><br><span class="line">    point_num = list(range(rw.num_point))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_num, cmap=plt.cm.Blues, s=5)</span><br><span class="line">    #突出起点和终点</span><br><span class="line">    plt.scatter(0, 0, c=&apos;green&apos;, s=100)</span><br><span class="line">    plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, s=100)</span><br><span class="line"></span><br><span class="line">    #隐藏坐标轴</span><br><span class="line">    plt.axes().get_xaxis().set_visible(False)</span><br><span class="line">    plt.axes().get_yaxis().set_visible(False)</span><br><span class="line">    #plt.subplot().set_xticks([])</span><br><span class="line">    #plt.subplot().set_yticks([])</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    keep_drawing = input(&quot;Make another walk?y/n&quot;)</span><br><span class="line">    if keep_drawing == &apos;n&apos;:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><p>可成功绘制随机漫步图，然而有个警告报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.warnings.warn(message, mplDeprecation, stacklevel=1)</span><br></pre></td></tr></table></figure></p><p>原因是matplotlib版本问题，出在隐藏坐标轴<code>plt.axes().get_yaxis()</code>处，尝试修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot().set_xticks([])</span><br><span class="line">plt.subplot().set_yticks([])</span><br></pre></td></tr></table></figure></p><p>然而没啥用，还是在警告，暂时没解决。。好在不影响功能，不是强迫症也就无视这红字了。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;matplotlib可绘制随机漫步图，取随机X个数，在画布上绘制，并加入渐变颜色，效果还是挺好看的&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.tokyle.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="matplotlib" scheme="http://www.tokyle.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib绘制渐变图</title>
    <link href="http://www.tokyle.com/2017/12/20/matplotlib%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE/"/>
    <id>http://www.tokyle.com/2017/12/20/matplotlib绘制渐变图/</id>
    <published>2017-12-20T08:13:30.000Z</published>
    <updated>2017-12-27T09:53:49.209Z</updated>
    
    <content type="html"><![CDATA[<p>使用matplotlib绘制1-1000所有整数立方值图形报错</p><a id="more"></a><p>绘制1~1000所有整数的立方图，颜色采用渐变蓝色，点越接近坐标原点，颜色越浅。<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">x_values = list(range(1,1001))</span><br><span class="line">y_values = [x**3 for x in x_values]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, c=y_values,cmap=plt.cm.Blues,s=40)</span><br><span class="line"></span><br><span class="line">#设置图表坐标并设置坐标标签</span><br><span class="line">plt.title(&quot;Square Numbers&quot;,fontsize=24)</span><br><span class="line">plt.xlabel(&quot;Values&quot;,fontsize=14)</span><br><span class="line">plt.ylabel(&quot;Square of Value&quot;,fontsize=14)</span><br><span class="line"></span><br><span class="line">#设置坐标轴刻度</span><br><span class="line">plt.tick_params(axis=&apos;both&apos;, labelsize=14)</span><br><span class="line"></span><br><span class="line">#设置坐标轴取值</span><br><span class="line">plt.axes([0,1100,0,1100000])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>可以成功绘制图形，但是有警告报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserWarning: Unable to find pixel distance along axis for interval padding of ticks; assuming no interval padding needed.warnings.warn(&quot;Unable to find pixel distance along axis &quot;</span><br></pre></td></tr></table></figure></p><p>原因：<br>设置坐标轴取值时，使用的是<em>plt.axes</em>，该函数创建的是一个轴对象，并将输入解释为指定位置的矩形，绘制的坐标轴中取值0在绘制的图形之外，超出了限制范围，所以警告报错。</p><p>解决方案：<br>使用<code>plt.axis()</code>代替<code>plt.axes()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#设置坐标轴取值</span><br><span class="line">plt.axis([0,1100,0,1100000])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用matplotlib绘制1-1000所有整数立方值图形报错&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.tokyle.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="matplotlib" scheme="http://www.tokyle.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>Django2.0更新内容记录</title>
    <link href="http://www.tokyle.com/2017/12/19/Django2-0%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.tokyle.com/2017/12/19/Django2-0更新内容记录/</id>
    <published>2017-12-19T09:39:33.000Z</published>
    <updated>2017-12-27T09:54:20.489Z</updated>
    
    <content type="html"><![CDATA[<p>Django 2.0 变更内容(不按版本敲着实是有点坑o(╥﹏╥)o)</p><a id="more"></a><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>Django 1.9在创建<code>models.ForeignKey</code>外键时，可写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topic = models.ForeignKey(Topic）</span><br></pre></td></tr></table></figure></p><p>Django 2.0需要多传一个字段<code>on_delete</code>，且可给定默认值<code>models.CASCADE</code><br>所以上述可写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topic = models.ForeignKey(Topic,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></p><h2 id="指定app-name"><a href="#指定app-name" class="headerlink" title="指定app_name"></a>指定app_name</h2><p>Django 1.9在映射URL时，<em>工程的urls.py</em>可写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path,include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;admin/&apos;, admin.site.urls),</span><br><span class="line">    path(&apos;&apos;,include(&apos;learning_logs.urls&apos;, namespace=&apos;learning_logs&apos;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><em>应用的urls.py</em>可写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;</span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    #主页</span><br><span class="line">    path(&apos;&apos;, views.index, name=&apos;index&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>该写法在Django 2.0中会出现报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;Specifying a namespace in include() without providing an app_name &apos;</span><br><span class="line">django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</span><br></pre></td></tr></table></figure></p><p>意思是缺少了app_name，所以需要指定app_name，我的做法是在应用的urls.py文件中指定app_name，也就是工程的urls.py保持不变，<em>应用的urls.py</em>增加app_name指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;</span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">app_name = &apos;learning_logs&apos;</span><br><span class="line">urlpatterns = [</span><br><span class="line">    #主页</span><br><span class="line">    path(&apos;&apos;, views.index, name=&apos;index&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="映射URL"><a href="#映射URL" class="headerlink" title="映射URL"></a>映射URL</h2><p>对于django.urls.path()函数，允许有简单的表示方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r’^articles/(?P[0-9]&#123;4&#125;)/$’, views.year_archive),</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(‘articles//‘, views.year_archive),</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://tokyle.com/2017/12/13/Django%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E9%93%BE%E6%8E%A5/#more" target="_blank" rel="noopener">用法参见前博客记录</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django 2.0 变更内容(不按版本敲着实是有点坑o(╥﹏╥)o)&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.tokyle.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="Django" scheme="http://www.tokyle.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>性能测试-理发师模型</title>
    <link href="http://www.tokyle.com/2017/12/15/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E7%90%86%E5%8F%91%E5%B8%88%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.tokyle.com/2017/12/15/性能测试-理发师模型/</id>
    <published>2017-12-15T02:36:26.000Z</published>
    <updated>2017-12-15T02:49:25.316Z</updated>
    
    <content type="html"><![CDATA[<p>性能测试有个有名的模型，理发店模型，理发店标配：一间或大或小的店面，一个或几个理发师，几张理发的椅子和顾客休息的椅子。<br>本文介绍一下理发店模型（相关资料网上一堆，只是为了自己记录）</p><a id="more"></a><h1 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h1><p><img src="/images/barbershop.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">该理发店：</span><br><span class="line">1. 理发店共有3名理发师；</span><br><span class="line">2. 每位理发师剪一个发的时间都是1小时；</span><br><span class="line">3. 我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，我们的顾客会立马生气的走人。</span><br></pre></td></tr></table></figure><h1 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；</span><br><span class="line">2. 当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；</span><br><span class="line">3. 很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时；</span><br></pre></td></tr></table></figure><p>从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从1位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。</p><p>当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。</p><p>不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。</p><p>通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。</p><p>在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。</p><h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><p><img src="/images/performance.jpg" alt=""></p><p>这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示<code>资源的利用情况</code>（Utilization，包括硬件资源和软件资源）、<code>吞吐量</code>（Throughput，这里是指每秒事务数）以及<code>响应时间</code>（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。</p><p>在这张图中我们可以看到，<strong>最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。</strong></p><p>根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“<strong><em>最佳并发用户数</em></strong>（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“<strong>最大并发用户数</strong>（The Maximum Number of Concurrent Users）”。</p><p>当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。</p><p>对应到我们上面理发店的例子，每小时3个顾客就是这个理发店的最佳并发用户数，而每小时9个顾客则是它的最大并发用户数。当每小时都有3个顾客到来时，理发店的整体工作效率最高；而当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。<br>当然，如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。</p><blockquote><p><a href="http://www.cnblogs.com/jackei/archive/2006/11/20/565527.html" target="_blank" rel="noopener">大神原网址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;性能测试有个有名的模型，理发店模型，理发店标配：一间或大或小的店面，一个或几个理发师，几张理发的椅子和顾客休息的椅子。&lt;br&gt;本文介绍一下理发店模型（相关资料网上一堆，只是为了自己记录）&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://www.tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="性能" scheme="http://www.tokyle.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Jmeter系统监控配置</title>
    <link href="http://www.tokyle.com/2017/12/15/Jmeter%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.tokyle.com/2017/12/15/Jmeter系统监控配置/</id>
    <published>2017-12-15T02:00:54.000Z</published>
    <updated>2017-12-15T02:07:40.969Z</updated>
    
    <content type="html"><![CDATA[<p>Jmeter是测试人员经常会使用的一款压力测试工具，经常会使用来测试接口的性能；Jmeter同时具备监控服务器资源使用情况的功能。</p><p>主要介绍一下怎么使用Jmeter来监控服务器的CPU,内存,IO等信息。</p><a id="more"></a><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>使用Jmeter监控系统性能，实际上是插件的使用，可以认为是在Jmeter中装载了一个小型监控系统的客户端，同时在需要监控的系统内装载服务端，在允许Jmeter时，同时打开监控服务端，进行系统资源的监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：JMeterPlugins-Standard</span><br><span class="line">服务端：ServerAgent</span><br></pre></td></tr></table></figure><p>下载地址：</p><blockquote><p><a href="http://jmeter-plugins.org/downloads/all/" target="_blank" rel="noopener">官网下载</a></p></blockquote><p>百度云链接：</p><blockquote><p><a href="https://pan.baidu.com/s/1eR5iOue" target="_blank" rel="noopener">JMeterPlugins-Standard-1.4.0</a><br><a href="https://pan.baidu.com/s/1nvKJQad" target="_blank" rel="noopener">ServerAgent-2.2.1</a></p></blockquote><h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><p>将 JMeterPlugins-Standard-1.4.0.zip 中 lib\ext 目录下的 JmeterPlugins-Standard.jar 文件都放到apache-jmeter-2.13\lib\ext目录中。<br>将 ServerAgent-2.2.1.zip 解压后放到要监控的服务器中待使用。</p><h1 id="监控设置"><a href="#监控设置" class="headerlink" title="监控设置"></a>监控设置</h1><ol><li>启动Jmeter后，右击<code>线程组</code>，选择<code>添加- 监听器- jp@gc-PerfMon Metrics Collector</code></li><li>打开<code>jp@gc - PerfMon Metrics Collector</code>，点击<code>Add Row</code>选择相应监控对象（服务器IP和监控内容），端口默认<code>4444</code>即可。</li></ol><p><img src="/images/jmeter-setting.jpg" alt=""></p><h1 id="开启监控"><a href="#开启监控" class="headerlink" title="开启监控"></a>开启监控</h1><ol><li>设置<code>永远循环</code>，否则监控会运行一次就断开，设置方式：<code>线程组-循环次数（选择永远）</code></li><li>服务端运行<code>ServerAgent</code>，Linux系统运行shell脚本，windows系统执行bat脚本（系统需事先完成jdk配置）</li></ol><p>成功完成系统资源监控</p><p><img src="/images/jmeter-cpu.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jmeter是测试人员经常会使用的一款压力测试工具，经常会使用来测试接口的性能；Jmeter同时具备监控服务器资源使用情况的功能。&lt;/p&gt;
&lt;p&gt;主要介绍一下怎么使用Jmeter来监控服务器的CPU,内存,IO等信息。&lt;/p&gt;
    
    </summary>
    
      <category term="性能测试" scheme="http://www.tokyle.com/categories/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="Jmeter" scheme="http://www.tokyle.com/tags/Jmeter/"/>
    
      <category term="性能" scheme="http://www.tokyle.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客中加入图片</title>
    <link href="http://www.tokyle.com/2017/12/14/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>http://www.tokyle.com/2017/12/14/Hexo博客中加入图片/</id>
    <published>2017-12-14T13:44:10.000Z</published>
    <updated>2017-12-14T14:26:03.424Z</updated>
    
    <content type="html"><![CDATA[<p>好不容易搭好了hexo，插个图片各种错</p><a id="more"></a><h1 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h1><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>markdown语法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source/images/image.jpg</span><br><span class="line">   ![](/images/image.jpg)</span><br></pre></td></tr></table></figure><p>这样，图片既可以在首页内容访问，也可以在文章正文中使用</p><h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>首先在/blog/_config.yml 中设置 post_asset_folder: true ，这样在 hexo new “文章” 时会生成与文章标题一样的目录，将文章中需要使用的图片存在该目录下（source//_posts/文章）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_posts/post_name/image.jpg</span><br><span class="line">   ![](image.jpg)</span><br></pre></td></tr></table></figure><h1 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h1><p>现在大多数做法是使用图床，自己也看过七牛云之类的做为图床，但是，七牛云个流氓，还要手持身份证认证，所以暂时放弃。（该方法就是在图床中生成链接，直接引链接即可）</p><blockquote><p><a href="https://coding.net/help/doc/project/markdown.html" target="_blank" rel="noopener">Markdown 语法介绍</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好不容易搭好了hexo，插个图片各种错&lt;/p&gt;
    
    </summary>
    
      <category term="skill" scheme="http://www.tokyle.com/categories/skill/"/>
    
    
      <category term="Hexo" scheme="http://www.tokyle.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>python编码</title>
    <link href="http://www.tokyle.com/2017/12/13/python%E7%BC%96%E7%A0%81/"/>
    <id>http://www.tokyle.com/2017/12/13/python编码/</id>
    <published>2017-12-13T08:44:58.000Z</published>
    <updated>2017-12-27T09:55:13.823Z</updated>
    
    <content type="html"><![CDATA[<p>python日常踩坑系列（二）</p><a id="more"></a><p>日常编写python脚本，鉴于java各种坑编码经历，首先就会把pycharm编码设置成utf-8，但是不知道什么鬼，设置完成之后，编译还是会报编码gbk的错误</p><p><img src="/images/utf8.jpg" alt=""></p><p>问题如下：</p><p>“UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 34: illegal multibyte sequence”</p><p>解决方案：</p><p>1，设置所有文件编码默认为utf-8（文件最前面指定）</p><p><img src="/images/pycharm_setting.jpg" alt=""></p><p>2，处理数据时进行转码：</p><p>with open(“population.json”,encoding=’UTF-8’) as data:</p><p>–完 (#^.^#)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python日常踩坑系列（二）&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.tokyle.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django获取不到特定链接</title>
    <link href="http://www.tokyle.com/2017/12/13/Django%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E9%93%BE%E6%8E%A5/"/>
    <id>http://www.tokyle.com/2017/12/13/Django获取不到特定链接/</id>
    <published>2017-12-13T08:01:41.000Z</published>
    <updated>2017-12-14T14:19:39.143Z</updated>
    
    <content type="html"><![CDATA[<p>python日常踩坑系列</p><a id="more"></a><p><img src="/images/new_python.jpg" alt=""></p><p>按照教程方式打开本地特定链接报错<br>源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># Home page.</span></span><br><span class="line">    url(<span class="string">r'^$'</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Show all topics.</span></span><br><span class="line">    url(<span class="string">r'^topics/$'</span>, views.topics, name=<span class="string">'topics'</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Detail page for a single topic.</span></span><br><span class="line">    url(<span class="string">r'^topics/(?P&lt;topic_id&gt;\d+)/$'</span>, views.topic, name=<span class="string">'topic'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>打开<a href="http://127.0.0.1:8000/topics/1/报错：" target="_blank" rel="noopener">http://127.0.0.1:8000/topics/1/报错：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Using the URLconf defined in learning_log.urls, Django tried these URL patterns, in <span class="keyword">this</span> order:</span><br><span class="line">  <span class="number">1</span>. admin/</span><br><span class="line">  <span class="number">2</span>. [name=<span class="string">'index'</span>]</span><br><span class="line">  <span class="number">3</span>. topics [name=<span class="string">'topics'</span>]</span><br><span class="line">  <span class="number">4</span>. topics/?P&lt;topic_id&gt;\d+/ [name=<span class="string">'topic'</span>]</span><br><span class="line">The current path, topics/<span class="number">1</span>/, didn<span class="string">'t match any of these.</span></span><br></pre></td></tr></table></figure><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>Django2.0有更新<br>对于django.urls.path()函数，允许有简单的表示方法：</p><p><em>url(r’^articles/(?P<year>[0-9]{4})/$’, views.year_archive),</year></em></p><p>可以写成：</p><p><em>path(‘articles/<int:year>/‘, views.year_archive),</int:year></em></p><p>所以代码可更改为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">'lerning_logs'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#主页</span></span><br><span class="line">    path(<span class="string">''</span>, views.index, name=<span class="string">'index'</span>),</span><br><span class="line">    <span class="comment">#显示所有主题</span></span><br><span class="line">    path(<span class="string">'topics'</span>, views.topics, name=<span class="string">'topics'</span>),</span><br><span class="line">    <span class="comment">#特定主题的详细页面</span></span><br><span class="line">    <span class="comment">#path('topics/?P&lt;topic_id&gt;\d+/', views.topic, name='topic'),</span></span><br><span class="line">    path(<span class="string">'topics/&lt;topic_id&gt;/'</span>, views.topic, name=<span class="string">'topic'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python日常踩坑系列&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.tokyle.com/tags/python/"/>
    
      <category term="Django" scheme="http://www.tokyle.com/tags/Django/"/>
    
  </entry>
  
</feed>
