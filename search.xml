<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[centos7搭建zabbix]]></title>
    <url>%2F2018%2F05%2F11%2Fcentos7%E6%90%AD%E5%BB%BAzabbix%2F</url>
    <content type="text"><![CDATA[centos7搭建zabbix3.4 zabbix安装环境要求： zabbix安装要求 安装前置操作关闭selinux1sudo sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config 升级yum1sudo yum -y update 切换iptables防火墙查看防火墙状态1firewall-cmd --state 关闭防火墙1systemctl stop firewalld.service 禁止开机启动启动防火墙1systemctl disable firewalld.service iptables设置安装iptables服务1yum install iptables-services 开启iptables防火墙1systemctl start iptables.service 开启特定端口：编辑文件：/etc/sysconfig/iptables，加入想要开放的端口即可，例如开放10051端口：1-A INPUT -p tcp -m tcp --dport 8090 -j ACCEPT 保存退出，重启防火墙：1systemctl restart iptables.service 安装MySQL下载源包：1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 安装mysql源:1yum localinstall mysql57-community-release-el7-8.noarch.rpm 检查是否安装成功：1yum repolist enabled | grep &quot;mysql.*-community.*&quot; 123mysql-connectors-community/x86_64 MySQL Connectors Community 51mysql-tools-community/x86_64 MySQL Tools Community 63mysql57-community/x86_64 MySQL 5.7 Community Server 267 可以修改源配置，安装你喜欢的版本：1vim /etc/yum.repos.d/mysql-community.repo 只需要把对应的enable改成1即可。安装1yum install mysql-community-server 启动服务12systemctl start mysqldsystemctl status mysqld #查看状态 配置开机启动12systemctl enable mysqldsystemctl daemon-reload 修改root密码查看默认密码：1grep &apos;temporary password&apos; /var/log/mysqld.log 修改密码很简单，mysql -uroot -p进入控制台，修改：1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;yourpwd&apos;; 修改权限：1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;pwd&apos; WITH GRANT OPTION; 配置防火墙，开放3306端口，即可在windows使用工具连接数据库。 安装Apache123sudo yum -y install httpdsystemctl start httpd.service #启动systemctl enable httpd.service #开机启动 安装php1sudo yum install php 安装php扩展1sudo yum install php-mysqlnd php-gd libjpeg* php-snmp php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-bcmath php-mhash php-common php-ctype php-xml php-xmlreader php-xmlwriter php-session php-mbstring php-gettext php-ldap php-mysqli --skip-broken 1sudo yum install wget telnet net-tools python-paramiko gcc gcc-c++ dejavu-sans-fonts python-setuptools python-devel sendmail mailx net-snmp net-snmp-devel net-snmp-utils freetype-devel libpng-devel perl unbound libtasn1-devel p11-kit-devel OpenIPMI unixODBC 修改一些配置设置MySQL参数1vim /etc/my.cnf 在文件最后添加以下内容（8G内存为例，根据自己配置适当修改）123456789101112131415161718192021222324innodb_file_per_table = 1innodb_status_file = 1innodb_buffer_pool_size = 6Ginnodb_flush_log_at_trx_commit = 2innodb_log_buffer_size = 16Minnodb_log_file_size = 64Minnodb_support_xa = 0default-storage-engine = innodbbulk_insert_buffer_size = 8Mjoin_buffer_size = 16Mmax_heap_table_size = 32Mtmp_table_size = 32Mmax_tmp_tables = 48read_buffer_size = 32Mread_rnd_buffer_size = 16Mkey_buffer_size = 32Mthread_cache_size = 32innodb_thread_concurrency = 8innodb_flush_method = O_DIRECTinnodb_rollback_on_timeout = 1query_cache_size = 16Mquery_cache_limit = 16Mcollation_server = utf8_bincharacter_set_server = utf8 注：原则上 innodb_buffer_pool_size 需要设置为主机内存的 80%，如果主机内存不是 8GB，以上参数可依据相应比例进行调整，例如主机内存为 16GB，则 innodb_buffer_pool_size 建议设置为 12GB，innodb_log_buffer_size 建议设置为 32M，innodb_log_file_size 建议设置为 128M，以此类推。请注意innodb_buffer_pool_size的值必须是整数，例如主机内存是4G，那么innodb_buffer_pool_size可以设置为3G，而不能设置为3.2G 重启MySQL1systemctl restart mysqld 创建zabbix数据库用户进入mysql控制台1mysql -uroot -p 12345create database zabbix character set utf8;create user zabbix@&apos;%&apos; identified by &apos;yourpwd&apos;;GRANT ALL PRIVILEGES ON *.* TO &apos;zabbix&apos;@&apos;%&apos; IDENTIFIED BY &apos;yourpwd&apos; WITH GRANT OPTION;flush privileges;exit; 安装zabbix源1sudo rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm 安装zabbix1sudo yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-java-gateway zabbix-web 配置zabbix导入zabbix所需信息12cd /usr/share/doc/zabbix-server-mysql-3.4.3zcat create.sql.gz | mysql -uroot zabbix -p 配置zabbix参数1sudo vim /etc/zabbix/zabbix_server.conf 1234567891011121314151617181920DBPassword=yourpwd(125行左右)CacheSize=512M（在385行左右）HistoryCacheSize=128M（在410行左右）HistoryIndexCacheSize=128M（在419行左右）TrendCacheSize=128M（在428行左右）ValueCacheSize=256M（在438行左右）Timeout=30（在448行左右） 配置Apache中的php参数123456789sudo vim /etc/httpd/conf.d/zabbix.confphp_value max_execution_time 600php_value memory_limit 256Mphp_value post_max_size 32Mphp_value upload_max_filesize 32Mphp_value max_input_time 600php_value always_populate_raw_post_data -1date.timezone 去掉注释符号#，并将值修改为 Asia/Shanghai 重启系统1reboot 启动zabbix1sudo systemctl start httpd &amp;&amp; systemctl start zabbix-server 在浏览器中输入http://your_IP/zabbix，进入zabbix页面进行初始化配置，单击两次next step，填写正确数据库信息，继续next step，填写zabbix detail（相当于起名字），端口不变！！！然后finish，完成安装。 设置中文第一次登录zabbix监控系统，默认用户为admin，默认密码zabbix，正确登录系统。选择Administrator –&gt; Users –&gt; Admin，在Language栏选择Chinese(zh_CN)完成汉化。 OVER! 参考链接 centos7安装zabbix3.4]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Zabbiz3.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos部署.net core]]></title>
    <url>%2F2018%2F05%2F10%2Fcentos%E9%83%A8%E7%BD%B2-net-core%2F</url>
    <content type="text"><![CDATA[Centos7部署.net core应用 安装dotnet产品提要首先需要注册Microsoft签名密钥并添加Microsoft产品提要，才能安装.net12rpm --import https://packages.microsoft.com/keys/microsoft.ascsh -c &apos;echo -e &quot;[packages-microsoft-com-prod]\nname=packages-microsoft-com-prod \nbaseurl= https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/dotnetdev.repo&apos; 默认使用root用户操作 安装.NET SDK首先更新yum1yum update 安装所需组件1yum install libunwind libicu 安装.NET SDK1yum install dotnet-sdk-2.1.200 完成安装，dotnet --version验证安装 部署应用将你的.net core应用随意放置在某个目录，进入目录，执行1dotnet YourApp.WebApi.dll 即可启动服务，默认启动端口为5000. nginx代理安装nginx安装nginx需要添加EPEL仓库，然后再安装：12yum install epel-releaseyum install nginx 启动nginx启动：1systemctl start nginx 设置nginx开机启动1systemctl enable nginx 修改配置将nginx的默认配置文件中的80端口内容注释掉，文件路径：/etc/nginx/nginx.conf,然后在nginx的配置加载目录下创建你需要代理的端口配置文件yourapp.conf，路径：/etc/nginx/conf.d，文件内容：1234567891011server &#123; listen 80; location / &#123; proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125;&#125; 重启nginx即可通过80端口访问部署的.net core服务。 问题记录由于安装在linux上，不同于windows，出现了一个现象，页面进行请求之后，消息队列中的消息一直无法被消费，查看日志，显示：123The handler does not support custom handling of certificates with this combination of libcurl (7.29.0) and its SSL backend (&quot;NSS/3.28.4&quot;).) ---&gt; System.PlatformNotSupportedException: The handler does not support custom handling of certificates with this combination of libcurl (7.29.0) and its SSL backend (&quot;NSS/3.28.4&quot;).at System.Net.Http.CurlHandler.SslProvider.SetSslOptionsForUnsupportedBackend(EasyRequest easy, ClientCertificateProvider certProvider)at System.Net.Http.CurlHandler.SslProvider.SetSslOptions(EasyRequest easy, ClientCertificateOption clientCertOption 原因就是linux不支持ssl（貌似是这样），搜了一堆答案，大部分是建议升级curl 解决linux netcore https请求使用自签名证书忽略安全检查方法开始：首先安装openssl和gcc1yum install openssl-devel gcc 然后是最新版本的curl：123456wget https://curl.haxx.se/download/curl-7.59.0.tar.gztar -zxf curl-7.59.0.tar.gzcd curl-7.59.0./configure --prefix=/usr/local/curl/ --without-nss --with-ssl=/usr/local/ssl/makemake install 备份原来的curl：1mv /usr/bin/curl /usr/bin/curl.bak 新安装的curl创建软链接1ln -s /usr/local/curl/bin/curl /usr/bin/curl 查看此时curl版本1curl --version 编辑搜索目录：1vim /etc/ld.so.conf 增加一行：/usr/local/curl/lib 重启服务，完成！ 参考链接 centos部署.net core]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用webpagetest测试不同国家登录响应]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%BD%BF%E7%94%A8webpagetest%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E5%9B%BD%E5%AE%B6%E7%99%BB%E5%BD%95%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[使用webpageTest模拟不同国家进行登录操作 产品boss提了个从不同国家测试系统访问响应时间的需求，目前完成的是不同国家登录操作。 先来个套话：网站的打开速度直接影响用户体验，据悉，网站若没有在4秒内读取出来，大多数的访客就会选择离开，而且网页的载入速度也会影响网站的排名，因此，网站的打开速度极其重要。根据不同的需求去分析网站的加载速度，有助于促进网站高效运行 工具拿到需求之后，上网搜过很多工具，接触了的有： Pingdomsucuri 以及正在使用的： webpagetest webpagetest其他的就不介绍了，只介绍怎么使用webpagetest进行不同国家的登录操作。说实话，刚开始接触时候有点懵，webpagetest自己有个Auth模块，原以为可以直接通过这个来进行登录鉴权，结果可以预料，压根没用，后来就开始琢磨Script模块。看了n久官方文档之后，实验出来了，鼓励大家看官方文档啊。。。上链接： script模块 webpagetest提供脚本的形式，帮助用户使用脚本来填充表单，达到登录的目的。这点看下来有点类似于自动化测试时候，先看页面源码，找到用户名/密码源码的唯一标识，在script代码框中使用该唯一标识来指代需要用到的元素，例如：登录页面源码展示的用户名：1&lt;input name=&quot;username&quot; class=&quot;ant-input ng-not-empty ng-dirty ng-valid-parse userInput ng-touched&quot; id=&quot;username&quot; type=&quot;text&quot; placeholder=&quot;用户名或邮箱&quot; ng-model=&quot;model.username&quot; ng-change=&quot;onChange()&quot;&gt; 从上面的源码可以看出，使用id可以唯一标志该字段，在自动化测试中使用find_element_by_id(&#39;username&#39;)即可获得该页面元素，类比到webpagetest的script，也是如此：1setValue id=username yourusername 即可完成定位到用户名并且完成用户名输入，同样的，密码：源码为：1&lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; class=&quot;ant-input ant-input-lg ng-not-empty ng-dirty ng-valid-parse userInput ng-touched&quot; placeholder=&quot;密码&quot; ng-model=&quot;model.password&quot; autocomplete=&quot;off&quot; focus-if=&quot;model.username&quot; ng-change=&quot;pwdOnChange()&quot;&gt; webpagetest定位：1setValue id=password yourpassword 当然，点击登录按钮也类似：1clickAndWait innerText=Login 以上演示的只是一种定位方式，更多的使用，还是去看官方文档吧，有各种情况可供选择~~ 登录直接上我的登录脚本：123456logData 0navigate https://test-login.comlogData 1setValue name=username yourusernamesetValue name=password yourpasswordclickAndWait type=submit 说明logData个人理解是是否开启数据记录的标志，类似开启缓存（可能理解不对），0为关闭，1为开启，对于登录之后的操作，可以在登录前设置logData为1，打开数据记录，这样在后续的操作中就可以使用登录之后的用户信息。 官方示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// load the account name and passwordloadVariables accounts.txt// bring up the login screensetEventName launchnavigate http://webmail.aol.com// ignore any errors from here on (in case the mailbox is empty or we get image challenged)ignoreErrors 1// log insetValue name=loginId %AOLSN%setValue name=password %AOLPW%setEventName loadsubmitForm name=AOLLoginForm// only read and send a mail once an hourminInterval AOLMail 60// close the today curtainclick className=backdropsleep 5// Open the first message with a subject of &quot;test&quot;setEventName readclickAndWait innerText=test// delete the messageclick title=Delete (del)sleep 5// open the compose mail formsetEventName composeclickAndWait title=Write mail (Alt + w)// send a test message to myselfsleep 1setValue tabindex=100 %AOLSN%setValue name=Subject testloadFile msg.txt %MSG%setInnerText contentEditable=true %MSG%sleep 1setDOMElement className=confirmMessagesetEventName sendclickAndWait innerText=SendendInterval// sign offsetEventName logoutclickAndWait className=signOutLink]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>webpagetest</tag>
        <tag>response time</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建Nitrate]]></title>
    <url>%2F2018%2F04%2F22%2FCentos7%E6%90%AD%E5%BB%BANitrate%2F</url>
    <content type="text"><![CDATA[基于python+Django，测试用例管理平台Nitrate搭建 前言基于目前Jira+confluence已经成为日常流程管控，老大就琢磨着我们测试用例需要个专门的平台进行管控，所以也就产生了调研的需求，候选有俩：testlink和Nitrate，由于目前组内python氛围较活跃，自动化测试用例也是基于python，所以也就是希望能找到一个基于python写的系统，方便定制，二次开发嘛~ 开篇在有搭建Nitrate这个任务之后，本着偷懒的心态，首先搜了一圈搭建教程，然而，一篇都没找到！！！也就是说，我得自己折腾了！！！没办法，直接上github找项目地址，说不定在说明里面有介绍呢 Nitrate项目地址 里面的确是有介绍，搭建教程貌似也有，还是各种环境的搭建教程，好像看到些光辉啊.. Nitrate Doc 文档介绍了各种搭建教程，选你看着比较顺眼的，动手吧~ 坎坷的系统搭建平时Linux还算是比较顺手，直接选Installing nitrate on RHEL6 with Apache and MySQL，虽然介绍的Redhat的，不都涨一样嘛~开工：由于自己电脑还是Windows的（别提了，测试嘛，需要太多工具，唉），首先就是搭个Centos7的虚拟机，轻车熟路了，非常迅速的完工，Xshell远程连上，开始愉快的黑窗口作业。。 环境准备由于搭建的centos7是所谓的CentOS-7-x86_64-Everything-1611版本，网卡什么的驱动都是装好了，如果你装的是最间版，那么ifconfig命令都敲不了。。。自己百度怎么开网吧。。 Git由于是需要从github仓库直接拉项目，所以git就必须先搭个了:1yum install git 就完成了，如果遇到yum不让用，日志显示XX进程正在使用yum，那要么等，要么就是暴力点，直接杀：1rm -rf /var/run/yum.pid 然后就可以安心的yum install了。 Django由于Nitrate是基于Django的，所以，必不可少的需要装个Django；装Django，有三种方法： pip最简单就是一条命令带走：1pip install Django setuptools使用setuptools安装，首先需要先装它：1yum install python-setuptools 安装完成之后，再使用easy_install安装django：1easy_install django 源码安装首先是上官网下载个tar.gz格式的源码包： 官方源码下载地址 然后就可以开始正常的解压安装了：1234cd your_pathrz (windows拷包到linux)tar -zxvf Django-x.x.tar.gzpython setup.py install 即可完成安装，验证：1django-admin.py 正确安装会出现很多选项，类似这样：12345678910111213[root@localhost run]# django-admin.pyType &apos;django-admin.py help &lt;subcommand&gt;&apos; for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata 好了，这这里来说说遇到的第一个坑，鬼知道是为了个什么，Nitrate限制Django版本，当你使用pip或者easy_install安装个2.0版本之后，后面编译安装Nitrate时候，就会开始报错给你了，到时候就知道是多么北京的事了,印象中Django版本要求是1.8&lt;=Django版本&lt;1.11 ，唉，所以，如果谁正准备装这个，或者偶尔看到我写的这玩意，真的，记住，还是源码安装Django吧。。。另外，强烈建议你就要你装完系统的python版本（多半是2.7.5），千万别升3.6，不然可能还要哭一会。 pip上面说的可以使用pip来装Django，但是，貌似2.7.5的python压根就没自带个pip，好吧，反正后面还需要pip，还是先装上吧：首先安装epel扩展1yum -y install epel-release 然后就可以装pip了：1yum -y install python-pip 完了清个cache:1yum clean all MySQL数据库选MySQL也没什么可纠结了，安装：下载源包：1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 安装mysql源:1yum localinstall mysql57-community-release-el7-8.noarch.rpm 检查是否安装成功：1yum repolist enabled | grep &quot;mysql.*-community.*&quot; 123mysql-connectors-community/x86_64 MySQL Connectors Community 51mysql-tools-community/x86_64 MySQL Tools Community 63mysql57-community/x86_64 MySQL 5.7 Community Server 267 可以修改源配置，安装你喜欢的版本：1vim /etc/yum.repos.d/mysql-community.repo 只需要把对应的enable改成1即可。 安装1yum install mysql-community-server 这里再次吐槽下公司的网，烂的不是一点半点，这个包印象中有近200M，公司网以20k速度给我下。。。直接流量开热点才下好。 启动服务systemctl start mysqld 查看状态systemctl status mysqld 配置开机启动12systemctl enable mysqldsystemctl daemon-reload 修改root密码查看默认密码：1grep &apos;temporary password&apos; /var/log/mysqld.log 修改密码很简单，mysql -uroot -p进入控制台，改：1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;pwd&apos;; 顺便改个权限：1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;pwd&apos; WITH GRANT OPTION; 再配个防火墙，3306端口打开，那么在Windows中就能使用工具连接数据库了。 修改字符编码编辑/etc/my.cnf，在[mysqld]下添加配置：123[mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos; 重启mysql服务即可。 开始搭建项目clone首先是clone到本地：12cd /usr/local/srcgit clone https://github.com/Nitrate/Nitrate.git 大概有这么些东西：123456789101112131415161718192021[root@localhost Nitrate]# lltotal 160-rw-r--r--. 1 root root 609 Apr 22 12:23 AUTHORSdrwxr-xr-x. 4 root root 43 Apr 22 12:41 build-rw-r--r--. 1 root root 66430 Apr 22 12:23 CHANGELOG.rstdrwxr-xr-x. 4 root root 60 Apr 22 12:23 contribdrwxr-xr-x. 2 root root 35 Apr 22 12:41 distdrwxr-xr-x. 3 root root 76 Apr 22 12:23 docs-rw-r--r--. 1 root root 18092 Apr 22 12:23 LICENSE-rw-r--r--. 1 root root 1690 Apr 22 12:23 Makefile-rwxr-xr-x. 1 root root 279 Apr 22 12:23 manage.py-rw-r--r--. 1 root root 256 Apr 22 12:23 MANIFEST.indrwxr-xr-x. 2 root root 110 Apr 22 12:41 Nitrate.egg-info-rw-r--r--. 1 root root 25090 Apr 22 12:23 nitrate.spec-rw-r--r--. 1 root root 1753 Apr 22 12:23 README.rst-rw-r--r--. 1 root root 1127 Apr 22 12:23 requirements.txt-rw-r--r--. 1 root root 657 Apr 22 12:23 setup.cfg-rw-r--r--. 1 root root 2234 Apr 22 12:23 setup.pydrwxr-xr-x. 19 root root 4096 Apr 22 12:23 tcms-rw-r--r--. 1 root root 827 Apr 22 12:23 tox.ini-rw-r--r--. 1 root root 4 Apr 22 12:23 VERSION.txt 安装开发包1yum install gcc python-devel mysql-devel krb5-devel libxml2-devel libxslt-devel 安装完成之后，还要项目依赖 安装依赖进入项目目录：1cd /usr/local/src/Nitrate 开始安装：1pip install . 这个过程会在你本地检查一个个的依赖，没有就装，其中就会检查Django，这破版本的问题，真的是害我又重装一遍。安装速度取决于你的网速和电脑硬件性能，安心等着successful。 源码安装Nitrate还是在这个目录，执行:1python setup.py install 使用源码安装Nitrate，等着就好，安装完成之后，可以到/usr/lib/python2.7/site-packages下找到你安装的Nitrate：123[root@localhost site-packages]# ls | grep NitrateNitrate-4.1-py2.7.eggNitrate-4.1-py2.7.egg-info 看看里面有啥：12345678910111213141516171819202122232425262728293031323334[root@localhost site-packages]# cd Nitrate-4.1-py2.7.egg[root@localhost Nitrate-4.1-py2.7.egg]# lsEGG-INFO tcms[root@localhost Nitrate-4.1-py2.7.egg]# lltotal 4drwxr-xr-x. 2 root root 130 Apr 22 14:52 EGG-INFOdrwxr-xr-x. 18 root root 4096 Apr 22 14:52 tcms[root@localhost Nitrate-4.1-py2.7.egg]# cd tcms/[root@localhost tcms]# lltotal 56-rw-r--r--. 1 root root 307 Apr 22 14:52 celery.py-rw-r--r--. 1 root root 586 Apr 22 14:52 celery.pycdrwxr-xr-x. 11 root root 4096 Apr 22 14:52 core-rw-r--r--. 1 root root 301 Apr 22 14:52 __init__.py-rw-r--r--. 1 root root 422 Apr 22 14:52 __init__.pycdrwxr-xr-x. 4 root root 75 Apr 22 14:52 integrationdrwxr-xr-x. 4 root root 32 Apr 22 14:52 localedrwxr-xr-x. 3 root root 261 Apr 22 14:52 managementdrwxr-xr-x. 3 root root 228 Apr 22 14:52 profilesdrwxr-xr-x. 2 root root 272 Apr 22 14:52 reportdrwxr-xr-x. 2 root root 241 Apr 22 14:52 searchdrwxr-xr-x. 2 root root 224 Apr 22 16:15 settingsdrwxr-xr-x. 8 root root 94 Apr 22 15:09 staticdrwxr-xr-x. 14 root root 4096 Apr 22 16:06 templatesdrwxr-xr-x. 6 root root 4096 Apr 22 14:52 testcasesdrwxr-xr-x. 6 root root 4096 Apr 22 14:52 testplansdrwxr-xr-x. 6 root root 4096 Apr 22 14:52 testrunsdrwxr-xr-x. 2 root root 86 Apr 22 14:52 tests-rw-r--r--. 1 root root 2334 Apr 22 14:52 urls.py-rw-r--r--. 1 root root 2299 Apr 22 14:52 urls.pycdrwxr-xr-x. 2 root root 123 Apr 22 14:52 utils-rw-r--r--. 1 root root 1896 Apr 22 14:52 wsgi.py-rw-r--r--. 1 root root 1605 Apr 22 14:52 wsgi.pycdrwxr-xr-x. 4 root root 4096 Apr 22 14:52 xmlrpc 记住tcms/这个文件夹，后面的配置，全都在这里面。 配置初始化数据首先是创建nitrate这数据库，然后创建用户，赋权限，初始化数据：12create database nitrate;GRANT ALL PRIVILEGES ON *.* TO &apos;nitrate&apos;@&apos;%&apos; IDENTIFIED BY &apos;pwd&apos; WITH GRANT OPTION; 修改配置之前接触过Django的，应该都知道有个文件setting.py这里面是你app的一些重要配置，我们要改的，也就是它。Nitrate把传统意义上的setting.py分成了两个文件（其实是一个文件）：12common.pyproject.py 文件路径：/usr/lib/python2.7/site-packages/Nitrate-4.1-py2.7.egg/tcms/settings几乎所有配置都可以在common.py中完成，但是project.py在文件开头就是一句话：1from common import * 所以，我们常用的配置，在project.py中完成即可。内容大概长这样，可以参考我的配：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Django settings for product env.from common import *# Debug settingsDEBUG = TrueTEMPLATE_DEBUG = DEBUG# Database settingsDATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;nitrate&apos;, &apos;USER&apos;: &apos;nitrate&apos;, &apos;PASSWORD&apos;: &apos;pwd&apos;, &apos;HOST&apos;: &apos;192.168.98.133&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;, &apos;slave_1&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;nitrate&apos;, &apos;USER&apos;: &apos;nitrate&apos;, &apos;PASSWORD&apos;: &apos;pwd&apos;, &apos;HOST&apos;: &apos;192.168.98.133&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;,&#125;# add RemoteUserMiddleWare if kerberos authentication is enabledMIDDLEWARE_CLASSES += (# &apos;django.contrib.auth.middleware.RemoteUserMiddleware&apos;,)# Remote kerberos authentication backends#AUTHENTICATION_BACKENDS = (# &apos;tcms.core.contrib.auth.backends.ModAuthKerbBackend&apos;,#)DATABASE_ROUTERS = [&apos;tcms.core.utils.tcms_router.RWRouter&apos;]# Kerberos realm#KRB5_REALM = &apos;EXAMPLE.COM&apos;# Bugzilla integration setttings# Config following settings if your want to integrate with bugzillaBUGZILLA3_RPC_SERVER = &apos;&apos;BUGZILLA_URL = &apos;&apos;BUGZILLA_USER = &apos;&apos;BUGZILLA_PASSWORD = &apos;&apos;# JIRA integration setttings# Config following settings if your want to integrate with JIRAJIRA_URL = &apos;&apos;# Set the default send mail addressEMAIL_HOST = &apos;smtp.example.com&apos;EMAIL_FROM = &apos;noreply@example.com&apos;# Site-specific messages# First run - to detemine need port user or not.FIRST_RUN = False# You can add a help link on the footer of home page as following format:# (&apos;http://foo.com&apos;, &apos;foo&apos;)FOOTER_LINKS = ( (&apos;/xmlrpc/&apos;, &apos;XML-RPC service&apos;),)# added for nitrate3.4 compatibilityDEFAULT_GROUPS = [&apos;default&apos;]TESTOPIA_XML_VERSION = &apos;1.0&apos;# admin settingsADMINS = ( # (&apos;Your Name&apos;, &apos;your_email@domain.com&apos;),)# user guide URLUSER_GUIDE_URL = &quot;&quot;DEFAULT_PAGE_SIZE = 100 基本需要修改的，一是DEBUG开关，第二个是数据库配置，开启DEBUG开关是为了后面初始化数据时候获取staticfile，开始第二个坑：12AUTHENTICATION_BACKENDSMIDDLEWARE_CLASSES 注释别放开啊别放开，千万别手痒，惨痛的教训，就是手痒在不知道这俩什么含义就放开了，然后在搭建完成之后，登录都登录不了。。一直在报jquery.min.js 404，这个问题真的是折腾死，开始根本想不到是这边的问题，造成把common.py文件研究了个遍，环境重新又搭建两遍，一遍使用venv开启，一遍按原来的来，最终在万念俱灰，把注释又加上才解决，唉。。。 配置common.py首先，直接上我配完的，可参考:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509# -*- coding: utf-8 -*-import django.conf.global_settings as DEFAULT_SETTINGSimport os.pathNITRATE_VERSION = &apos;4.0.0&apos;DEBUG = False# Administrators error report email settingsADMINS = ( # (&apos;Your Name&apos;, &apos;your_email@example.com&apos;),)TCMS_ROOT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), &apos;..&apos;).replace(&apos;\\&apos;, &apos;/&apos;))MANAGERS = ADMINSDATABASES = &#123; # Master DB for writing &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;nitrate&apos;, &apos;USER&apos;: &apos;nitrate&apos;, &apos;PASSWORD&apos;: &apos;pwd&apos;, &apos;HOST&apos;: &apos;192.168.98.133&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;, # First slave DB for reading &apos;slave_1&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;nitrate&apos;, &apos;USER&apos;: &apos;nitrate&apos;, &apos;PASSWORD&apos;: &apos;pwd&apos;, &apos;HOST&apos;: &apos;192.168.98.133&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;, # Second slave DB for reporting, optional &apos;slave_report&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.3306&apos;, &apos;NAME&apos;: &apos;nitrate&apos;, &apos;USER&apos;: &apos;nitrate&apos;, &apos;PASSWORD&apos;: &apos;pwd&apos;, &apos;HOST&apos;: &apos;192.168.98.133&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;&#125;# Hosts/domain names that are valid for this site; required if DEBUG is False# See https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hostsALLOWED_HOSTS = [&apos;*&apos;]# Local time zone for this installation. Choices can be found here:# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name# although not all choices may be available on all operating systems.# In a Windows environment this must be set to your system time zone.TIME_ZONE = &apos;UTC&apos;# Language code for this installation. All choices can be found here:# http://www.i18nguy.com/unicode/language-identifiers.htmlLANGUAGE_CODE = &apos;en-us&apos;SITE_ID = 1# If you set this to False, Django will make some optimizations so as not# to load the internationalization machinery.USE_I18N = True# If you set this to False, Django will not format dates, numbers and# calendars according to the current locale.USE_L10N = True# If you set this to False, Django will not use timezone-aware datetimes.USE_TZ = False# Absolute filesystem path to the directory that will hold user-uploaded files.# Example: &quot;/var/www/example.com/media/&quot;MEDIA_ROOT = &apos;&apos;# URL that handles the media served from MEDIA_ROOT. Make sure to use a# trailing slash.# Examples: &quot;http://example.com/media/&quot;, &quot;http://media.example.com/&quot;MEDIA_URL = &apos;&apos;# URL prefix for admin absolute URLADMIN_PREFIX = &apos;/admin&apos;LOGIN_URL = &apos;nitrate-login&apos;LOGIN_REDIRECT_URL = &apos;user-profile-redirect&apos;LOGOUT_REDIRECT_URL = &apos;nitrate-login&apos;# Absolute path to the directory static files should be collected to.# Don&apos;t put anything in this directory yourself; store your static files# in apps&apos; &quot;static/&quot; subdirectories and in STATICFILES_DIRS.# Example: &quot;/var/www/example.com/static/&quot;#BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), &apos;..&apos;).replace(&apos;\\&apos;, &apos;/&apos;))#STATIC_ROOT = &apos;/usr/lib/python2.7/site-packages/Nitrate-4.1-py2.7.egg/tcms/static/&apos;STATIC_ROOT = &apos;/home/nitrate/projects/site/assets&apos;#STATIC_ROOT = os.path.join(TCMS_ROOT_PATH, &apos;static&apos;)# URL prefix for static files.# Example: &quot;http://example.com/static/&quot;, &quot;http://static.example.com/&quot;STATIC_URL = &apos;/static/&apos;# Additional locations of static filesSTATICFILES_DIRS = ( # Put strings here, like &quot;/home/html/static&quot; or &quot;C:/www/django/static&quot;. # Always use forward slashes, even on Windows. # Don&apos;t forget to use absolute paths, not relative paths. os.path.join(TCMS_ROOT_PATH,&apos;static&apos;), #&apos;/usr/lib/python2.7/site-packages/Nitrate-4.1-py2.7.egg/tcms/static/&apos;,# &apos;/home/nitrate/projects/site/assets&apos;,)# List of finder classes that know how to find static files in# various locations.STATICFILES_FINDERS = ( &apos;django.contrib.staticfiles.finders.FileSystemFinder&apos;, &apos;django.contrib.staticfiles.finders.AppDirectoriesFinder&apos;,)# Make this unique, and don&apos;t share it with anybody.SECRET_KEY = &apos;^8y!)$0t7yq2+65%&amp;_#@i^_o)eb3^q--y_$e7a_=t$%$1i)zuv&apos;TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [ os.path.join(TCMS_ROOT_PATH, &apos;templates/&apos;).replace(&apos;\\&apos;, &apos;/&apos;), ], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;debug&apos;: True, &apos;context_processors&apos;: [ &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.i18n&apos;, &apos;django.template.context_processors.media&apos;, &apos;django.template.context_processors.static&apos;, &apos;django.template.context_processors.tz&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, # Added for Nitrate &apos;django.template.context_processors.request&apos;, &apos;tcms.core.context_processors.admin_prefix_processor&apos;, &apos;tcms.core.context_processors.auth_backend_processor&apos;, &apos;tcms.core.context_processors.request_contents_processor&apos;, &apos;tcms.core.context_processors.settings_processor&apos;, ], &#125;, &#125;,]MIDDLEWARE_CLASSES = ( &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;, &apos;django.middleware.locale.LocaleMiddleware&apos;, &apos;django.middleware.common.CommonMiddleware&apos;, &apos;tcms.core.middleware.CsrfDisableMiddleware&apos;, &apos;django.middleware.csrf.CsrfViewMiddleware&apos;, &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;, &apos;django.contrib.messages.middleware.MessageMiddleware&apos;,)ROOT_URLCONF = &apos;tcms.urls&apos;# Python dotted path to the WSGI application used by Django&apos;s runserver.WSGI_APPLICATION = &apos;tcms.wsgi.application&apos;INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.admindocs&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.sites&apos;, &apos;django.contrib.staticfiles&apos;, &apos;django_comments&apos;, &apos;kobo.django.xmlrpc&apos;, &apos;tinymce&apos;, &apos;tcms.core.contrib.auth.apps.AppConfig&apos;, &apos;tcms.core.contrib.comments.apps.AppConfig&apos;, &apos;tcms.core.contrib.linkreference&apos;, &apos;tcms.core.logs&apos;, &apos;tcms.integration.bugzilla&apos;, &apos;tcms.integration.errata&apos;, &apos;tcms.management&apos;, &apos;tcms.profiles&apos;, &apos;tcms.testcases&apos;, &apos;tcms.testplans&apos;, &apos;tcms.testruns&apos;, &apos;tcms.xmlrpc.apps.AppConfig&apos;, # core app must be here in order to use permissions created during creating # modules for above apps. &apos;tcms.core.apps.AppConfig&apos;,)SESSION_SERIALIZER = &apos;django.contrib.sessions.serializers.JSONSerializer&apos;## Default apps settings## Define the custom comment app# http://docs.djangoproject.com/en/dev/ref/contrib/comments/custom/COMMENTS_APP = &apos;tcms.core.contrib.comments&apos; # &apos;nitrate_comments&apos;## XML-RPC interface settings## XML-RPC methodsXMLRPC_METHODS = &#123; &apos;TCMS_XML_RPC&apos;: ( (&apos;tcms.xmlrpc.api.auth&apos;, &apos;Auth&apos;), (&apos;tcms.xmlrpc.api.build&apos;, &apos;Build&apos;), (&apos;tcms.xmlrpc.api.env&apos;, &apos;Env&apos;), (&apos;tcms.xmlrpc.api.product&apos;, &apos;Product&apos;), (&apos;tcms.xmlrpc.api.testcase&apos;, &apos;TestCase&apos;), (&apos;tcms.xmlrpc.api.testcaserun&apos;, &apos;TestCaseRun&apos;), (&apos;tcms.xmlrpc.api.testcaseplan&apos;, &apos;TestCasePlan&apos;), (&apos;tcms.xmlrpc.api.testopia&apos;, &apos;Testopia&apos;), (&apos;tcms.xmlrpc.api.testplan&apos;, &apos;TestPlan&apos;), (&apos;tcms.xmlrpc.api.testrun&apos;, &apos;TestRun&apos;), (&apos;tcms.xmlrpc.api.user&apos;, &apos;User&apos;), (&apos;tcms.xmlrpc.api.version&apos;, &apos;Version&apos;), (&apos;tcms.xmlrpc.api.tag&apos;, &apos;Tag&apos;), ),&#125;XMLRPC_TEMPLATE = &apos;xmlrpc.html&apos;# Cache backendCACHES = &#123; &apos;default&apos;: &#123; &apos;BACKEND&apos;: &apos;django.core.cache.backends.locmem.LocMemCache&apos;, &#125;&#125;SESSION_ENGINE = &apos;django.contrib.sessions.backends.cached_db&apos;# Needed by django.core.context_processors.debug:# See http://docs.djangoproject.com/en/dev/ref/templates/api/#django-core-context-processors-debugINTERNAL_IPS = (&apos;127.0.0.1&apos;, )# Authentication backends# For the login/register/logout reaon, we only support the internal auth backends.AUTHENTICATION_BACKENDS = ( &apos;tcms.core.contrib.auth.backends.DBModelBackend&apos;,)## Mail settings## Set the default send mail address# See http://docs.djangoproject.com/en/dev/ref/settings/#email-backendEMAIL_HOST = &apos;&apos;EMAIL_PORT = 25EMAIL_FROM = &apos;noreply@foo.com&apos;EMAIL_SUBJECT_PREFIX = &apos;[TCMS] &apos;EMAILS_FOR_DEBUG = []ENABLE_ASYNC_EMAIL = TrueCELERY_BROKER_URL = &apos;redis://&apos;# Celery worker settingsCELERY_TASK_RESULT_EXPIRES = 60 * 2CELERY_RESULT_BACKEND = &apos;db+sqlite:///celery-results.db&apos;CELERYD_TIMER_PRECISION = 120CELERY_IGNORE_RESULT = TrueCELERY_MAX_CACHED_RESULTS = -1CELERY_DEFAULT_RATE_LIMIT = &apos;250/m&apos;# TCMS email behavior settingsPLAN_EMAIL_TEMPLATE = &apos;mail/change_plan.txt&apos;PLAN_DELELE_EMAIL_TEMPLATE = &apos;mail/delete_plan.txt&apos;CASE_EMAIL_TEMPLATE = &apos;mail/edit_case.txt&apos;CASE_DELETE_EMAIL_TEMPLATE = &apos;mail/delete_case.txt&apos;# TCMS Bug System settings# Set default bug system to bugzillaDEFAULT_BUG_SYSTEM_ID = 1# Maximum upload file size, default set to 5MB.# 2.5MB - 2621440# 5MB - 5242880# 10MB - 10485760# 20MB - 20971520# 50MB - 5242880# 100MB 104857600# 250MB - 214958080# 500MB - 429916160MAX_UPLOAD_SIZE = 5242880# PaginationPLAN_RUNS_PAGE_SIZE = 20# Site-specific messages# The site can supply optional &quot;message of the day&quot; style banners, similar to# /etc/motd. They are fragments of HTML.# This if set, is shown on the login/registration screens.# MOTD_LOGIN = &apos;&apos;# The URLS will be list in footer# Example:#FOOTER_LINKS = (# (&apos;mailto:nitrate-dev-list@example.com&apos;, &apos;Contact Us&apos;),# (&apos;mailto:nitrate-admin@example.com&apos;, &apos;Request Permission&apos;),# (&apos;http://foo.com&apos;, &apos;foo&apos;)#)FOOTER_LINKS = ()# Attachement file download path# it could be spcified to a different out of MEDIA_URL# FILE_UPLOAD_DIR = path.join(MEDIA_DIR, &apos;uploads&apos;).replace(&apos;\\&apos;,&apos;/&apos;),FILE_UPLOAD_DIR = &apos;/var/nitrate/uploads&apos;# Enable the administrator delete permission# In another word it&apos;s set the admin to super user or not.SET_ADMIN_AS_SUPERUSER = False## Authentication backend settings## Bugzilla author xmlrpc url# Required by bugzilla authentication backendBUGZILLA3_RPC_SERVER = &apos;&apos;BUGZILLA_URL = &apos;&apos;# JIRA URLJIRA_URL = &apos;&apos;# Turn on/off bugzilla external trackerBUGZILLA_EXTERNAL_TRACKER = False# Turn on/off listening signals sent by models.LISTENING_MODEL_SIGNAL = True# Kerberos settings# Required by kerberos authentication backendKRB5_REALM = &apos;&apos;# Integration with Errata system, used to linkify the Errata ID# A valid Errata URL:# https://errata.devel.example.com/errata/stateview/&#123;Errata ID&#125;ERRATA_URL_PREFIX = &apos;&apos;# user guide url:USER_GUIDE_URL = &apos;&apos;# Default page size for showing each possible query result. This provides a# consistent user experiece to users.DEFAULT_PAGE_SIZE = 20# Disable TCMS to produce test run progress info to consumers by qpid for# reducing unnecessary I/O access and errata does not subscribe tcms msg now.# If you want to continue sending msg to qpid, please overwrite it in product# .py and make sure qpid config is correct.ENABLE_QPID = False# TCMS use Piwik to track request.ENABLE_PIWIK_TRACKING = False# Piwik site id, generate by eng-opsPIWIK_SITE_ID = &apos;&apos;# Piwik api url without schema.PIWIK_SITE_API_URL = &apos;&apos;# Piwik js lib url without schemaPIWIK_SITE_JS_URL = &apos;&apos;# A sample logging configuration. The only tangible logging# performed by this configuration is to send an email to# the site admins on every HTTP 500 error when DEBUG=False.# See http://docs.djangoproject.com/en/dev/topics/logging for# more details on how to customize your logging configuration.LOGGING = &#123; &apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;formatters&apos;: &#123; &apos;verbose&apos;: &#123; &apos;format&apos;: &apos;%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s&apos; &#125;, &apos;simple&apos;: &#123; &apos;format&apos;: &apos;[%(asctime)s] %(levelname)s %(message)s&apos; &#125;, &apos;xmlrpc_log&apos;: &#123; &apos;format&apos;: &apos;[%(asctime)s] %(levelname)s XMLRPC %(process)d &quot;%(message)s&quot;&apos; &#125;, &#125;, &apos;filters&apos;: &#123; &apos;require_debug_false&apos;: &#123; &apos;()&apos;: &apos;django.utils.log.RequireDebugFalse&apos; &#125; &#125;, &apos;handlers&apos;: &#123; &apos;console&apos;: &#123; &apos;level&apos;: &apos;DEBUG&apos;, &apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;formatter&apos;: &apos;simple&apos; &#125;, &apos;xmlrpc&apos;: &#123; &apos;level&apos;: &apos;DEBUG&apos;, &apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;formatter&apos;: &apos;xmlrpc_log&apos;, &#125;, &apos;mail_admins&apos;: &#123; &apos;level&apos;: &apos;ERROR&apos;, &apos;filters&apos;: [&apos;require_debug_false&apos;], &apos;class&apos;: &apos;django.utils.log.AdminEmailHandler&apos; &#125;, &#125;, &apos;loggers&apos;: &#123; &apos;django.request&apos;: &#123; &apos;handlers&apos;: [&apos;mail_admins&apos;], &apos;level&apos;: &apos;ERROR&apos;, &apos;propagate&apos;: True, &#125;, &apos;nitrate.xmlrpc&apos;: &#123; &apos;handlers&apos;: [&apos;xmlrpc&apos;], &apos;level&apos;: &apos;DEBUG&apos;, &apos;propagate&apos;: True, &#125;, &#125;&#125;TINYMCE_DEFAULT_CONFIG = &#123; &apos;mode&apos;: &quot;exact&quot;, &apos;theme&apos;: &quot;advanced&quot;, &apos;language&apos;: &quot;en&quot;, &apos;skin&apos;: &quot;o2k7&quot;, &apos;browsers&apos;: &quot;gecko&quot;, &apos;dialog_type&apos;: &quot;modal&quot;, &apos;object_resizing&apos;: &apos;true&apos;, &apos;cleanup_on_startup&apos;: &apos;true&apos;, &apos;forced_root_block&apos;: &quot;p&quot;, &apos;remove_trailing_nbsp&apos;: &apos;true&apos;, &apos;theme_advanced_toolbar_location&apos;: &quot;top&quot;, &apos;theme_advanced_toolbar_align&apos;: &quot;left&quot;, &apos;theme_advanced_statusbar_location&apos;: &quot;none&quot;, &apos;theme_advanced_buttons1&apos;: &quot;formatselect,&quot; &quot;bold,italic,&quot; &quot;underline,&quot; &quot;bullist,&quot; &quot;numlist,&quot; &quot;link,&quot; &quot;unlink,&quot; &quot;image,&quot; &quot;search,&quot; &quot;|,&quot; &quot;outdent,&quot; &quot;indent,&quot; &quot;hr,&quot; &quot;fullscreen,&quot; &quot;|,&quot; &quot;help&quot;, &apos;theme_advanced_buttons2&apos;: &quot;tablecontrols&quot;, &apos;theme_advanced_buttons3&apos;: &quot;&quot;, &apos;theme_advanced_path&apos;: &apos;false&apos;, &apos;theme_advanced_blockformats&apos;: &quot;p,h2,h3,h4,div,code,pre&quot;, &apos;theme_advanced_styles&apos;: &quot;[all] clearfix=clearfix;&quot; &quot;[p] summary=summary;&quot; &quot;[div] code=code;&quot; &quot;[img] img_left=img_left;&quot; &quot;[img] img_left_nospacetop=img_left_nospacetop;&quot; &quot;[img] img_right=img_right;&quot; &quot;[img] img_right_nospacetop=img_right_nospacetop;&quot; &quot;[img] img_block=img_block;&quot; &quot;[img] img_block_nospacetop=img_block_nospacetop;&quot; &quot;[div] column span-2=column span-2;&quot; &quot;[div] column span-4=column span-4;&quot; &quot;[div] column span-8=column span-8&quot;, &apos;height&apos;: &apos;300&apos;, &apos;width&apos;: &apos;100%&apos;, &apos;urlconverter_callback&apos;: &apos;myCustomURLConverter&apos;, &apos;plugins&apos;: &quot;table,safari,&quot; &quot;advimage,&quot; &quot;advlink,&quot; &quot;fullscreen,&quot; &quot;visualchars,&quot; &quot;paste,&quot; &quot;media,&quot; &quot;template,&quot; &quot;searchreplace,&quot; &quot;emotions,&quot;, &apos;table_styles&apos;: &quot;Header 1=header1;&quot; &quot;Header 2=header2;&quot; &quot;Header 3=header3&quot;, &apos;table_cell_styles&apos;: &quot;Header 1=header1;&quot; &quot;Header 2=header2;&quot; &quot;Header 3=header3;&quot; &quot;Table Cell=tableCel1&quot;, &apos;table_row_styles&apos;: &quot;Header 1=header1;&quot; &quot;Header 2=header2;&quot; &quot;Header 3=header3;&quot; &quot;Table Row=tableRow1&quot;,&#125;LOCALE_PATHS = ( os.path.join(TCMS_ROOT_PATH, &apos;locale&apos;),)TESTOPIA_XML_VERSION = &apos;1.1&apos; 需要注意的： 检查INSTALLED_APPS中，是否有django.contrib.staticfiles，很重要！ DEBUG开关 数据库配置 STATIC_ROOT,STATIC_URL,STATICFILES_DIRS，这三个，真的真的很重要！并且很容易就出问题，看我注释了那么多行就知道我是试了多少种组合了 前三条没什么可说的，关键就是第四条，先贴出个第三个坑:1django.core.exceptions.ImproperlyConfigured: The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting 这个是在进行数据初始化时候报的错，问题很好看，字面意思就是，然后我就开始各种尝试配置STATIC_ROOT和STATICFILES_DIRS，首先先解释一下这个配置的作用，首先，配置的是路径，文件夹的路径，作用就是存放静态文件，各种js,css等，在你页面加载的静态文件，都在这个文件夹里。在Django项目进行部署时：1python manage.py collectstatic 命令就会把所有需要的静态文件都复制到你配置的STATIC_ROOT文件夹中。所以STATIC_ROOT配置的是你app级的静态文件保存地址。那么STATICFILES_DIRS呢，这个文件夹，可以看成是所有app公共的静态文件的保存地址，当需要加载静态文件时，django会首先在公共的文件中查找，然后去app级的文件夹查找。至于STATIC_URL这个配置其实就是为了映射STATIC_ROOT，值基本配STATIC_URL = &#39;/static/&#39;即可。 开启服务首先是初始化数据：1django-admin.py migrate --settings=tcms.settings.product 将Nitrate一些必须的数据，表初始化；然后是加载静态文件：1django-admin.py collectstatic --settings=tcms.settings.product 根据你指定的配置，将静态文件拷贝到指定文件夹；然后是创建超级管理员：1django-admin.py createsuperuser --settings=tcms.settings.product 最后，起服务：1django-admin.py runserver --settings=tcms.settings.product 到浏览器上http://127.0.0.1:8000开始折腾吧~~~ 几个问题debug-toolbar当打开DEBUG，在进行初始化时，可能会报错：1no module named debug-toolbar 很明显，缺包，装包，不过包名不叫debug-toolbar,1yum install django-debug-toolbar 即可。 django.core.exceptions.ImproperlyConfigured: The STATICFILES_DIRS setting should not contain the STATIC_ROOT setting也是字面意思，STATIC_ROOT配置不能包含在STATICFILES_DIRS中，为什么会遇到这个问题，这玩意是我在第一次起服务没报错，但是页面静态文件一个都获取不到，整个页面朴素的不像话时候，尝试解决引发的另一个问题。先说说页面元素不加载，当初我配置是看网上有介绍STATICFILES_DIRS可以注释，不需要配，然后我就把STATIC_ROOT配成公共文件地址，结果在页面打开Nitrate时候，所有静态文件都是类似于：1&quot;GET /static/media/css/bootstrap/bootstrap.css HTTP/1.1&quot; 404 5904 这样的问题，整个页面就朴素的不行。。。然后又尝试把STATIC_ROOT注释，这次报的是代码中指明了app配置，STATIC_ROOT该项不能少这样的报错；然后两个都保留，这次就出现了上面那个错；再一次，在没看setting.py文件前，把STATIC_ROOT设置成了公共的，STATICFILES_DIRS设置成了app的，一如既往，静态文件全部加载不出来。。最后才修改成上述配置文件样（试过的组合不止这些，反正是折腾死，还怀疑过是copy静态文件时，少拷了个文件，都想改源码了，唉。。。）所以这个问题解决很简单，把STATIC_ROOT设置成了app的，STATICFILES_DIRS设置成了公共的。 DATABASES is improperly configured. Please supply the ENGINE value这个报错遇到过好几个，基本是俩原因： 改配置文件，输错了 nitrate用户没有权限检查的改了即可。 后记周五下午在公司没有搭建成功，搭的都心累了，成果就是一及其朴素的页面；周天早上6点钟开始折腾，一直弄到下午，才完完整整的搭完，唉，真的是个充实的周末…目前环境是搭建在虚拟机中，访问也是只能虚拟机中的Firefox输入http://127.0.0.1:8000才能访问，后面需要结合appach和wsgi，至少是完成公司局域网内访问，这个应该挺简单，再弄。。。 参考文档 Collecting staticfiles throws ImproperlyConfigured Managing static filesDjango 使用 Bootstrap，在 DEBUG = True 模式下，部分 js、css 提示 404 错误settings.py中的静态文件管理设置django中的setting最佳配置小结 ============================================================================================================================================================================================来更新接下来的部署了！ 使用apache&amp;mod_wsgi部署django项目 使用apache和mod_wsgi来部署Nitrate，使得不需要一直在虚拟机里面的浏览器才能打开Nitrate。 安装httpd&amp;mod_wsgi1yum install httpd mod_wsgi 创建上传文件夹创建长传文件夹，并且修改用户及属组：12mkdir -p /var/nitrate/uploadschown apache:apache /var/nitrate/uploads 配置mod_wsgi在/etc/httpd/conf.d文件夹下，创建文件wsgi.conf，修改内容：1LoadModule wsgi_module modules/mod_wsgi.so 配置Apache&amp;mod_wsgi在/etc/httpd/conf.d文件夹下创建nitrate的配置文件nitrate-httpd.conf，具体内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# Deployment using mod_wsgi## Useful documentation:# https://docs.djangoproject.com/en/1.5/howto/deployment/wsgi/# Force the use of ssl:#&lt;IfModule mod_rewrite.c&gt;# RewriteEngine on# RewriteCond %&#123;HTTPS&#125; off# RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125;#&lt;/IfModule&gt;# Make sure static files collected to this dir# Ref https://docs.djangoproject.com/en/1.5/ref/contrib/staticfiles/#django-admin-collectstatic#Alias /static /usr/share/nitrate/staticiAlias /static /home/nitrate/projects/site/assets#Alias /usr/lib/python2.7/site-packages/Nitrate-4.1-py2.7.egg/tcms/static# Limit threads forked:# prefork MPM StartServers 5MinSpareServers 5MaxSpareServers 10MaxClients 256MaxRequestsPerChild 0# Configurations for mod_wsgiWSGIScriptAlias / /usr/lib/python2.7/site-packages/tcms/wsgi.pyWSGIPythonPath /usr/lib/python2.7/site-packagesWSGIPassAuthorization On&lt;Location &quot;/&quot;&gt; # ==================== # Handler for mod_wsgi # ==================== SetHandler wsgi-script Options All AllowOverride All Require all granted LimitRequestBody 10485760 AddOutputFilterByType DEFLATE text/html text/plain text/xml text/javascript application/x-javascript text/css ErrorDocument 401 &quot;Your request is unauthorization.&quot;&lt;/Location&gt;&lt;Location &quot;/static&quot;&gt; SetHandler None # Disable auth on the static content, so that we&apos;re aren&apos;t forced to # use Kerberos. Doing so would remove &quot;Expires&quot; headers from the static # content, which would lead to poor page-load times. AuthType none Satisfy Any Allow from All # Many file types are likely to benefit from compression # Enable gzip compression on them: AddOutputFilterByType DEFLATE text/html text/plain text/xml text/javascript application/x-javascript text/css # Set far-future Expires headers on static content # (trac 184): ExpiresActive On ExpiresDefault &quot;access plus 10 years&quot;&lt;/Location&gt; 需要注意的几个配置：123Alias /static /home/nitrate/projects/site/assetsWSGIScriptAlias / /usr/lib/python2.7/site-packages/tcms/wsgi.pyWSGIPythonPath /usr/lib/python2.7/site-packages 都修改成你自己的本地路径 httpd.conf说实话，我对这玩意是真的不熟悉，就基本没改，路径：/etc/httpd/conf/httpd.conf，只需要修改：12ServerName example.com:80Listen ip_address:80 我比较懒，直接一个改成localhost，另一个改为80，就完工了。然后就可以起服务了！！！1systemctl start httpd.service 在本地windows下的浏览器应该就可以直接访问虚拟机的ip来访问nitrate了 可能遇到的问题反正对我来说不是可能，全遇到了。。 httpd服务启动失败这个问题，原因很多，直接看日志比较正常，我是因为端口配错了才出现 页面报错，无法连接mysql，报权限问题首先，检查是否有权限，在确定有权限情况下，基本是系统的问题了。解释一下，虚拟机装的是centos，centos在默认情况下SELinux是打开的，这玩意，是不允许远程连接MySQL资源的。。。所以简单的解决：1setenforce 0 网上有个建议做法：1setsebool httpd_can_network_connect_db 1 允许Apache访问外部MySQL资源 浏览器访问虚拟机IP，静态文件不加载和之前碰到的配路径一样，所有静态文件加载都是403，加载不了，这次，确定不是路径配置的问题，那就是权限问题呗，给你/static目录下的文件赋权限，有可执行权限即可。1chmod -R 755 /static]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Nitrate</tag>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下升级python2.7到3.6]]></title>
    <url>%2F2018%2F04%2F20%2FCentos%E4%B8%8B%E5%8D%87%E7%BA%A7python2-7%E5%88%B03-6%2F</url>
    <content type="text"><![CDATA[Centos下，修改python版本，保留原2.7.5版本同时，更改默认版本为3.6 保留原版本由于yum中会配置python版本，在进行python版本更新时，需要先将yum的配置文件都更改了。首先，切用户1su - root 1mv /usr/bin/python2.7 /usr/bin/python2.7.5 # 保留默认版本python为python2.7.5 1ln -s /usr/bin/python2.7.5 /usr/local/bin/python2.7.5 # 创建软连接 1ls -al /usr/bin/yum* # 查看/usr/bin/目录下所有yum文件，共7个 一个一个改：1#!/usr/bin/python —&gt; #!/usr/bin/python2.7.5 12vi /usr/libexec/urlgrabber-ext-down # 修改/usr/libexec/目录下 urlgrabber-ext-down#!/usr/bin/python —&gt; #!/usr/bin/python2.7.5 安装python3.6安装配置环境wget首先检查是否有安装wget，没有则需要安装：1yum install wget 准备编译环境12yum groupinstall &apos;Development Tools&apos;yum install zlib-devel bzip2-devel openssl-devel ncurses-devel 开始安装123456789101112131415161718192021222324wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgztar zxvf Python-3.6.2.tgzcd Python-3.6.2./configuremake allmake installmake cleanmake distcleanrm -rf /usr/bin/pythonrm -rf /usr/bin/python3rm -rf /usr/bin/python3.6ln -s /usr/local/bin/python3.6 /usr/bin/pythonln -s /usr/local/bin/python3.6 /usr/bin/python3ln -s /usr/local/bin/python3.6 /usr/bin/python3.6/usr/bin/python -V/usr/bin/python3 -V/usr/bin/python3.6 -Vrm -rf /usr/local/bin/pythonrm -rf /usr/local/bin/python3ln -s /usr/local/bin/python3.6 /usr/local/bin/pythonln -s /usr/local/bin/python3.6 /usr/local/bin/python3python -Vpython3 -Vpython3.6 -V 123456[root@localhost Python-3.6.2]# python -VPython 3.6.2[root@localhost Python-3.6.2]# python3 -VPython 3.6.2[root@localhost Python-3.6.2]# python3.6 -VPython 3.6.2 安装成功~ 参考链接]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切换163yum源]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%88%87%E6%8D%A2163yum%E6%BA%90%2F</url>
    <content type="text"><![CDATA[来篇福利文 经常装环境的应该遇过下包基本没动静，基于这“伟大”的互联网环境，下包真的是很心累的一件事，好在国内有志之士还是弄了很多福利的，下面：Centos切换国内163yum源 前言前提条件，linux服务器支持wget，没有则装一个：1yum install -y wget 装好之后，开始切换yum源。 备份首先，搭环境的必要素质，修改配置文件之前，一定要先备份！（踩了n多坑的教训）1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载163源切换到/etc/yum.repos.d，wget下载163源配置文件1wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 改名修改下载完成的文件的名称1mv /etc/yum.repos.d/CentOS6-Base-163.repo /etc/yum.repos.d/CentOS-Base.rep 生成缓存12yum clean allyum makecache 完工~~~]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之SQL优化系列（三）]]></title>
    <url>%2F2018%2F04%2F18%2FMySQL%E4%B9%8BSQL%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL精准分析执行时间 当进行sql性能瓶颈分析时，第一反应肯定是查看sql执行时间，那么当使用慢查询日志，以及explain都无法知晓具体信息时，怎么分析。 Query ProfilerQuery Profiler是MYSQL自带的一种query诊断分析工具，通过它可以分析出一条SQL语句的性能瓶颈在什么地方。通过show variables like &quot;%pro%&quot;;可以查看该工具是否开启：1234567891011121314151617mysql&gt; show variables like &quot;%pro%&quot;;+------------------------------------------+-------+| Variable_name | Value |+------------------------------------------+-------+| check_proxy_users | OFF || have_profiling | YES || mysql_native_password_proxy_users | OFF || performance_schema_max_program_instances | -1 || profiling | OFF || profiling_history_size | 15 || protocol_version | 10 || proxy_user | || sha256_password_proxy_users | OFF || slave_compressed_protocol | OFF || stored_program_cache | 256 |+------------------------------------------+-------+11 rows in set, 1 warning (0.00 sec) 发现当前为关闭状态，手动开启：12mysql&gt; set profiling = 1;Query OK, 0 rows affected, 1 warning (0.00 sec) 使用首先执行几条sql，作为分析样本：1234567mysql&gt; select sleep(3);+----------+| sleep(3) |+----------+| 0 |+----------+1 row in set (3.00 sec) 1234567mysql&gt; select 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec) 查看执行情况：123456789mysql&gt; show profiles;+----------+------------+-----------------------------+| Query_ID | Duration | Query |+----------+------------+-----------------------------+| 1 | 0.00325925 | show variables like &quot;%pro%&quot; || 2 | 2.99971075 | select sleep(3) || 3 | 0.00051050 | select 1 |+----------+------------+-----------------------------+3 rows in set, 1 warning (0.00 sec) 可以看出具体执行时间，若想查看具体那一条SQL的具体信息：123456789101112131415161718mysql&gt; show profile for query 2; +----------------------+----------+ | Status | Duration | +----------------------+----------+ | starting | 0.000103 | | checking permissions | 0.000008 | | Opening tables | 0.000006 | | init | 0.000016 | | optimizing | 0.000008 | | executing | 0.000018 | | User sleep | 2.999385 | | end | 0.000016 | | query end | 0.000009 | | closing tables | 0.000005 | | freeing items | 0.000115 | | cleaning up | 0.000023 | +----------------------+----------+ 12 rows in set, 1 warning (0.00 sec) 对系统分析查看执行sql中对系统的影响，例如，查看磁盘IO：123456789101112131415161718mysql&gt; show profile block io for query 2;+----------------------+----------+--------------+---------------+| Status | Duration | Block_ops_in | Block_ops_out |+----------------------+----------+--------------+---------------+| starting | 0.000103 | NULL | NULL || checking permissions | 0.000008 | NULL | NULL || Opening tables | 0.000006 | NULL | NULL || init | 0.000016 | NULL | NULL || optimizing | 0.000008 | NULL | NULL || executing | 0.000018 | NULL | NULL || User sleep | 2.999385 | NULL | NULL || end | 0.000016 | NULL | NULL || query end | 0.000009 | NULL | NULL || closing tables | 0.000005 | NULL | NULL || freeing items | 0.000115 | NULL | NULL || cleaning up | 0.000023 | NULL | NULL |+----------------------+----------+--------------+---------------+12 rows in set, 1 warning (0.00 sec) 可以完整的看出select sleep(3);该sql执行过程中对磁盘IO的影响。类似的还有：12345mysql&gt; show profile cpu for query 2;mysql&gt; show profile memory for query 2;mysql&gt; show profile swaps for query 2;mysql&gt; show profile context switches for query 2;mysql&gt; show profile all for query 2;]]></content>
      <categories>
        <category>MySQL-SQL优化</category>
      </categories>
      <tags>
        <tag>profiler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loadruner日常总结]]></title>
    <url>%2F2018%2F04%2F18%2Floadruner%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[日常工作中遇到的loadrunner的相关问题的总结： 前言首先，使用的环境（版本）：123WIN7 企业版 Service Pack1loadrunner 12.50IE 11 环境说明本来用习惯了，到了新公司第一件事就是装了WIN10，loadrunner版本使用的也是loadrunner 12.50，然后，开始工作，录制脚本时候，开始了各种神坑问题，对了，先说一句，笔记本是Thinkpad T430（不是win 10系统的锅）。录制时候就开始了坑死人的经历，第一个是基本相当于不支持chrome，想用chrome录制，必须开代理或者fiddle，简直是愁；换成firefox，浏览器都打不开，用IE，各种的需要安全证书，或者就是压根浏览器直接未响应。好不容易开着代理，用chrome录制好了，回放，70%的概率电脑会蓝屏，无语至极。 艰难的环境搭建没办法，日常工作现在就是在性能测试上，只好放弃win10，转用win7了（再次再次提醒，T430千万别用win10来搭配loadrunner！！！）再次重装系统，这次用了什么鬼纯净版，也就是ghost版，是人为在官方原本基础上的优化版，唉，装是装好了，事又来了，众所周知，loadrunner和浏览器的兼容实在是个很深的坑尤其是64位的windows系统，更是能选用的很少。试了各种chrome，firefox，ie甚至什么遨游，世界之窗，基本是快奔溃的状态。实验半天，基本兼容性是:1IE &gt; firefox &gt; chrome IE最好，firefox网上基本是建议用25左右的版本，但是，没有64位的啊。。。chrome就别提了，老样子，要么是要开代理，要么是直接打开浏览器就未响应。所以，首选还是IE啊，但是，试了下，公司的测试网站，在IE8上压根就打不开（win7自带是IE8），版本太低了！必须要升级到IE11，升级是简单，找到windows update搜索下载，下载完更新即可，安装完成需要重启系统，然后坑来了：ghost版装的系统，直接帮你“优化了”权限，基本你是默认就是管理员，然后在安装windows更新时候，问题就来了，系统会在判断你权限时候，发现权限混乱，直接更新失败，返回还原点，windows——update failure，error code：80070005，唉，简直是半疯。在实验了其他n中手动更新IE的方法失败之后，只能放弃。直接上MSDN下载官方镜像，重新安装系统，这次终于是成功将IE8更新到IE11了。 常见问题CV证书在录制时候，经常会遇到不适用loadrunner录制，网页可以打开，使用loadrunner录制，网页打开显示“无法此页”；可能在浏览器显示该页面之前，已经弹出了一个类似该网站CV证书。。。的弹窗提示，意思很明显，该测试网站，在你的浏览器安全证书中没有它的证书，所以浏览器的安全策略就过滤了该浏览器的连接，页面就打不开了。 解决办法在录制时候：点击Recoding Oftions，在Network栏，点击Mapping and Filtering，Port mapping选择WinINet level data，点击确定，录制即可。 loadrunner未响应该问题，网上有很多解答，基本第一条就是1IE - Internet选项 - 高级 - 启用第三方软件扩展（取消勾选） 然后，我是直接用管理员登录的系统，再进行录制就可以了。附上网上有个很全的回答：loadrunner点击录制不响应 请求接口HTTP CODE 500在排除接口异常，使用其他如postman，soupui等工具直接请求可以成功返回数据情况下，查看使用loadrunner录制的脚本，是否在传参的时候将参数进行格式化，以JSON格式传参，我是遇到过很多次，直接使用loadrunner录制脚本，录制出来的脚本中缺少格式化:1&quot;EncType=application/json; charset=utf-8&quot;, 录制出来的脚本类似：12345678910web_custom_request(&quot;2018_1&quot;, &quot;URL=https://www.test.com/api/config/calendar/1/2018&quot;, &quot;Method=PUT&quot;, &quot;Resource=0&quot;, &quot;RecContentType=application/json&quot;, &quot;Referer=https://www.test.com/app&quot;, &quot;Snapshot=t16.inf&quot;, &quot;Mode=HTML&quot;, &quot;Body=&#123;\&quot;2018-11-01\&quot;:1&#125;&quot;, LAST); 这样请求，即使加上所有token，很可能还是会500，所以手工加上一句格式化json的即可。 后记loadrunner作为付费软件，限制其实还是挺多的，日常生活中遇到什么问题，还需要继续记录。P.S 做性能测试，真的是，能用Jmeter或者locust，真的，就转吧。。。破解个限制这么多的，实在是，唉。。。]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>loadrunner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOs7强制修改MySQL中root密码]]></title>
    <url>%2F2018%2F04%2F04%2FCentOs7%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9MySQL%E4%B8%ADroot%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[centos7强制修改MySQL默认密码 前言最近需要搭建zabbix，需要在centos7上搭建MySQL服务器；这个很简单，直接命令：获取MySQL源：1sudo rpm -Uvh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm 安装：1sudo yum install mysql-* --skip-broken 问题安装过程，由于公司网简直惨不忍睹，中间一度断掉了，都不知道哪边安装出错了。。。好不容易看着安装成功之后，查找默认的root密码：1grep &apos;temporary password&apos; /var/log/mysqld.log 然后就悲剧了，这个日志文件，压根就是空的，root密码跑哪玩去了！！！然后试了试，貌似好像可以起服务。。见鬼12systemctl start mysqldsystemctl status mysqld 不过这样还是进不了控制台啊，没密码啊，没办法，只有强制修改root密码。 强制修改密码首先强制修改配置文件，/etc/my.cnf添加：12[mysqld]skip-grant-tables=1 添加skip-grant-tables=1这行，然后重启MySQL服务。1systemctl restart mysqld 修改密码进入MySQL控制台：1mysql 打印：12345678910111213Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.21 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 修改密码123use mysql;update user set authentication_string = password(&quot;xxxx&quot;) where user=&quot;root&quot;;flush privileges; 然后将/etc/my.cnf下skip-grant-tables=1注释掉，重启MySQL服务。 后续使用修改完成的root密码登录MySQL控制台之后，可以进入控制台：123456789101112131415mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.21Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 但是有问题：12mysql&gt; show databases;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 按照提示，我们在修改root密码时候，应该使用的是alter而不是update来更新密码，所以，重新修改密码:12alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;QWEqwe+342&apos;;flush privileges; 再次重启服务即可。]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum安装软件失败]]></title>
    <url>%2F2018%2F04%2F04%2Fyum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[centos运行yum报错解决办法 问题使用yum安装软件时，报错：12345Another app is currently holding the yum lock; waiting for it to exit... The other application is: PackageKit Memory : 130 M RSS (1.0 GB VSZ) Started: Wed Apr 4 10:44:50 2018 - 04:01 ago State : Sleeping, pid: 11199 解决该问题可能是由于系统目前处于自动升级状态，所以锁定了yum，只要强制关闭yum进程即可重新运行yum1rm -rf /var/run/yum.pid 优质yum源Remi repository 是包含最新版本 PHP 和 MySQL 包的 Linux 源，由 Remi 提供维护。有个这个源之后，使用 YUM 安装或更新 PHP、MySQL、phpMyAdmin 等服务器相关程序的时候就非常方便了。 12345wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmwget http://rpms.remirepo.net/enterprise/remi-release-7.rpmrpm -Uvh remi-release-7.rpm epel-release-latest-7.noarch.rpm# for RHEL onlysubscription-manager repos --enable=rhel-7-server-optional-rpms 参考文章]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos7</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之SQL优化系列（二）]]></title>
    <url>%2F2018%2F04%2F03%2FMySQL%E4%B9%8BSQL%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过explain分析低效SQL的执行计划 序言使用的数据库依然是mysql示例库sakila接着上篇的MySQL之SQL优化系列（一）当通过慢查询日志定位到执行效率较低的SQL之后，使用explain进行低效SQL的分析。 使用EXPLAIN分析低效SQL的执行计划使用EXPLAIN可以获取MySQL是如何执行SELECT语句的，包括在SELECT语句执行过程中表如何连接以及连接的顺序，如下示例SQL执行：12345678910111213141516171819202122232425262728mysql&gt; explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id = b.customer_id and email=&apos;JANE.BENNETT@sakilacustomer.org&apos;\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: a partitions: NULL type: ALLpossible_keys: PRIMARY key: NULL key_len: NULL ref: NULL rows: 599 filtered: 10.00 Extra: Using where*************************** 2. row *************************** id: 1 select_type: SIMPLE table: b partitions: NULL type: ref possible_keys: idx_fk_customer_id key: idx_fk_customer_id key_len: 2 ref: sakila.a.customer_id rows: 26 filtered: 100.00 Extra: NULL 2 rows in set, 1 warning (0.01 sec) 字段解释： select_type:表示select的类型，常见取值有SIMPLE(简单表，不使用表连接或子查询)、PRIMARY(主查询，外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(子查询中的第一个SELECT) table:输出结果集的表 type:表示MySQL在表中找到所需行的方法，或者称为访问类型，常见的有：1ALL —— index —— range —— ref —— eq_ref —— const,system —— NULL 从做到右，性能由最差到最好。示例： type=ALL，全表扫描，MySQL遍历全表来找到匹配行：123456789101112131415mysql&gt; explain select * from film limit 1\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: film partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1000 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 2.type=index，索引全扫描，MySQL遍历整个索引来查询匹配的行：1mysql&gt; show index from film; 获取得到film表的索引：film_id(主键),title,language_id,original_language_id123456789101112131415mysql&gt; explain select title from film\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: film partitions: NULL type: index possible_keys: NULL key: idx_title key_len: 767 ref: NULL rows: 1000 filtered: 100.00 Extra: Using index 1 row in set, 1 warning (0.00 sec) 3.type=range,索引范围扫描，常见的有between,&gt;,&lt;等。4.type=ref，使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配单独值得记录行，例如：123456789101112131415mysql&gt; explain select * from payment where customer_id=24\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: payment partitions: NULL type: ref possible_keys: idx_fk_customer_id key: idx_fk_customer_id key_len: 2 ref: const rows: 25 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 索引idx_fk_customer_id是非唯一索引，查询条件为等值查询条件customer_id=24，所以扫描索引的类型为ref。ref还经常出现在join操作中。5.type=eq_ref，类似ref，区别在于使用的索引是唯一索引，对于每一个索引的键值，表中只有一条记录匹配。换句换说，就是在进行多表连接时，使用得失primary key或者unique index作为关联条件。12345678910111213141516171819202122232425262728mysql&gt; explain select * from film a,film_text b where a.film_id = b.film_id\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: b partitions: NULL type: ALL possible_keys: PRIMARY key: NULL key_len: NULL ref: NULL rows: 1000 filtered: 100.00 Extra: NULL *************************** 2. row *************************** id: 1 select_type: SIMPLE table: a partitions: NULL type: eq_ref possible_keys: PRIMARY key: PRIMARY key_len: 2 ref: sakila.b.film_id rows: 1 filtered: 100.00 Extra: Using where 2 rows in set, 1 warning (0.00 sec) 6.type=const/system，表单中有最多一个匹配行，查询起来非常迅速，所以这个匹配行中的其他列的值可以被优化器在当前查询中当做常量来处理，例如，根据主键primary key或者唯一索引unique index进行的查询。12345678910111213141516alter table customer add unique index uk_email(email);mysql&gt; explain select * from (select * from customer where email=&apos;LINDA.WILLIAMS@sakilacustomer.org&apos;) a\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: customer partitions: NULL type: const possible_keys: uk_email key: uk_email key_len: 153 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) 通过唯一索引uk_email访问的时候，类型type为const。 possible_keys：表示查询时可能使用的索引 key：表示实际使用的索引 key_len：使用到索引字段的长度、 rows：扫描行的数量 Extra：执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息。]]></content>
      <categories>
        <category>MySQL-SQL优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>explain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python性能测试框架locust（一）]]></title>
    <url>%2F2018%2F03%2F30%2Fpython%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6locust%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基于python的性能测试框架LOCUST系列一 简介首先，这个框架是做性能测试的，然后，基于python编写！！！所以，不可能不研究研究啊。LOCUST英文意思是“蝗虫”，感受感受使用locust进行性能测试，并发请求就像铺天盖地的蝗虫一样攻击你的系统，嗯，想想都可怕。 在Locust测试框架中，测试场景是由纯python脚本编写，对于http以及https协议，可以使用python的requests库作为客户端。对于其他协议，locust也提供有接口。也就是说，只要我们使用python编写对应的请求，就能方便的用locust进行压力测试。 安装安装locust很简单，日常操作：1pip install locustio demo示例官方demo：12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle shi@time: 2018/3/30/030 16:59&quot;&quot;&quot;from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet): def on_start(self): &quot;&quot;&quot; on_start is called when a Locust start before any task is scheduled &quot;&quot;&quot; self.login() def login(self): self.client.post(&quot;/login&quot;, &#123;&quot;username&quot;: &quot;ellen_key&quot;, &quot;password&quot;: &quot;education&quot;&#125;) @task(2) def index(self): self.client.get(&quot;/&quot;) @task(1) def profile(self): self.client.get(&quot;/profile&quot;)class WebsiteUser(HttpLocust): task_set = UserBehavior host = &apos;http://example.com&apos; min_wait = 5000 max_wait = 9000 cmd进入该文件所在路径下，执行locust命令，即可开启locust web服务，默认端口808912345678E:\py_workspace\LocustTest\codings\TestScripts &#123;git&#125;&#123;lamb&#125; ls__init__.py __pycache__ locustfile.pyE:\py_workspace\LocustTest\codings\TestScripts &#123;git&#125;&#123;lamb&#125; locust[2018-03-30 17:22:44,919] 3HET0MVY93LITXF/INFO/locust.main: Starting web monitor at *:8089[2018-03-30 17:22:44,920] 3HET0MVY93LITXF/INFO/locust.main: Starting Locust 0.8.1 打开浏览器，输入url:http://localhost:8089即可访问locust web。 tips：使用locust打开服务前提是脚本名称是locustfile.py；否则需要执行指定脚本的命令：locust -f mylocustFile.py -P 7070指定文件和端口 demo简单分析官方的demo对于http://example.com进行压测，随机访问首页（/）以及页面（/profile）比例为2:1，每次请求间隔为5~9s。 后记locust现在还是刚刚开始接触，看着官方介绍的，功能相当齐全，尤其是我还是一个只有python编码能力的菜鸡。。。太对胃口了。。。好好研究！ 官网]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Locust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[loadrunner监控Mysql]]></title>
    <url>%2F2018%2F03%2F30%2Floadrunner%E7%9B%91%E6%8E%A7Mysql%2F</url>
    <content type="text"><![CDATA[使用loadrunner监控mysql 前言最近工作需要研究怎么深度性能测试，使用的工具基本是loadrunner，jmeter或者基于python的框架locust。近期一段时间应该和lr打交道会比较多，lr最为一个收费的专业性能测试软件，功能是毋庸置疑的相当强大，但是，貌似我没有找到监控mysql的模块。。sql server倒是有，也可能是我远离lr太长时间了。 mysql性能监控在日常性能测试过程中，除了需要对系统TPS，RT这样的参数进行监控以及各服务器的CPU，MEMORY，IO之外，还要实时对数据库进行监控，因为接触的多的是mysql，就以MySQL为例。 当mysql出现运行缓慢，或者出于某种原因无法响应查询，可以监控以下几个指标来获取解决： 查询吞吐量 查询执行性能 连接情况 数据库缓冲池 吞吐量由于本篇重点是介绍监控MySQL，对于mysql的性能指标就只解释一种，以吞吐量为例：MySQL中有一个Questions的内部计数器，客户端每发送一个查询，改值加一。1234567mysql&gt; show global status like &quot;Questions&quot;;+---------------+-------+| Variable_name | Value |+---------------+-------+| Questions | 665 |+---------------+-------+1 row in set (0.00 sec) 所以对Questions该指标进行监控，当该指标发生突变，如骤降或者骤增，很可能数据库出现了问题。 HP SiteScopeWIKIPEDIA给的解释：1HP SiteScope is agentless monitoring software focused on monitoring the availability and performance of distributed IT infrastructures, including Servers, Network devices and services, Applications and application components, operating systems and various IT enterprise components. 大致意思是：HP SiteScope是无代理监控软件，专注于监控分布式IT基础架构的可用性和性能，包括服务器，网络设备和服务，应用程序和应用程序组件，操作系统和各种IT企业组件。所以，HP SiteScope很适合用来监控MySQL。 安装网上找一圈硬是没找到安装包，很怀疑对于mysql的监控有更简单的方法，或者就是压根没人做开源的。。直接梯子到官网下了个11.3的版本： 度娘盘连接 密码：7l99mysql驱动密码：y9i8 安装很简单，压缩包打开，找到HPSiteScope_11.30_setup.exe一路next即可，mysql驱动放在D:\HP\SiteScope\java\lib\ext下。 LR监控MySQL操作安装完成HP SiteScope后，在浏览器输入url：http://127.0.0.1:8080/SiteScope即可打开主页 可能遇到的问题输入url之后，可能会遇见页面是空白的情况（我就遇到过），首先，别用chrome和firefox，这玩意貌似只能在IE上面打开；其次，你本地需要JDK环境（java -version）要求JDK1.6以上。最后，IE的internet选项中，把局域网设置里的代理勾掉。以上就是我解决的页面空白的三个办法（我全中过，折腾老半天） 进入HP SiteScope首页，在SiteScope上右键，新建组，输入组名之后，右键创建的组，新建监控器，选择数据库计数器，只需要配置几项：12345678910数据库连接URL: jdbc:mysql://localhost/sakila查询： show status数据库驱动程序： org.gjt.mm.mysql.Driver凭据：输入数据库用户名及密码计数器：选择计数器：Com_insert_select/Value Com_select/Value counters in error Questions/Value Select_scan/Value 点击验证保存，完成保存。 lr配置监控打开LR Contraller，配置完场景，在run页面，可用图，选择SiteScope图，右键SiteScope，点击打开，右击打开的SiteScope图，点击添加度量，弹出的窗口有两个添加，上面一个是添加服务器，我添加的是localhost端口8888，下一个添加是选择添加的组件，选择需要的添加组件，点击确定，即可完成配置。（没办法，图床都太坑了，所以全程无图。。。请原谅。。。） 后记官网下载的HP SiteScope是未破解版，有时间还是需要折腾个破解版的研究研究。工具是会用了，原理根本没去看，这是病，不懂原理就直接使用，总感觉不踏实。 参考地址]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>loadrunner</tag>
        <tag>SiteScope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之SQL优化系列（一）]]></title>
    <url>%2F2018%2F03%2F09%2FMySQL%E4%B9%8BSQL%E4%BC%98%E5%8C%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[作为一个不知道几分之几的程序员，日常性能测试的关注点之一就是SQL的执行效率，SQL优化。 案例库mysql提供有类似oracle的scott库（root/tiger，至今记得接触oracle时候这个趣闻，创始人是库名，猫的名字是密码）的案例库sakila，基本可以使用来完成SQL优化的测试。 sakila库下载地址 压缩包中有三个文件：sakila-schema.sql，sakila-data.sql，sakila.mwb；sakila-schema.sql建库及表，sakila-data.sql插数据，sakila.mwb可以使用mysql workbench打开，是sakila的数据模型（MySQL Mode） MySQL workbench官方下载地址度娘盘地址&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;密码：25y4 安装完成：12345678910111213141516171819202122232425262728293031mysql&gt; use sakila;Database changedmysql&gt; show tables;+----------------------------+| Tables_in_sakila |+----------------------------+| actor || actor_info || address || category || city || country || customer || customer_list || film || film_actor || film_category || film_list || film_text || inventory || language || nicer_but_slower_film_list || payment || rental || sales_by_film_category || sales_by_store || staff || staff_list || store |+----------------------------+23 rows in set (0.00 sec) show status查看SQL执行频率MySQL可以通过show [session|global] status命令来查看服务器状态信息；其中session，global为可选参数，session表示显示当前连接的统计结果，global表示统计自数据库上次启动至今的信息，不写默认为session。示例：12345678910111213141516171819202122232425262728mysql&gt; show status like &apos;Com_%&apos;; +-----------------------------+-------+ | Variable_name | Value | +-----------------------------+-------+ | Com_admin_commands | 0 | | Com_assign_to_keycache | 0 | | Com_alter_db | 0 | | Com_alter_db_upgrade | 0 | | Com_alter_event | 0 | | Com_alter_function | 0 | | Com_alter_instance | 0 | | Com_alter_procedure | 0 | | Com_alter_server | 0 | | Com_alter_table | 2 | | Com_alter_tablespace | 0 | | Com_alter_user | 0 | | Com_analyze | 0 | | Com_begin | 0 | | Com_binlog | 0 | | Com_call_procedure | 0 | | Com_change_db | 3 | | Com_change_master | 0 | | Com_change_repl_filter | 0 | | Com_check | 0 | | Com_checksum | 0 | | Com_commit | 15 | | Com_create_db | 1 | ... 统计当前连接下的信息。 参数解释Com_xxx表示每个xxx语句执行的次数，通常比较关注的是以下几个：◆&ensp;Com_select：&ensp;执行SELECT操作的次数，执行一次累加1；◆&ensp;Com_insert：&ensp;执行INSERT操作的次数，对于批量插入的INSERT操作，只累加一次；◆&ensp;Com_update：&ensp;执行UPDATE操作的次数。◆&ensp;Com_delete：&ensp;执行DELETE操作的次数。上述参数对于所有的存储引擎的表操作都会进行累计，下面的参数，只针对InnoDB存储引擎：◆&ensp;Innodb_read：SELECT查询返回的行数。◆&ensp;Innodb_rows_inserted：执行INSERT操作插入的行数。◆&ensp;Innodb_rows_updated：执行UPDATE操作更新的行数。◆&ensp;Innodb_rows_deleted：执行DELETE操作删除的行数。通过以上参数，比较容易得出当前数据库的应用是插入更新为主还是查询操作为主，以及各种类型的SQL大致执行的比例是多少。（对于更新操作的技术，是对执行次数的技术，不论commit还是rollback都会累加）。对于事务型应用，通过Com_commit和Com_rollback可以了解事务提交和回滚的情况，对于回滚操作很频繁的数据库，可能意味着应用编写存在问题。另外，一下几个参数便于了解数据库的基本情况：◆&ensp;Connections：尝试连接MySQL服务器的次数。◆&ensp;Uptime：服务器工作时间。◆&ensp;Slow_queried：慢查询次数 定位执行效率低的SQL我在工作中，使用过两种方式来查看当前执行效率低的SQL：一：查看线程：show processlist示例：1234567891011mysql&gt; show processlist;+----+------+-----------------+--------+---------+-------+----------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+-----------------+--------+---------+-------+----------+------------------+| 6 | root | localhost:16830 | test1 | Sleep | 18721 | | NULL || 7 | root | localhost:17154 | test1 | Sleep | 18721 | | NULL || 18 | root | localhost:47691 | sakila | Query | 0 | starting | show processlist || 19 | root | localhost:49737 | NULL | Sleep | 393 | | NULL || 20 | root | localhost:49738 | sakila | Sleep | 393 | | NULL |+----+------+-----------------+--------+---------+-------+----------+------------------+5 rows in set (0.00 sec) 该命令可以查看当前MySQL在进行的线程，包括状态，信息（是否锁表）等，便于实时查看SQL执行情况 二：慢查询日志定位MySQL的慢查询日志位置可以命令查看：12345678mysql&gt; show variables like &apos;%slow_query_log%&apos;;+---------------------+-----------------------------------------------------------+| Variable_name | Value |+---------------------+-----------------------------------------------------------+| slow_query_log | OFF || slow_query_log_file | /home/data/mysql/centos7-db-slow.log |+---------------------+-----------------------------------------------------------+2 rows in set, 1 warning (0.00 sec) 默认情况下慢查询是关闭的，慢查询日志保存路径可以看见。只需要给slow_query_log设置值即可开启慢查询：1234567891011mysql&gt; set global slow_query_log=1;Query OK, 0 rows affected (0.01 sec)mysql&gt; show variables like &apos;%slow_query_log%&apos;;+---------------------+-----------------------------------------------------------+| Variable_name | Value |+---------------------+-----------------------------------------------------------+| slow_query_log | ON || slow_query_log_file | /home/data/mysql/centos7-db-slow.log |+---------------------+-----------------------------------------------------------+2 rows in set, 1 warning (0.00 sec) 同时，可以配置慢查询时间，以及慢查询日志保存路径：在mysql安装路径下找到my.cnf文件，在其中增加或者修改long_query_time和slow_query_log_file即可完成配置。或者命令行更改也可以：123456789101112131415161718mysql&gt; show variables like &apos;%long_query_time%&apos;;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set, 1 warning (0.00 sec)mysql&gt; set long_query_time=2;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &apos;long_query_time&apos;;+-----------------+----------+| Variable_name | Value |+-----------------+----------+| long_query_time | 2.000000 |+-----------------+----------+1 row in set, 1 warning (0.00 sec) 慢查询示例当MySQL开启了慢查询，并且慢查询时间也根据自己情况进行了更改，下面实验下：12345678mysql&gt; show variables like &apos;%slow_query_log%&apos;;+---------------------+-----------------------------------------------------------+| Variable_name | Value |+---------------------+-----------------------------------------------------------+| slow_query_log | ON || slow_query_log_file | /home/data/mysql/centos7-db-slow.log |+---------------------+-----------------------------------------------------------+2 rows in set, 1 warning (0.00 sec) 可以看见，当前系统慢查询是开启状态，且一旦出现慢查询，会记录日志在/home/data/mysql/centos7-db-slow.log中。1234567mysql&gt; show variables like &apos;long_query_time&apos;;+-----------------+----------+| Variable_name | Value |+-----------------+----------+| long_query_time | 2.000000 |+-----------------+----------+1 row in set, 1 warning (0.00 sec) 慢查询时间设置为2s，一旦有SQL执行时间超过2s，就会被认为是慢查询，记录在慢查询日志中。 执行4s查询：1234567mysql&gt; select sleep(4);+----------+| sleep(4) |+----------+| 0 |+----------+1 row in set (4.00 sec) 该SQL执行时间为固定的4s，按照设置，肯定是慢查询了，进入日志文件，查看日志：123456789MySQL, Version: 5.7.21 (MySQL Community Server (GPL)). started with:TCP Port: 3306, Named Pipe: MySQLTime Id Command Argument# Time: 2018-03-09T08:34:16.502235Z# User@Host: root[root] @ localhost [::1] Id: 2# Query_time: 4.000101 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0use sakila;SET timestamp=1520584456;select sleep(4); 以上就是慢查询内容，包含数据库，SQL执行时间，具体SQL，即定位到执行效率低的SQL，进行优化。 后记定位到慢查询的SQL之后，接下来就是对低效SQL进行分析，后序再说…]]></content>
      <categories>
        <category>MySQL-SQL优化</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础之*args与**kwargs]]></title>
    <url>%2F2018%2F03%2F08%2Fpython%E5%9F%BA%E7%A1%80%E4%B9%8B-args%E4%B8%8E-kwargs%2F</url>
    <content type="text"><![CDATA[python基础之*args和**kwargs简单介绍 认识 *args和 **kwargs首先，看看*args和**kwargs到底是个什么：代码示例：123456789def foo(*args, **kwargs): print(u&quot;args = &quot;, args) print(u&quot;kwargs = &quot;, kwargs) print(&quot;==============我是分割线==================&quot;)if __name__ == &apos;__main__&apos;: foo(1, 2, 3, 4) foo(a=1, b=2, c=3) 输出结果为：123456args = (1, 2, 3, 4)kwargs = &#123;&#125;==============我是分割线==================args = ()kwargs = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;==============我是分割线================== 可以看出，这俩其实就是python的两个变量，*args是个元组（tuple）,**kwargs是个字典（dictionary）。 原理通过google各种解释，差不多是理解了，其实*args和**kwargs真正起作用的是*和**，而args以及kwargs其实就类似于var和vars；当python需要传递多个参数时，就将参数放在一个元组里，按照参数位置传递，以*开头；当需要传递多个键值对时，就把这些键值对放在一个字典里，按照关键字传递，以**开头。 示例一：1234567def foo(x, *args): print(x) print(args)if __name__ == &apos;__main__&apos;: foo(1, 2, 3, 4) 输出结果：121(2, 3, 4) 可以看出，python将（1,2,3,4），其中1，赋给默认参数x，（2,3,4）作为一个元组赋给args； 示例二：1234567def foo(x, **kwargs): print(x) print(kwargs)if __name__ == &apos;__main__&apos;: foo(1, a=2, b=3, c=4) 输出结果：121&#123;&apos;a&apos;: 2, &apos;b&apos;: 3, &apos;c&apos;: 4&#125; python将(1, a=2, b=3, c=4)，其中1，赋值给默认参数x；(a=2, b=3, c=4)作为字典赋给kwargs。 实参角度或者从实参角度来理解：*args示例：12345678def foo(x, y, z): print(x) print(y) print(z)if __name__ == &apos;__main__&apos;: foo(*(1, 2, 3)) 输出结果：123123 可以看出python将*(1, 2, 3)，按照位置将值赋给了x, y, z； **kwargs示例：12345678def foo(x, y, z): print(x) print(y) print(z)if __name__ == &apos;__main__&apos;: foo(**&#123;&quot;x&quot;:1,&quot;y&quot;:2,&quot;z&quot;:3&#125;) 输出结果：123123 python将**{&quot;x&quot;:1,&quot;y&quot;:2,&quot;z&quot;:3}，按照关键字x,y,z赋值给了x,y,z。 *args其实可以理解为python需要调用的任意个没有关键字的参数（无名参数）组成的元组，称之为Non-keyword Variable Arguments；**kwargs是python需要调用的任意个关键字参数（键值对）组成的字典，称之为keyword Variable Arguments 注意事项位置参数，*args，**kwargs混合使用顺序当函数参数中同时拥有位置参数，*args以及**kwargs时，顺序必须是位置参数，*args，**kwargs，否则会报错。示例：12345678def foo(x, *args, **kwargs): print(x) print(args) print(kwargs)if __name__ == &apos;__main__&apos;: foo(1,2,3,4,a=1, b=2, c=3) 输出结果：1231(2, 3, 4)&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125; 位置参数，默认参数，**kwargs混合使用顺序当需要同时使用位置参数，默认参数以及**kwargs时，顺序必须为位置参数，默认参数，**kwargs，否则会报错。示例：12345678def foo(x, y=2, **kwargs): print(x) print(y) print(kwargs)if __name__ == &apos;__main__&apos;: foo(1,3,a=1,b=2,c=3) 输出结果：12313&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125; 其中，3将赋给y，替换默认值2。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker使用简介]]></title>
    <url>%2F2018%2F03%2F05%2Fdocker%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[日常docker使用简介 由于日常测试的项目都是在云端，阿里云，AWS上，基本也都是使用了虚拟化技术，项目放在docker或者k8s中。我现在所在的公司，是把项目放在docker中，挂在阿里云上，所以日常使用比较多的就是docker了。 常用操作查看服务从跳转机进入指定的docker所在服务器中，想要查看目前运行的服务：查看所有服务:1docker ps -a 和在linux下查看服务差不多，只是前面加了个docker；查看指定的服务，例如想查看服务名为boss的服务:1docker ps -a |grep boss 看着还是和linux下查看服务一样。。 查看日志一般进行测试时，习惯是开着日志，动态查看，因为有的错误，页面不会全部展示出来，我的习惯是进行测试时，浏览器开启开发者模式（F12），后台开启动态日志，执行操作之后进行数据库查询验证；那么docker下进行动态日志展示：1docker logs -f --tail=300 ContainerId 解释：首先在服务所在的服务器下，查询得到该服务当前开启的容器ID（containerId）docker ps -a该命令执行完成，会展示服务的基础信息：12[root@test-docker2 anmavadmin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 即可以获取得到指定服务的containerid，动态查看日志和linux下类似，linux下普通的查看日志：1tail -f -n 300 xxx.log 即可动态显示日志文件后300行的日志，同样的，在docker下查看也是使用-f动态显示，显示行数用--tail=行数，再加上指定的Container Id即可1docker logs -f --tail=300 boss_container_id 进入Docker容器docker说到底，其实就是个小型的linux环境，所以，和普通linux一样，也是可以直接进入docker内部，进入docker内部有四种方法，方法很多，日常熟练的掌握一l两种即可。: 进入docker内部的四种方法 我日常使用的是docker exec进入docker内部：1docker exec -it ContainerId /bin/bash 即可进入容器内部，之后就可以和普通linux下一样操作。 K8S（Kubernetes） + Docker当前很多环境的搭建方案选择都是k8s+docker的混合搭建，这样的环境，进行测试工作的常用操作： 查看服务所在节点首先是进入k8s所在的服务器，查看需要查看日志的服务所在docker节点（正常情况下都不会只有一台docker，负载均衡，都知道。。。）：1kubectl get pods -o wide 即可显示所有服务的基础信息，包括服务名称，状态，IP，docker节点：123[root@centos7-k8s1 xxx]# kubectl get pods -o wideNAME READY STATUS RESTARTS AGE IP NODEtest-boss-server-060b3cf86fa24bd7c9ce2548015e9b38-07qn1 1/1 Running 0 12h 172.17.46.3 centos7-k8s1 此时即可获取到服务所在节点，例如上述示例，服务在centos7-k8s1，即节点1上，所以进入节点1所在服务器，即可动态查看服务日志:123进入节点1，sudo su root(或者就是sudo 命令)docker ps -a |grep bossdocker logs -f --tail=300 containerid 查看服务状态测试中也会遇见点击页面无响应，后台报服务连接超时的错误，此时，可以查看当前服务运行状态：1kubectl get rc -o wide 获取到的信息：123[root@centos7-k8s1 xxx]# kubectl get rc -o wideNAME DESIRED CURRENT READY AGE CONTAINER(S) IMAGE(S) SELECTORtest-boss-server 2 2 2 12h test-boss-server registry.docker.test.cn:5000/test-dev/test-boss-server:20180304_215608 deployment=060b3cf86fa24bd7c9ce2548015e9b38,name=test-boss-server,version=test 可以看出boss服务，期望运行节点数是2，当前运行节点数也是2，所以该服务当前是正常状态。一旦出现DESIRED和CURRENT的值不一致，表明有服务出现问题。出现问题之后就需要对服务进行问题定位，重启等操作，就不多说了。 后记自己对于虚拟化技术的掌握度基本是皮毛都算不上，现在还是满足最基本工作需要范围o(╥﹏╥)o，后期看来得好好补。。 3月3号时候，突然有个冲动，步行到西山岛上去，然后就说走就走。。。从渔洋山一直到西山岛-金庭游客中心,一个人默默的暴走了近1个小时40分钟，9.5km，走完全程3段太湖大桥，穿过岛两座，可惜天公不作美啊，太湖湖面上雾有点大，桥上风景还是有点朦胧，得找个天气晴朗的日志再走一遭！（再也不穿登山鞋去了，原本想爬山才穿的登山鞋，结果徒步差点没把脚走废掉。。。） 生命在于运动，恰逢一年一度的跑步黄金时期，该走出去，走走，跑跑，爬爬山~~~(大早上来发现VPS又挂了，哎我的hexo可以搭在VPS上的，进不去还写个鬼博客，只好又重搭了一个，愁)]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>Linux运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年伊始-开年记]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%96%B0%E5%B9%B4%E4%BC%8A%E5%A7%8B-%E5%BC%80%E5%B9%B4%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[随波逐流，还是不停的瞎折腾~ 新年伊始过年来上班第一天就发现，SSR又登不上了，也就意味着，google啊，又离我远去。。。搞啥啊，查了下黄历，没啥问题啊，翻了下新华社新闻，好吧，开会了。。不出所料，被墙了。 周二时候有点不服，把vultr上几乎所有VPS都重搭了下，好吧，居然IP全挂，这么多台都全挂，有点服。。今天早上过来，感觉还是有点不爽，主要是每次打开浏览器，由于我设置的Chrome主页就是google，每次进来都是空荡荡的，感觉很难受，抱着不死就折腾的心态，又开始搭，结果还真找到个漏网之鱼，苍天啊，真的是泪流满面o(╥﹏╥)o 立刻重建，还好有这个经历： VPS重建记 一台新机器，花了半个小时就完成了，终于，又可以科学上网，hexo又可以更博了！！ 日常记忆随手记下昨天遇到的小白问题：在搭建自动化框架时，基本会把页面元素的定位信息放在类似于example.ini的配置文件中，然后从文件中获取定位方式以及定位表达式，这样方便维护。读取example.ini文件配置内容，我是使用的configparser，用法：12cf = configparser.ConfigParser()cf.read(&apos;example.ini&apos;) 这样就会把配置文件中的配置信息加载到内存中，获取信息一般使用两种方式： 获取特定的optionValue使用cf.get(section, option)即可获取特定的option的值例如，有一个example.ini内容如下：12345[126mail_login]loginPage.frame = id &gt; x-URS-iframeloginPage.username = xpath &gt; //input[@name=&quot;email&quot;]loginPage.password = xpath &gt; //input[@name=&quot;password&quot;]loginPage.loginbutton = id &gt; dologin 想要获取切换到登录frame的定位方式及表达式，只需要：12frame126 = cf.get(&quot;126mail_login&quot;, &quot;loginPage.frame&quot;)print(frame126) 打印出定位方式及表达式：1id &gt; x-URS-iframe 获取指定section下的所有option使用cf.items(section)即可获取该section下的所有option，返回的是一个列表，包含option以及对应的value示例：12options = cf.items(&quot;126mail_login&quot;)print(options) 返回结果：1[(&apos;loginpage.frame&apos;, &apos;id &gt; x-URS-iframe&apos;), (&apos;loginpage.username&apos;, &apos;xpath &gt; //input[@name=&quot;email&quot;]&apos;), (&apos;loginpage.password&apos;, &apos;xpath &gt; //input[@name=&quot;password&quot;]&apos;), (&apos;loginpage.loginbutton&apos;, &apos;id &gt; dologin&apos;)] 问题由于日常的开发环境是windows，系统的默认编码是gbk，所有在windows下使用configparser来读取配置文件时，有的时候会报编码错误：1UnicodeDecodeError: &apos;gbk&apos; codec can&apos;t decode byte 0xae in position 272: illegal multibyte sequence 解决解决方法很简单，直接看cf.read()的源码，源码是这样的：1234567891011121314151617181920212223def read(self, filenames, encoding=None): &quot;&quot;&quot;Read and parse a filename or a list of filenames. Files that cannot be opened are silently ignored; this is designed so that you can specify a list of potential configuration file locations (e.g. current directory, user&apos;s home directory, systemwide directory), and all existing configuration files in the list will be read. A single filename may also be given. Return list of successfully read files. &quot;&quot;&quot; if isinstance(filenames, str): filenames = [filenames] read_ok = [] for filename in filenames: try: with open(filename, encoding=encoding) as fp: self._read(fp, filename) except OSError: continue read_ok.append(filename) return read_ok 默认的read()是没有指定编码的encoding=None，所以只需要指定编码为utf-8即可解决：1cf.read(pageElementLocatorPath, encoding=&apos;utf-8&apos;) 其中pageElementLocatorPath为example.ini文件 后记生活不就是不断的折腾嘛，墙了继续试，大不了你再墙嘛~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>自动化测试</tag>
        <tag>lives</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在2018新年来临]]></title>
    <url>%2F2018%2F02%2F12%2F%E5%86%99%E5%9C%A82018%E6%96%B0%E5%B9%B4%E6%9D%A5%E4%B8%B4%2F</url>
    <content type="text"><![CDATA[写在春节来临之际农历2017年最后一个工作日，明天就要回家过春节了，想想，2017，好像过去的挺快的。来篇流水账，写写，我的2017。 活在苏州： 工作篇有苦有甜才是生活，作为占据我一天一半时间的大头，首先还是想看看在这上面，我的2017到底发生了些什么。工作内容还是日常的做个行走的BUG，以做一个开发及其烦躁的tester为荣，并在这条道上，坚定的走到黑！ 安硕生涯2016年7月来到安硕，工作了也有段时间，工作方式，好歹是从个外人眼中看来，测试就是定点点的工作转换成了性能测试做的多一点的，入门级性能测试工程师。日常工作，积累了一套性能需求分析-脚本编写-结果分析-瓶颈定位-性能调优的性能测试步骤，说起来，做的还是有点乐此不疲的，就是记忆力有点差，mysql性能调优经常忘。。（(ಥ_ಥ) ）同时，接触到了大数据相关，虽然和我的关联不是特别大，最多就是帮着测测规则，测测数据，好歹是打开了另一扇窗；眼界不是来自于期刊杂志，有真正自己去接触了，才是有自己的感受，所以，还是挺感激这段经历。然后2017年9月，离开了安硕。 新的开始2017年9月21日，正式从安硕来到了这，正式开始了测试带队（虽然手下就一人~~~），也正式捡起了放下一年半的python。刚毕业那会，和舍友选语言，他选了python做爬虫，我选了java，后来兜兜转转，我的java技术还是那么菜，压根入门都没达到就半路夭折，好在，还有补牢的机会，重新拿起python，做起了自动化。9月至今，python书籍看完两本，简陋自动化框架搭建完成一个，算是还对的起自己。路还在脚下，当慢慢走。 生活篇2017年的生活，不再那么浑浑噩噩，上班下班，周末宅；生活中发生了好几件大事。2017年5月13日，在苏州买了房，从此开始房奴生涯（o(╥﹏╥)o）2017年5月23日，回句容领了证，从此告别一个人的时光（(｀・ω・´)）7月，失去了一位亲人..总的来说，2017，算是翻天覆地的一年，本命年的我，经历了也就这些。人间烟火，不过是比落叶还轻的生活；该开的开，山野鲜花依然澎湃；该来的来，路上精彩还在等待。 玩乐篇换个心情，回忆点轻松的，作为一个从小就喜欢满田野疯的“野孩子”，整年不出门去看看那是不现实的。3月，的确是个赏樱花的季节，无锡-鼋头渚 原谅手残，技术不到家，樱花实在没拍的好，照片只能待在自己手机没事用来傻笑~4月，好像是万条垂下绿丝绦的时节了，杭州-西湖九溪烟树，云栖竹径，苏堤春晓，柳浪闻莺，梅坞春早，钱塘江，龙井村等等，带着个小胖子，也有过一天翻越无数山头，暴走30公里的经历。（杭州之行，照片太丑，不拿出来丢人。。。）8月，拿着婚假，怀着点点感伤，踏上了川藏线的朝圣之路，成都-&gt;拉萨成都遇上海燕和莉儿，一行，10天，成都出发，终点拉萨。南方的孩子，还是应该在8月到雪山上去看看雪的，不是吗~感芸芸众生，人世无常，茫茫大海，谁可争流；不如步入山野，凭栏远眺，闲庭信步，观云卷云舒。 竺法渐传三界远，盛音近绕佛堂前。达布拉宫，只有亲眼看见，才知道，眼前，真的就是一幅画。 然后，12月，前往丽江拍婚纱照，天和西藏一样蓝，就是商业气息过于浓重了点，小憩可以，不宜久居。时间有限，没去成泸沽湖，没机会去洱海，都算是遗憾，谁说不是呢，有遗憾，才是真正的活着嘛。（照片，在相机，忘了传手机了。。。） 后记不大不小，24周岁，不多不少，两个人了；愿能够笑看沧桑，轻盈过往；淡看流年烟火，细品岁月静好。花有花的灿烂，云有云的诗意，淡然的面对生命的一切逝去，在似水流年间细细品味每一个过往，每一种滋味，每一份流逝。 最后，最后一天了，祝所有，在未来的日子里，恬然，静候花开。 （原谅通篇流水账~~~太久不会写文字了￣□￣｜｜）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>lives</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3完成mysql操作]]></title>
    <url>%2F2018%2F02%2F11%2Fpython3%E5%AE%8C%E6%88%90mysql%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[python3使用pymysql操作mysql5.7 版本信息：1234MYSQL 5.7.21PYTHON 3.6pymysql 0.8.0WIN 10 安装首先，老样子，安装。windows控制台直接执行：1pip install pymysql 即可，pipenv进行类包管理，控制台中进入工程所在目录下，执行：1pipenv install pymysql SQLsql.py文件，包含初始化数据库，创建库，创建表所有sql：1234567891011# 创建gloryroad数据库create_database = &apos;CREATE DATABASE IF NOT EXISTS gloryroad DEFAULT CHARSET utf8 COLLATE utf8_general_ci;&apos;# 创建testdata表drop_table = &apos;drop table if exists TESTDATA;&apos;create_table = &quot;&quot;&quot;CREATE TABLE TESTDATA ( id INT NOT NULL, bookname VARCHAR(40) NOT NULL UNIQUE, author VARCHAR(30) NOT NULL)&quot;&quot;&quot;primary_sql = &apos;alter table testdata add primary key(id);&apos;alter_id = &apos;alter table testdata change id id int AUTO_INCREMENT NOT NULL;&apos; 创建表时候，我们在mysql控制台，或者在类似Navicat for mysql这样的数据库连接工具中直接执行1234567CREATE TABLE `testdata` ( `id` int(11) NOT NULL AUTO_INCREMENT, `bookname` varchar(40) NOT NULL, `author` varchar(30) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `bookname` (`bookname`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 即可创建包含主键，唯一键，自增字段等属性的testdata表，但是不知道为啥，我直接在pycharm中执行，一直报错，又不想耗在这上面，就拆开来了，先创建表，再增加主键，修改字段等操作。 pymysql创建数据库及表创建库和表pymysql对mysql的操作，基本可以总结为几步：123456建立连接（connect）打开游标（cursor）执行sql（execute）提交事务（commit）关闭游标（close cursor）关闭连接（connect close） 所以进行创建数据库和表操作时，一步一步执行即可：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/11 13:06&quot;&quot;&quot;from SQL import *import pymysqlclass DataBaseInit(object): &quot;&quot;&quot; 1、数据库初始化 2、创建数据库及表，并向表中插入测试数据 &quot;&quot;&quot; def __init__(self, host, port, dbName, username, password, charset): self.host = host self.port = port self.db = dbName self.username = username self.password = password self.charset = charset def creaete(self): # 建库及表 try: # 连接mysql数据库 conn = pymysql.connect( host = self.host, port = self.port, user = self.username, passwd = self.password, charset = self.charset ) # 获取数据库游标 cur = conn.cursor() # 创建数据库 cur.execute(create_database) # 选择创建好的数据库 conn.select_db(&quot;gloryroad&quot;) # 建表并更改字段 cur.execute(drop_table) cur.execute(create_table) cur.execute(primary_sql) cur.execute(alter_id) except pymysql.Error as e: raise e else: # 关闭游标 cur.close() # commit conn.commit() # 关闭连接 conn.close() print(u&quot;创建数据库及表成功&quot;) 插入数据插入数据也是正常步骤即可，当插入不止一条数据，可以使用executemany()来一次插入多条数据，配合insert into table (col1, col2) values (%s, %s)可以完成参数化一次插入大量数据；插入数据方法：1234567891011121314151617181920212223242526272829303132def insertData(self): # 插入数据 try: # 连接具体某个库 conn = pymysql.connect( host=self.host, port=self.port, db=self.db, user=self.username, passwd=self.password, charset=self.charset ) # 打开游标 cur = conn.cursor() # 插入数据 sql = &quot;insert into testdata (bookname, author) values (%s, %s)&quot; cur.executemany(sql, [ [&apos;FACE TO FACE WITH FARE&apos;, &apos;Amana Trobe&apos;], [&apos;Relationship&apos;, &apos;Christopher benas Meng&apos;], [&apos;ZOO&apos;, &apos;Yiyi&apos;] ]) except pymysql.Error as e: raise e else: conn.commit() print(u&quot;初始化数据插入成功&quot;) # 确认插入成功 # cur.execute(&quot;select * from testdata;&quot;) # for i in cur.fetchall(): # print(i[1], i[2]) cur.close() conn.close() 从mysql获取数据很简单，一步一步走即可：12345678910111213def getDataFromDataBases(self): # 从testdata表获取测试数据 # bookname作为testdata，author作为expectdata self.cur.execute(&quot;select bookname, author from testdata;&quot;) # 取查询结果 datasTuple = self.cur.fetchall() return datasTupledef closeDatabase(self): # 数据库后续操作 self.cur.close() self.conn.commit() self.conn.close() 至此，就可以完成测试数据存在mysql中，从数据库表中完成测试数据的读取以及断言判断等操作。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>python3</tag>
        <tag>pymysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python3的UI自动化框架搭建系列（二）]]></title>
    <url>%2F2018%2F02%2F09%2F%E5%9F%BA%E4%BA%8Epython3%E7%9A%84UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自动化测试框架雏形搭建完成 小结框架终于差不多完成了，包含了123自定义日志自定义测试报告实时邮件发送 等模块。目前可以实现：12345测试过程中控制台实时打印日志测试过程中实时写日志入自定义log文件测试过程中发生断言失败，实时截图，并且将堆栈日志打印到指定log文件测试完成自动生成html格式测试报告测试完成自动发送邮件 实例以下是实现的简单的从excel中读取数据进行自动化测试的实例（测试用例使用excel编写）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/9 15:30&quot;&quot;&quot;from selenium import webdriverfrom ExcelUtil import GetDataFromExcelfrom selenium.common.exceptions import NoSuchElementExceptionfrom Log import *from MailSend import MailSendfrom ReportTemplate import htmlTemplatefrom nose.tools import assert_truefrom MakeDirs import *import time,tracebackimport sys,ddt# excel路径，sheet名path = &quot;G:/workstation/py_workstation/DataDriverTest/DdtData/testData.xlsx&quot;sheetname = &quot;search_data&quot;excel = GetDataFromExcel(path, sheetname)@ddt.ddtclass TestDdtByExcel(): @classmethod def setUpClass(cls): TestDdtByExcel.trStr = &quot;&quot; def setUp(self): self.browser = webdriver.Chrome() # 设置测试状态及结果标志 self.status = None self.flag = 0 @ddt.data(* excel.getData()) def test_ddtbyexcel(self, data): # 声明全局变量 global start, starttime # 定义执行结果的颜色 flagDict = &#123;0: &apos;red&apos;, 1: &apos;00AC4E&apos;&#125; # 获取测试用例名称 casename = sys._getframe().f_code.co_name testdata, expectdata = tuple(data) url = &quot;https://www.baidu.com&quot; self.browser.get(url) self.browser.implicitly_wait(10) try: # 获取当前时间戳 start = time.time() # 获取当前时间 starttime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) # 搜索 self.browser.find_element_by_id(&apos;kw&apos;).send_keys(testdata) self.browser.find_element_by_id(&apos;su&apos;).click() # 休眠3s time.sleep(3) # 断言 assert_true(expectdata in self.browser.page_source) except NoSuchElementException as e: error(u&quot;页面元素不存在：&quot; + str(traceback.print_exc( file=open(&quot;G:/workstation/py_workstation/DataDriverTest/Logs/Error/DdtTest.log&quot;, &quot;a&quot;)))) self.flag = 0 self.status = &apos;fail&apos; takeScreenShot(self.browser) except AssertionError as e: error(u&quot;搜索“&#123;0&#125;，期望“&#123;1&#125;”，失败”&quot;.format(testdata, expectdata) + str(traceback.print_exc( file=open(&quot;G:/workstation/py_workstation/DataDriverTest/Logs/Error/DdtTest.log&quot;, &quot;a&quot;)))) self.flag = 0 self.status = &apos;fail&apos; takeScreenShot(self.browser) except Exception as e: error(u&quot;未知错误：&quot; + str(traceback.print_exc( file=open(&quot;G:/workstation/py_workstation/DataDriverTest/Logs/Error/DdtTest.log&quot;, &quot;a&quot;)))) self.flag = 0 self.status = &apos;fail&apos; takeScreenShot(self.browser) else: info(u&quot;搜索“&#123;0&#125;，期望“&#123;1&#125;”，通过”&quot;.format(testdata, expectdata)) self.status = &apos;pass&apos; self.flag = 1 # 计算消耗时间 # 10位时间戳，单位为s spends = time.time() - start - 3 # 取两位小数 spendtime = &quot;%.2f&quot; %spends # 报告中添加数据 TestDdtByExcel.trStr += u&apos;&apos;&apos; &lt;tr&gt; &lt;td&gt;&#123;0&#125;&lt;/td&gt; &lt;td&gt;&#123;1&#125;&lt;/td&gt; &lt;td&gt;&#123;2&#125;&lt;/td&gt; &lt;td&gt;&#123;3&#125;&lt;/td&gt; &lt;td&gt;&#123;4&#125;&lt;/td&gt; &lt;td style=&quot;color: &#123;5&#125;&quot;&gt;&#123;6&#125;&lt;/td&gt; &lt;/tr&gt; &apos;&apos;&apos;.format(casename, testdata, expectdata, starttime, spendtime, flagDict[self.flag], self.status) def tearDown(self): self.browser.quit() @classmethod def tearDownClass(cls): # 写自定义报告 htmlTemplate(TestDdtByExcel.trStr)if __name__ == &apos;__main__&apos;: os.system(&quot;nosetests -s -v &#123;0&#125;&quot;.format(__file__)) info(u&quot;*****测试报告开始发送*****&quot;) report_file = &quot;G:/workstation/py_workstation/DataDriverTest/Report/DDTByExcel.html&quot; mail_subject = &quot;NoseTest测试报告_&#123;0&#125;&quot;.format(dt.now().strftime(&quot;%Y%m%d&quot;)) mailsend = MailSend(mail_subject, report_file) mailsend.sendMail() info(u&quot;~~~测试报告发送完成，请注意查收~~~&quot;) 结构粗略结构：12345678910project|—— coding（主要代码）|—— DdtConf（一些配置，包括邮箱（.ini），日志(logger.conf)等）|—— DdtData（测试数据（excel，xml，json）等）|—— DdtTools（工具类（生成html文件，创建文件夹，截图，邮件发送，从文件读数据））等）|—— Logs（日志） |—— Info |—— Error|—— Pictures（断言失败的截图）|—— Report（测试报告） 后期再慢慢改进，可以修改的地方还有很多！]]></content>
      <categories>
        <category>自动化测试框架</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>自动化测试</tag>
        <tag>python3</tag>
        <tag>nose</tag>
        <tag>ddt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows安装mysql5.7]]></title>
    <url>%2F2018%2F02%2F09%2Fwindows%E5%AE%89%E8%A3%85mysql5-7%2F</url>
    <content type="text"><![CDATA[winwods环境安装配置mysql5.7 版本信息12win 10mysql 5.7.21 下载直接上官网下载： mysql下载官网 以前官网上的下载是有.msi格式的安装包的，现在好像没怎么找到（也可能是眼睛花了。。），现在下载的是.zip压缩包，也就是直接解压缩就可以了。 安装及配置安装将压缩包下载到本地，解压缩到你自定义的目录下，如我下载的是mysql-5.7.21-winx64.zip文件，解压缩到我本地软件安装盘：E:\Test\ 环境变量解压完成之后，进行日常操作，配置环境变量，将你解压完成之后的mysql的bin目录所在路径添加到系统环境变量path中，另外可以新建一个MYSQL_HOME的环境变量，变量值也是你的bin目录所在路径，例如我的配置：1234pathE:\Test\mysql-5.7.21-winx64\binMYSQL_HOMEE:\Test\mysql-5.7.21-winx64\bin 配置服务注册在你的mysql目录下，新建my.ini文件，来完成windows系统服务的注册，内容可参考我的：1234567891011121314151617181920[client]port=3306default-character-set=utf8[mysqld]#解压目录basedir=E:\Test\mysql-5.7.21-winx64#解压目录下data目录datadir=E:\Test\mysql-5.7.21-winx64\dataport=3306character_set_server=utf8#导出mysql数据的目录secure_file_priv =E:\Test\mysql-5.7.21-winx64\datasql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES#开启查询缓存explicit_defaults_for_timestamp=true#skip-grant-tables[WinMySQLAdmin]E:\Test\mysql-5.7.21-winx64\bin\mysql.exe DATA文件夹在mysql 5.6版本之前，默认就是在E:\Test\mysql-5.7.21-winx64下就有data文件夹，现在没有了，需要自己手动新建E:\Test\mysql-5.7.21-winx64\data新建完成之后，右键管理员打开cmd，进入mysql的bin目录下（E:\Test\mysql-5.7.21-winx64\bin），执行命令：1mysqld --initialize 运行完成之后，在data目录下就有生成一些初始化的文件，里面有个你的机器.err格式的文件，用文本编辑器打开之后，可以看见随机生成的root的密码：12018-02-09T01:51:43.117196Z 1 [Note] A temporary password is generated for root@localhost: PaFe#w##v6zD 安装mysql管理员模式打开的cmd中，进入\mysql\bin目录下，输入服务安装命令：1mysqld -install 启动服务安装没有报错情况下，可以选择在windows的服务中手动起服务，也可以命令行起：1net start mysql 打印信息：123&#123;lamb&#125; net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。 表明mysql服务已经成功启动。 mysql操作mysql服务启动之后，用root用户登录(密码在前步生成的xxx.err文件中)：1mysql -uroot -p密码 进入mysql控制台。1234567891011121314mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.21 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 表示成功进入控制台。 修改root密码控制台下执行:1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;新密码&apos;; 回车即可。用新密码重新登录进控制台，随意看看mysql吧（关于数据库的操作就不提了，教程一大堆，用多了就熟悉了）~12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 12345678910mysql&gt; use sys;Database changedmysql&gt; show tables;+-----------------------------------------------+| Tables_in_sys |+-----------------------------------------------+| host_summary || host_summary_by_file_io || host_summary_by_file_io_type || host_summary_by_stages 慢查询及版本信息123456789101112131415161718192021222324252627mysql&gt;mysql&gt; show variables like &quot;%slow%&quot;;+---------------------------+-----------------------------------------------------------+| Variable_name | Value |+---------------------------+-----------------------------------------------------------+| log_slow_admin_statements | OFF || log_slow_slave_statements | OFF || slow_launch_time | 2 || slow_query_log | OFF || slow_query_log_file | E:\Test\mysql-5.7.21-winx64\data\DESKTOP-PBQIU7V-slow.log |+---------------------------+-----------------------------------------------------------+5 rows in set, 1 warning (0.00 sec)mysql&gt; show variables like &quot;%version%&quot;;+-------------------------+------------------------------+| Variable_name | Value |+-------------------------+------------------------------+| innodb_version | 5.7.21 || protocol_version | 10 || slave_type_conversions | || tls_version | TLSv1,TLSv1.1 || version | 5.7.21 || version_comment | MySQL Community Server (GPL) || version_compile_machine | x86_64 || version_compile_os | Win64 |+-------------------------+------------------------------+8 rows in set, 1 warning (0.00 sec)]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3操作excel]]></title>
    <url>%2F2018%2F02%2F09%2Fpython3%E6%93%8D%E4%BD%9Cexcel%2F</url>
    <content type="text"><![CDATA[python3使用openpyxl完成excel数据读和写 工具python3操作excel数据，对于excel 2007及以上版本，一般使用openpyxl来进行操作；windows下，只需要控制台执行1pip install openpyxl 即可，若是使用pipenv进行类库管理的，控制台下进入工程所在目录（Pipfile所在路径），执行1pipenv install openpyxl 即可。对于pipenv在之前的一篇博客中有提及： python项目依赖管理工具 安装完成之后，执行命令python进入python交互环境，引包：1import openpyxl 不报错则安装成功 常用操作1234567891011121314151617181920212223# 引包import openpyxl# excel文件路径file = &quot;G:\workstation\py_workstation\DataDriverTest\DdtData\testData.xlsx&quot;# 打开excelwb = openpyxl.load_workbook(file)# 获取指定sheet页，名称：“search_data”sheet = wb[&quot;search_data&quot;]# 获取所有sheet的名称sheets = wb.sheetnames# 获取行数nrow = sheet.max_row# 获取列数ncol = sheet.max_column# 获取单元格值cell_1 = sheet.cell(row=2, column=2).value# 单元格赋值cell_2 = sheet.cell(row=2, column=2, value=&quot;YIDA&quot;)# 保存excelwb.save(file) 读写excel进行ddt时，有的时候测试数据，甚至测试用例是在excel中，如下表，标示出了测试数据，预期结果。 number&emsp;&emsp;testdata &emsp;&emsp;&emsp;expectdata1&emsp;&emsp;&emsp;&emsp;&ensp;Jordan&emsp;&emsp;&emsp;&emsp;&ensp;DRFSA2&emsp;&emsp;&emsp;&emsp;&ensp;Garnett&emsp;&emsp;&emsp;&emsp;&ensp;Kevin3&emsp;&emsp;&emsp;&emsp;&ensp;Oneal&emsp;&emsp;&emsp;&emsp;&emsp;Shaquille4&emsp;&emsp;&emsp;&emsp;&ensp;Nowitzki&emsp;&emsp;&emsp;&emsp;rsdffd5&emsp;&emsp;&emsp;&emsp;&ensp;Duncan&emsp;&emsp;&emsp;&emsp;Tim 首先是尝试使用python3 把数据写入excel 写数据直接上代码12345678910111213141516171819202122#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/9 13:25&quot;&quot;&quot;import openpyxlfile = &quot;G:/workstation/py_workstation/DataDriverTest/DdtData/test.xlsx&quot;wb = openpyxl.load_workbook(file)sheet = wb.activesheet.title = &quot;search_data&quot;value = [ [&quot;number&quot;, &quot;testdata&quot;, &quot;expectdata&quot;], [&quot;1&quot;, &quot;Jordan&quot;, &quot;DRFSA&quot;], [&quot;2&quot;, &quot;Garnett&quot;, &quot;Kevin&quot;]]for i in range(0, 3): for j in range(0, len(value[i])): sheet.cell(row=i+1, column=j+1, value=str(value[i][j]))wb.save(file) 读数据代码：1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/9 14:15&quot;&quot;&quot;import openpyxl# 打开excelwb = openpyxl.load_workbook(&quot;G:/workstation/py_workstation/DataDriverTest/DdtData/testData.xlsx&quot;)# 获取指定sheet页sheet = wb[&quot;search_data&quot;]# 获取列表中最大行数和最大列数nrows = sheet.max_rowncol = sheet.max_columntestdata = []# 获取2到6行for i in list(range(2,nrows+1)): tmplist = [] tmplist.append(sheet.cell(row=i, column=2).value) #2,2 tmplist.append(sheet.cell(row=i, column=3).value) #2,3 testdata.append(tmplist)print(testdata) 完成！！！ 后记估计是快过年，快放假了，都没什么心思敲了；真的是弄了好久才读出数据。。。python3操作excel是真的跟python2很不一样，网上的教程很多都不能用，最明显的就是:python2可以遍历工作表区域每一行，跳过第一行，直接写成1for row in sheet.rows[1:]: 但是python3实现不了。。不过自己能折腾出来，感觉还是有点小小的成就感的~ 附环境版本：1234python 3.6openpyxl 2.5.0win 10office 2013]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>openpyxl</tag>
        <tag>ddt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义测试报告]]></title>
    <url>%2F2018%2F02%2F08%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[解决自动化测试中捕获断言之后，测试报告展示为ok无法查看具体哪条用例执行失败的问题 问题来自之前博客中折腾的单元测试异常捕获问题：自动化测试断言捕获当时折腾出的解决方案是自定义测试报告的模板，定义status状态位，作为测试用例执行结果的状态标志，一旦发生断言异常捕获，将status状态为置为fail，最后体现在测试报告上。 自定义报告自定义报告模块，参考nose生成的报告，又东拼西凑折腾出了这份最简单的测试报告，最终报告生成原理就是：首先html文件中创建表格，预留html的尾部，在后续执行自动化测试过程中，将生成的测试数据拼接到不完整的html文件中，最终生成完成的html文件作为测试报告。 ReportTemplate.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/8 11:21&quot;&quot;&quot;def htmlTemplate(trData): &quot;&quot;&quot;自定义测试报告样式&quot;&quot;&quot; htmlStr = u&apos;&apos;&apos; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Unit Test Report&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;style&gt; body&#123; width: 80%; /* 整个body区域占浏览器百分比 */ margin: 40px auto; /* 整个body区域相对浏览器窗口摆放位置（左右，上下）*/、 font-weight: bold; /* 整个body区域字体加粗 */ font-family: Calibri, &quot;Trebuchet MS&quot;, sans-serif; /* 表格中文字的字体类型 */ font-size: 18px; /* 字体大小 */ color: #000; &#125; table&#123; border-spacing: 0; /* 表格边框宽度 */ width: 100%; /* 整个表格相对父元素的宽度 */ &#125; .tableStyle&#123; border-style: outset; /* 整个表格外边框样式 */ border-width: 2px; /* 整个表格外边框宽度 */ border-color: blue; /* 整个表格外边框颜色 */ &#125; .tableStyle tr:hover&#123; background: rgb(173,216,230); /* 鼠标滑过一行，动态显示的颜色 */ &#125; .tableStyle td&#123; border-left: solid 1px rgb(146,208,80); /* 表格的竖线颜色 */ border-top: 1px solid rgb(146,208,80); /* 表格的横线颜色 */ padding: 15px; /* 表格内边框尺寸 */ text-align: center; /* 表格内容显示位置 */ vertical-align: middle; &#125; .tableStyle th&#123; border-left: solid 1px rgb(146,208,80); border-top: 1px solid rgb(146,208,80); padding: 15px; text-align: center; vertical-align: middle; &#125; .tableStyle th&#123; padding: 15px; /* 表格标题栏，字体尺寸 */ background-color: rgb(146,208,80); /* 表格标题栏背景颜色 */ /* 标题栏设置渐变色 */ background-image: -webkit-gradient(linear, left top, left bottom, from(#92D050), to(#A2D668)); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;TestReport&lt;/h1&gt;&lt;/center&gt;&lt;br /&gt; &lt;table class=&quot;tableStyle&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;CaseName&lt;/th&gt; &lt;th&gt;TestData&lt;/th&gt; &lt;th&gt;ExpectData&lt;/th&gt; &lt;th&gt;StartTime&lt;/th&gt; &lt;th&gt;SpendTime&lt;/th&gt; &lt;th&gt;Result&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &apos;&apos;&apos; endStr = u&apos;&apos;&apos; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &apos;&apos;&apos; # 拼接成完整html文件 htmlf_file = htmlStr + trData + endStr with open(r&quot;D:/bug_things/selenium/report/DDTByObj.html&quot;, &quot;w&quot;, encoding=&apos;utf-8&apos;) as f_obj: f_obj.write(htmlf_file) #f.close() ddt数据驱动使用ddt进行自动化测试，单元测试框架使用nose，实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/8 14:07&quot;&quot;&quot;from selenium import webdriverfrom ReportTemplate import htmlTemplatefrom selenium.common.exceptions import NoSuchElementExceptionfrom DdtTools.Log import *from DdtTools.MailSend import MailSendfrom datetime import datetime as dtfrom nose.tools import assert_trueimport sysimport ddtimport timeimport traceback@ddt.ddtclass TestDdtByJson(): @classmethod def setUpClass(cls): # 只调一次 TestDdtByJson.trStr = &quot;&quot; def setUp(self): self.browser = webdriver.Chrome() # 存放测试结果状态，失败为fail，成功为pass self.status = None # 数据驱动测试结果的标志，成功置1，失败置0 self.flag = 0 @ddt.file_data(&quot;G:/workstation/py_workstation/DataDriverTest/DdtData/test_data_list.json&quot;) def test_ddtbyjson(self, value): global start, starttime # 获取当前测试用例名 casename = sys._getframe().f_code.co_name # 确定报告中状态单元格中内容颜色 flagDict = &#123;0: &apos;red&apos;, 1: &apos;#00AC4E&apos;&#125; url = &quot;https://www.baidu.com&quot; self.browser.get(url) #self.browser.maximize_window() # 将json中测试数据用“||”分隔成测试数据及期望结果 testdata, expectdata = tuple(value.strip().split(&quot;||&quot;)) self.browser.implicitly_wait(10) try: # 获取当前时间时间戳，用于计算耗时 start = time.time() # 获取当前时间 starttime = time.strftime(&quot;%Y-%m-%d %H:%M%S&quot;, time.localtime()) # 开始搜索 self.browser.find_element_by_id(&apos;kw&apos;).send_keys(testdata) self.browser.find_element_by_id(&apos;su&apos;).click() time.sleep(3) # 断言 assert_true(expectdata in self.browser.page_source) except NoSuchElementException as e: error(u&quot;页面元素不存在：&quot; + str(traceback.print_exc(file=(open(&quot;D:/bug_things/selenium/logs/errors/DdtTest.log&quot;, &apos;a&apos;))))) self.status = &apos;fail&apos; self.flag = 0 except AssertionError as e: error(u&apos;搜索“&#123;0&#125;”，期望“&#123;1&#125;”，失败&apos;.format(testdata, expectdata) + str(traceback.print_exc(file=open(&quot;D:/bug_things/selenium/logs/errors/DdtTest.log&quot;, &apos;a&apos;)))) self.status = &apos;fail&apos; self.flag = 0 except Exception as e: error(u&quot;未知错误：&quot; + str(traceback.print_exc(file=open(&quot;D:/bug_things/selenium/logs/errors/DdtTest.log&quot;, &apos;a&apos;)))) self.status = &apos;fail&apos; self.flag = 0 else: info(u&apos;搜索“&#123;0&#125;”，期望“&#123;1&#125;”，通过&apos;.format(testdata, expectdata)) self.status = &apos;pass&apos; self.flag = 1 # 计算消耗时间 # 时间戳相减(10位时间戳单位为s) spends = time.time() - start - 3 # 取两位小数 spendtime = &quot;%.2f&quot; %spends # 报告中添加测试数据 TestDdtByJson.trStr += u&apos;&apos;&apos; &lt;tr&gt; &lt;td&gt;&#123;0&#125;&lt;/td&gt; &lt;td&gt;&#123;1&#125;&lt;/td&gt; &lt;td&gt;&#123;2&#125;&lt;/td&gt; &lt;td&gt;&#123;3&#125;&lt;/td&gt; &lt;td&gt;&#123;4&#125;&lt;/td&gt; &lt;td style=&quot;color: &#123;5&#125;&quot;&gt;&#123;6&#125;&lt;/td&gt; &lt;/tr&gt; &apos;&apos;&apos;.format(casename, testdata, expectdata, starttime, spendtime, flagDict[self.flag], self.status) def tearDown(self): self.browser.quit() @classmethod def tearDownClass(cls): # 写自定义测试报告 htmlTemplate(TestDdtByJson.trStr)if __name__ == &apos;__main__&apos;: os.system(&quot;nosetests -s -v &#123;0&#125;&quot;.format(__file__)) info(u&quot;测试报告开始发送&quot;) report_file = &quot;D:/bug_things/selenium/report/DDTByObj.html&quot; mail_subject = &quot;UnitTest测试报告_&#123;0&#125;&quot;.format(dt.now().strftime(&quot;%Y%m%d&quot;)) mailsend = MailSend(mail_subject, report_file) mailsend.sendMail() info(u&quot;测试报告发送完成&quot;) 其中涉及到的邮件发送模块和日志模块可以参照以前的博客： 邮件模块日志配置 其中日志模块增加了对error级别的日志的配置，很简单，和info级别类似，就不多说了。最终实现效果，测试过程中在控制台以及D:/bug_things/selenium/logs/info/AutoDDT.log中实时写入info以及error的日志，当出现堆栈错误，写入D:/bug_things/selenium/logs/errors/DdtTest.log文件中，两个日志文件的写入方式都是append，测试完成之后邮件发送包含html附件的测试报告到指定邮箱；同时邮件正文中展示包含测试结果的表格，出现fail状态，可直接前往D:/bug_things/selenium/logs/errors/DdtTest.log日志中查看具体出错，以及具体出错行。需要改进的是，D:/bug_things/selenium/logs/errors/DdtTest.log文件没有明显对各个用例的区分，甚至没有空格行来让显示更明确，还是需要自己去搜索。 后记现在终于是完成了自动化测试的基本模块，日志和测试报告真的是折腾了…后期自己前端知识丰富之后，还需要优化测试报告。接下来，除了完成从excel和数据库中读取测试数据之外，就真的开始搭建自己的框架了（这几天这牛角尖钻的，解决之后还是挺舒服的~）]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>nose</tag>
        <tag>ddt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试异常捕获]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[关于自动化测试执行期间断言的异常的选择迷茫 大概是这段时间有点压抑，昨天下午就不知道怎么钻在了单元测试断言失败需不需要捕获异常这个问题上。大家都知道，进行单元测试时，加入断言验证单元测试结果，断言失败会报错，通过会打印ok标识。 nose进行单元测试使用nose进行单元测试示例：123456789#!/usr/bin/env python3# -*- coding: utf-8 -*-from nose.tools import assert_equaldef test_sum(): a = 1 b = 2 res = 5 assert_equal(res, a+b) 控制台执行1nosetests -v -s Testexec.py 打印信息12345678910111213141516Testexec.test_sum ... FAIL======================================================================FAIL: Testexec.test_sum----------------------------------------------------------------------Traceback (most recent call last): File &quot;g:\skills\python36\lib\site-packages\nose\case.py&quot;, line 198, in runTest self.test(*self.arg) File &quot;G:\workstation\py_workstation\DataDriverTest\Testexec.py&quot;, line 17, in test_sum assert_equal(res, a+b)AssertionError: 5 != 3----------------------------------------------------------------------Ran 1 test in 0.007sFAILED (failures=1) 可以看出，断言失败了，控制台也打印出了断言失败的信息。但是在进行自动化测试过程中，如果你想加入日志模块，在执行过程中就在控制台或者文件中打印日志，例如：Testexec.test_sum ... 断言失败，3不等于5这样的信息，很明显，直接用上述写法是不会走到打印失败信息这一步，所以就需要将断言失败的异常捕获，类似这样：123456789101112#!/usr/bin/env python3# -*- coding: utf-8 -*-from nose.tools import assert_equaldef test_sum(): try: a = 1 b = 2 res = 5 assert_equal(res, a+b) except AssertionError as e: print(&quot;断言失败，&#123;0&#125;不等于&#123;1&#125;&quot;.format(a+b, res)) 这种写法执行单元测试，结果：12345678&#123;lamb&#125; nosetests -v -s Testexec.pyTestexec.test_sum ... 断言失败，3不等于5ok----------------------------------------------------------------------Ran 1 test in 0.002sOK 可以看见在断言失败的情况下，打印出了自定义的断言失败信息，这样也就满足进行自动化测试时，实时有日志生成，方便查看，但是这样有个问题，你一旦把断言失败的异常捕获了，那该条测试执行结果就是OK状态，到最后统计时候就不容易看出是哪条执行失败了，只能查看日志；而且日志中也没有展示具体在哪一行有报错，所以这样的方式需要改进。 打印堆栈信息在断言失败时，把异常捕获，此时不会展示具体断言错误的信息，所以就需要添加堆栈信息打印：123456789def test_sum(): try: a = 1 b = 2 res = 5 assert_equal(res, a+b) except AssertionError as e: logging.error(&quot;断言失败，&#123;0&#125;不等于&#123;1&#125;&quot;.format(a+b, res) + str(traceback.print_exc()) 这样就可以获取堆栈信息，可以查看具体哪一行有报错，但是，这样堆栈的日志也只会打印在控制台上，不利于查看，好traceback.print_exc()可以指定日志输出路径，所以只需要修改为：123456789def test_sum(): try: a = 1 b = 2 res = 5 assert_equal(res, a+b) except AssertionError as e: logging.error(&quot;断言失败，&#123;0&#125;不等于&#123;1&#125;&quot;.format(a+b, res) + str(traceback.print_exc(file=open(&apos;test.log&apos;, &apos;a&apos;)))) 这样就可以完成，错误日志打印到文件中，其中a表示append。 邮件附件在进行自动化测试时，我们经常不仅需要日志文件，更多用到的是测试报告，在自动化用例执行完成之后以邮件形式发送到指定邮箱，只需要查看邮件的附件，就可以知晓用例执行情况；但是使用unittest或者nose时，一旦把断言异常捕获，那该条用例结果就是ok状态，实际上我们知道这条用例其实是执行失败了，这样，使用HTMLTestRunner或者是nosetests --with-html --html-file生成的html文件中，用例执行状态就都是success状态，很显然是不正确的。 所以我考虑的是，自己写自定义的测试报告样式，定义一个状态标志status，初始状态为success，在用例执行过程中，一旦捕获了断言异常，就将状态更新为fail，在测试报告中，执行结果栏展示的是该状态，这样就可以实现结果查看了。 自定义测试报告样式。。现在还是只有这个想法，未完待续，待实现了再来更新！（前端知识匮乏啊，越来越觉得自己弱。。。） 断言捕获，可以生成日志，在屏幕和日志文件中打印显示，但是，这样，所有的单元测试都是通过状态，没有一条fail； 断言不捕获，直接邮件发送结果，可以在邮件中看出具体哪条用例执行失败，可以点开失败，查看具体失败信息]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nose执行顺序]]></title>
    <url>%2F2018%2F02%2F07%2Fnose%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[nose单元测试执行顺序 nose和unittest一样，都可以在用例中指定setUp()和tearDown()（用户测试初始化以及测试结束后的操作），在nose中，package、module、class都可以设置setup()和teardown()； package中设置在package中设置，整个测试的运行期间只会执行一次（新建python package时，会生成一个init.py文件，在其中设置setUp()以及tearDown()即可） 用例中每次都执行setup及teardown在模块、类中执行顺序示例：新建Testexec.py文件，内容：1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/7 10:39&quot;&quot;&quot;from nose.plugins.skip import SkipTestclass TestClass(): def setUp(self): print(&quot;=============-My Testcase is setup-===========&quot;) def tearDown(self): print(&quot;============My Testcase is teardown===========&quot;) def test_fun1(self): print(&quot;This is test_fun1*******&quot;) pass def test_fun2(self): print(&quot;This is test_fun2=====&quot;) pass def test_fun3(self): print(&quot;This is test_fun3~~~~~~~~~&quot;) raise SkipTest def test_Fun1(self): print(&quot;This is test_Fun1***====***&quot;) pass 命令行执行nosetests：1nosetests -v -s Testexec.py 执行结果：12345678910111213141516171819202122&#123;lamb&#125; nosetests -v -s Testexec.py Testexec.TestClass.test_Fun1 ... =============-My Testcase is setup-=========== This is test_Fun1***====*** ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun1 ... =============-My Testcase is setup-=========== This is test_fun1******* ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun2 ... =============-My Testcase is setup-=========== This is test_fun2===== ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun3 ... =============-My Testcase is setup-=========== This is test_fun3~~~~~~~~~ ============My Testcase is teardown=========== SKIP ---------------------------------------------------------------------- Ran 4 tests in 0.005s OK (SKIP=1) 可以看见在对每一个函数进行测试时，都执行了一次setUp()以及tearDown()；且用例执行顺序是：1test_Fun1 -&gt; test_fun1 -&gt; test_fun2 -&gt; test_fun3 其中test_fun3跳过了测试，执行顺序是按照先大写字母，再小写字母，然后再按阿拉伯数字排列的。 用例中只执行一次setup及teardown只需要在setUpClass()及tearDownClass()前加修饰器@classmethod即可：12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/7 10:39&quot;&quot;&quot;from nose.plugins.skip import SkipTestclass TestClass(): @classmethod def setUpClass(cls): print(&quot;只初始化一次setup=======&quot;) @classmethod def tearDownClass(cls): print(&quot;只teardown一次***********&quot;) def setUp(self): print(&quot;=============-My Testcase is setup-===========&quot;) def tearDown(self): print(&quot;============My Testcase is teardown===========&quot;) def test_fun1(self): print(&quot;This is test_fun1*******&quot;) pass def test_fun2(self): print(&quot;This is test_fun2=====&quot;) pass def test_fun3(self): print(&quot;This is test_fun3~~~~~~~~~&quot;) raise SkipTest def test_Fun1(self): print(&quot;This is test_Fun1***====***&quot;) pass 执行测试：1nosetests -v -s Testexec.py 执行结果：123456789101112131415161718192021222324&#123;lamb&#125; nosetests -v -s Testexec.py 只初始化一次setup======= Testexec.TestClass.test_Fun1 ... =============-My Testcase is setup-=========== This is test_Fun1***====*** ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun1 ... =============-My Testcase is setup-=========== This is test_fun1******* ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun2 ... =============-My Testcase is setup-=========== This is test_fun2===== ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun3 ... =============-My Testcase is setup-=========== This is test_fun3~~~~~~~~~ ============My Testcase is teardown=========== SKIP 只teardown一次*********** ---------------------------------------------------------------------- Ran 4 tests in 0.006s OK (SKIP=1) 可以看见，setUpClass()以及tearDownClass都只执行了一次。在自动化测试中，可用来加载配置信息，只需要加载一次即可。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python3的UI自动化框架搭建系列（一）]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%9F%BA%E4%BA%8Epython3%E7%9A%84UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基于python3搭建appium ui自动化测试框架尝试系列（一） 框架实现目标12345678910自动找设备，连接设备自动启动appium server使用yml编写用例配置信息储存在ini文件或conf文件中自定义log，断言失败截图用例框架使用unittest或者nose用例报告html，用例执行完成邮件发送，附件测试报告多线程执行用例，失败重跑机制android自动监控权限弹窗执行过程红性能捕获（adb或者其他形式） 基于ddt和nose的简单尝试当前我能实现的appium自动化测试还是需要手动去起appium server，这点后面需要改善，github上有很多已经实现了的框架，但是不是很想直接拿来用，还是希望能够自己去一点一点的搭建。 即使是简单的尝试，还是想尽量实现多模块。 配置模块邮箱配置：包含邮件收发件人，密码，服务器等信息配置；日志配置：包含日志级别，时间格式，流处理器等；文件夹创建：包含获取当前日期，时间，创建文件夹等； 其实在之前的博客中已经实现，就不再贴代码了： 邮箱配置日志配置 文件夹创建是为了在测试过程中，出现断言失败的场景进行截图保存，文件夹使用两层，上一层为当前日期，下一层为当前时间，截图保存名字为断言失败的名字：MakeDirs.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/7 10:17&quot;&quot;&quot;import time,osimport tracebackfrom datetime import datetime as dtdef getCurrentDate(): &quot;&quot;&quot;获取当前日期&quot;&quot;&quot; date = time.localtime() today = str(date.tm_year) + &quot;-&quot; + str(date.tm_mon) + &quot;-&quot; + str(date.tm_mday) return todaydef getCurrentTime(): &quot;&quot;&quot;获取当前时间&quot;&quot;&quot; time_str = dt.now() now = time_str.strftime(&apos;%H-%M-%S&apos;) return nowdef createDir(): &quot;&quot;&quot;获取当前文件所在路径绝对路径&quot;&quot;&quot; current_path = os.path.abspath(&apos;.&apos;) # 获取当前日期 today = getCurrentDate() # 构造以今天日期命名的目录的绝对路径 date_dir = os.path.join(current_path, today) print(date_dir) if not os.path.exists(date_dir): # 如果以今天日期命名的目录不存在则创建 os.mkdir(date_dir) # 获取当前时间字符串 now = getCurrentTime() # 构造以当前时间命名的目录的绝对路径 time_dir = os.path.join(date_dir, now) print(time_dir) if not os.path.exists(time_dir): # 如果以当前时间命名的目录不存在则创建 os.mkdir(time_dir) return time_dirdef takeScreenShot(driver, save_path, pic_name): &quot;&quot;&quot;截屏&quot;&quot;&quot; pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;) try: driver.get_screenshot_as_file(pic_path) except Exception as e: print(traceback.print_exc(), e) 执行模块实现思路是ddt获取数据对象，进行测试数据和代码分离，数据对象包含输入数据以及预期结果，对预期结果进行断言，实现测试实现。以百度搜索测试为例:DataDriverByObj.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env python3# -*- coding: utf-8 -*-import ddt,timeimport traceback,loggingfrom DdtTools.Log import *from selenium import webdriverfrom nose.tools import assert_truefrom selenium.common.exceptions import NoSuchElementExceptionfrom datetime import datetime as dtfrom DdtTools.MailSend import MailSend@ddt.ddtclass TestDDTByObj(): &quot;&quot;&quot;数据驱动测试&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; self.browser = webdriver.Chrome() @ddt.data( [u&quot;龙猫&quot;, &quot;宫崎骏&quot;], [u&quot;大话西游之月光宝盒&quot;, &quot;周星驰&quot;], [u&quot;卧虎藏龙&quot;, &quot;李安&quot;] ) @ddt.unpack def test_dataDrivenByObj(self, testdata, expectdata): url = &quot;https://www.baidu.com&quot; self.browser.get(url) # 隐式等待10s self.browser.implicitly_wait(10) try: # 定位搜索输入框，并输入测试数据 self.browser.find_element_by_id(&apos;kw&apos;).send_keys(testdata) # 定位搜索按键，单击 self.browser.find_element_by_id(&apos;su&apos;).click() time.sleep(3) # 断言期望结果是否出现在页面源码中 assert_true(expectdata in self.browser.page_source) except NoSuchElementException as e: logging.error(u&quot;查找的页面元素不存在，异常堆栈信息：&quot; + str(traceback.print_exc())) except AssertionError as e: info(u&quot;搜索：&#123;0&#125;，期望：&#123;1&#125;，失败&quot;.format(testdata, expectdata)) except Exception as e: logging.error(u&quot;未知错误，错误信息：&quot; + str(traceback.print_exc())) else: info(u&quot;搜索：&#123;0&#125;，期望：&#123;1&#125;，通过&quot;.format(testdata, expectdata)) time.sleep(2) self.browser.quit()if __name__ == &apos;__main__&apos;: # mail_subject, report_file mail_subject = &apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;)) report_file = &apos;D:/bug_things/selenium/report/DDTByObj.html&apos; mailsend = MailSend(mail_subject, report_file) print(&apos;开始执行自动化测试...&apos;) os.system(&apos;nosetests -v &#123;0&#125; --with-html --html-file=&#123;1&#125;&apos;.format(__file__, report_file)) # 发送测试报告邮件 print(&apos;开始发送测试报告...&apos;) mailsend.sendMail() print(&apos;测试报告发送完成...&apos;) 后记差不多现在还是实现到现在的程度，后面至少可以优化，测试数据从xls，xml，excel，mysql中读取。（感觉自己现在实现的还是好弱。。。） 附上github上已经实现的框架，供参考，建议还是自己去一点一点的搭建，直接用个人觉得是有点功利的做法了，写代码，还是慢慢来的好。 ATXAuto_AnalysisAPPIUM]]></content>
      <categories>
        <category>自动化测试框架</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>appium</tag>
        <tag>python3</tag>
        <tag>nose</tag>
        <tag>ddt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】python实现chrome伪装成M站]]></title>
    <url>%2F2018%2F02%2F06%2F%E3%80%90%E8%BD%AC%E3%80%91python%E5%AE%9E%E7%8E%B0chrome%E4%BC%AA%E8%A3%85%E6%88%90M%E7%AB%99%2F</url>
    <content type="text"><![CDATA[selenium实现Chrome伪装成M站，模拟手机端浏览器，并完成页面操作 原理：通过--user-agent=&quot;xxx&quot;来修改HTTP请求头部的Agent字符串，设置个人代理，使得PC端的Chrome浏览器伪装成手机浏览器，可以在地址栏输入”about:version”查看修改效果。 代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom Log import *import timeclass TestMobile(): &quot;&quot;&quot;测试chrome伪装成手机M站&quot;&quot;&quot; def test_iPadChrome(self): # 添加chrome设置 info(u&quot;===========伪装成ipad==========&quot;) info(u&quot;=====开始设置ipad个人代理=====&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0(iPad; CPU OS 5_0 like Mac OS X)&apos; &apos;AppleWebKit/534.46(KHTML, like Gecko) Version/5.1&apos; &apos;Mobile/9A334 Safari/7534.48.3&apos; ) browser = webdriver.Chrome(chrome_options=options) browser.get(&quot;https://www.baidu.com&quot;) time.sleep(3) browser.find_element_by_id(&apos;kw&apos;).send_keys(&quot;iPad&quot;) time.sleep(1) # 通过在Chrome浏览器地址栏输入about:version，查看伪装效果 browser.get(&quot;about:version&quot;) # 人工确认“用户代理”项配置信息是否和设置一致 time.sleep(10) info(u&quot;==========伪装ipad成功==========&quot;) browser.quit() def test_iPhoneChrome(self): # 添加chrome配置 info(u&quot;==========测伪装成iphone==========&quot;) info(u&quot;=====设置iphone个人代理=====&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0 (iPhone; CPU iPhone OS 5_0 like Mac OS X)&apos; &apos;AppleWebKit/534.46(KHTML, like Gecko) Version/5.1&apos; &apos;Mobile/9A334 Safari/7534.48.3&apos; ) browser = webdriver.Chrome(chrome_options=options) browser.get(&quot;https://www.baidu.com&quot;) time.sleep(3) # 定位搜索框 browser.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;iPhone&quot;) time.sleep(1) browser.get(&quot;about:version&quot;) time.sleep(10) info(u&quot;==========伪装成iphone成功==========&quot;) browser.quit() def testAndroid236Chrome(self): info(u&quot;==========测试伪装成android2.3.6==========&quot;) info(u&quot;=====设置android2.3.6个人代理=====&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0 (Linux; U; Android 2.3.5; en-us)&apos; &apos;Nexus S Build/GRK39F) AppleWebKit/533.1&apos; &apos;(KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&apos; ) brower = webdriver.Chrome(chrome_options=options) brower.get(&quot;https://www.baidu.com&quot;) # 定位搜索输入框 brower.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;Android 2.3.6&quot;) time.sleep(1) brower.get(&quot;about:version&quot;) time.sleep(10) info(u&quot;==========伪装成android2.3.6成功==========&quot;) brower.quit() def testAndroid402Chrome(self): info(u&quot;==========测试伪装成android4.0.2==========&quot;) info(u&quot;=====设置android4.0.2个人代理&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0 (Linux; U; Android 4.0.2;&apos; &apos;en-us; Galaxy Nexus Build/ICL53F) AppleWebKit/534.30&apos; &apos;(KHTML, like Gecko) Version/4.0 Mobile Safari/534.30&apos; ) browser = webdriver.Chrome(chrome_options=options) browser.get(&quot;http://www.baidu.com&quot;) time.sleep(3) browser.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;Android 4.0.2&quot;) time.sleep(1) browser.get(&quot;about:version&quot;) time.sleep(10) info(u&quot;==========伪装成android4.0.2成功==========&quot;) browser.quit()if __name__ == &apos;__main__&apos;: testmobile = TestMobile() testmobile.testAndroid402Chrome() testmobile.testAndroid236Chrome() testmobile.test_iPhoneChrome() testmobile.test_iPadChrome() 偶然看见这个实现，目前没想到应用场景。。直接使用appium进行移动自动化好像也能实现啊。。（可能工作中遇见的太少了）]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logging模块使用简介]]></title>
    <url>%2F2018%2F02%2F02%2Flogging%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[python3日志模块，logging使用简介 日志打印python3使用logging进行日志打印，很简单，直接引logging包即可：123456789import logginglogging.warning(&quot;This is warning message&quot;)logging.critical(&quot;This is critical message&quot;)logging.error(&quot;This is error message&quot;)# 打印结果WARNING:root:This is warning messageCRITICAL:root:This is critical messageERROR:root:This is error message 默认情况下只显示了大于等于WARNING级别的日志。日志级别：1critical(50) &gt; error(40) &gt; warning(30) &gt; info(20) &gt; debug(10) 简单应用通过logging.basicConfig函数对日志的输出格式及方式做相关配置1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-import logginglogging.basicConfig( filename=&apos;test.log&apos;, format=&apos;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H-%M-%S&apos;, level=logging.DEBUG, #level=10)logging.critical(&quot;This ia critical message&quot;)logging.error(&quot;This is error message&quot;)logging.warning(&quot;This is warning message&quot;)logging.info(&quot;This is info message&quot;)logging.debug(&quot;This is debug message&quot;) logging.basicConfig函数各参数 1.filename：指定日志文件名2.filemode：和file函数意义相同，指定日志文件的打开模式，’w’或’a’；默认为’a’表示“append”。3.format：指定输出的格式和内容，format可以输出很多有用信息： 12345678910111213141516format参数中可能用到的格式化串：%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息 4.datefmt：指定时间格式，同time.strftime()5.level：设置日志级别，默认为logging.WARNING6.stream：指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略 模块介绍若要对logging进行更多灵活的控制，必须了解Logger，Handler，Formatter，Filter的概念：logger提供了应用程序可以直接使用的接口；handle将（logger创建的）日志记录发送到合适的目的输出；filter提供了细度设备来决定输出哪条日志记录；formatter决定日志记录的最终输出格式； Logger每个程序在输出信息之前都要获得一个Logger。Logger通常对应了程序的模块名，比如聊天工具的图形界面模块可以这样获得它的Logger：LOG=logging.getLogger(”chat.gui”)而核心模块可以这样：LOG=logging.getLogger(”chat.kernel”) Logger.setLevel(lel):指定最低的日志级别，低于lel的级别将被忽略。debug是最低的内置级别，critical为最高Logger.addFilter(filt)、Logger.removeFilter(filt):添加或删除指定的filterLogger.addHandler(hdlr)、Logger.removeHandler(hdlr)：增加或删除指定的handlerLogger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()：可以设置的日志级别 Handlerhandler对象负责发送相关的信息到指定目的地。Python的日志系统有多种Handler可以使用。有些Handler可以把信息输出到控制台，有些Logger可以把信息输出到文件，还有些Handler可以把信息发送到网络上。如果觉得不够用，还可以编写自己的Handler。可以通过addHandler()方法添加多个多handlerHandler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略Handler.setFormatter()：给这个handler选择一个格式Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象 每个Logger可以附加多个Handler。接下来我们就来介绍一些常用的Handler： 1) logging.StreamHandler使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息。它的构造函数是:StreamHandler([strm])其中strm参数是一个文件对象。默认是sys.stderr 2) logging.FileHandler和StreamHandler类似，用于向一个文件输出日志信息。不过FileHandler会帮你打开这个文件。它的构造函数是：FileHandler(filename[,mode])filename是文件名，必须指定一个文件名。mode是文件的打开方式。参见Python内置函数open()的用法。默认是’a’，即添加到文件末尾。 3) logging.handlers.RotatingFileHandler这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。它的构造函数是：RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])其中filename和mode两个参数和FileHandler一样。maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。 4) logging.handlers.TimedRotatingFileHandler这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。它的构造函数是：TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。interval是时间间隔。when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：S 秒M 分H 小时D 天W 每星期（interval==0时代表星期一）midnight 每天凌晨 实例日志的一般操作顺序为：1.创建一个流类型handler用于输出日志到控制台(控制器)2.定义输出日志级别3.定义handler的输出格式formatter4.将handler添加到logging对象 同时输出日志到控制台和文件1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-import logginglogging.basicConfig( filename=&apos;test.log&apos;, format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H-%M-%S&apos;, level=10)# 定义一个StreamHandler(日志流处理器)，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象console = logging.StreamHandler()console.setLevel(logging.INFO)# 格式化，设置控制台的日志输出格式formatter = logging.Formatter(&apos;%(name)-12s: %(levelname)-8s %(message)s&apos;)# 定义控制器的日志输出格式console.setFormatter(formatter)# 将控制器添加到logging对象logging.getLogger(&apos;&apos;).addHandler(console)logging.critical(&quot;This is critical message&quot;)logging.error(&quot;This is error message&quot;)logging.warning(&quot;This is warning message&quot;)logging.info(&quot;This is info message&quot;)logging.debug(&quot;This is debug message&quot;) 配置文件用法类似于java中的log4j的logging.config，我们也可以自己配置logger.conf文件： Logger.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950###############################################[loggers]keys=root,example01,example02[logger_root]level=DEBUGhandlers=hand01,hand02[logger_example01]handlers=hand01,hand02qualname=example01propagate=0[logger_example02]handlers=hand01,hand03qualname=example02propagate=0###############################################[handlers]keys=hand01,hand02,hand03[handler_hand01]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stderr,)[handler_hand02]class=FileHandlerlevel=DEBUGformatter=form01args=(&apos;D:/bug_things/selenium/logs/AutoTest.log&apos;, &apos;a&apos;, &apos;utf-8&apos;)[handler_hand03]class=handlers.RotatingFileHandlerlevel=INFOformatter=form02args=(&apos;D:/bug_things/selenium/logs/AutoTest.log&apos;, &apos;a&apos;, 10*1024*1024, 5, &apos;utf-8&apos;)###############################################[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)sdatefmt=%a, %d %b %Y %H:%M:%S[formatter_form02]format=%(name)-12s: %(levelname)-8s %(message)sdatefmt=%Y %m %d %H %M %S 封装方法将配置文件中定义的日志打印的配置进行封装，生成debug，info，message方法：Log.py1234567891011121314151617181920#!/usr/bin/env python3# -*- coding: utf-8 -*-import logging.configlogging.config.fileConfig(&quot;Logger.conf&quot;)def debug(message): # 打印debug级别的日志方法 logging.debug(message)def warning(message): # 打印warning级别的日志方法 logging.warning(message)def info(message): # 打印info级别的日志方法 logging.info(message) 应用以百度搜索为例:BaiDu.py1234567891011121314151617181920212223242526272829#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom Log import *import timeclass TestBaiDuSearch(): def __init__(self): # 启动浏览器 self.browser = webdriver.Chrome() def test_baidu_search(self): info(u&quot;===================搜索====================&quot;) url = &quot;https://www.baidu.com&quot; self.browser.get(url) info(u&quot;访问百度首页&quot;) self.browser.find_element_by_id(&apos;kw&apos;).send_keys(u&quot;自动化测试&quot;) info(u&quot;在输入框中搜索关键字“自动化测试”&quot;) self.browser.find_element_by_id(&apos;su&apos;).click() info(u&quot;单击搜索按键&quot;) info(u&quot;=================测试执行结束================&quot;) time.sleep(3) self.browser.quit()if __name__ == &apos;__main__&apos;: testbaidu = TestBaiDuSearch() testbaidu.test_baidu_search() 执行BaiDu.py文件，在D:/bug_things/selenium/logs目录下会生成AutoTest.log日志文件，文件内容：12345Fri, 02 Feb 2018 17:10:52 Log.py[line:20] INFO ===================搜索====================Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 访问百度首页Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 在输入框中搜索关键字“自动化测试”Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 单击搜索按键Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO =================测试执行结束================ 同时控制台打印信息：12345root : INFO ===================搜索====================root : INFO 访问百度首页root : INFO 在输入框中搜索关键字“自动化测试”root : INFO 单击搜索按键root : INFO =================测试执行结束================ 参考文章]]></content>
      <categories>
        <category>python黑科技</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python3</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码简单总结]]></title>
    <url>%2F2018%2F02%2F02%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[python字符串和编码 首先，字符串是一种数据类型，我们还经常会用到，然后，最常见的字符串问题就是字符编码问题，经常会看见文件打开一堆乱码，然后手工转utf-8啥的。 字符编码计算机基础计算机能够处理的只有数字，所以其他类型的数据想要被计算机识别并处理，首先要进行的就是字符编码，转换成数字之后处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是(11111111,二进制的255)，如果要表示更大的整数，就必须更多的字节，比如两个字节可以表示最大整数是65535。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 字库表字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。 字符集字符集是一个系统支持的所有抽象字符的集合。常见的字符集有ASCII，UTF-8，UTG-16，GB2313等。 字符编码字符编码可以看成是一套规则，目的就是在符号集合和数字系统直接建立对应关系。常见的字符编码有Unicode，ASCII，UTF-8等 三者关系字库表可以看成是一个全球统一的可读可用的字符库，但是实际使用过程中，很少需要用到这么多字符，例如，中文系统基本就用不到日文的字符，所以也就不需要日文字符的那一部分集合；因此就会诞生一个个的类似于定制的字符集合，这就是字符集，集合中包含了数据和字母的一个个对应关系，这就是字符编码。以ASCII为例： ASCIIASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。它是现今最通用的单字节编码系统（但是有被Unicode追上的迹象），并等同于国际标准ISO/IEC 646。 ASCII字符集：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 ASCII编码：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。 python字符编码ASCII是出现比较早的字符编码，但是其中只包含了数字和英文大小写字符，对于中文，日文等字符就不适用了，国内学者为了能够完成中文编码，就指定了GB2312编码，同样的，很多国家都有指定自己的编码，这样就会遇到一个问题，中文编码到日文编码的环境查看，会发生乱码，因为根本就不支持这样的字符，为了解决这个问题，一个统一的编码就诞生了Unicode，Unicode编码不同于ASCII的使用一个字节表示一个字符，它使用的是两个字节表示一个字符（中文至少需要两个字节），生僻字符就需要4个字符。字母’A’用ASCII编码，十进制是65，二进制是01000001；用Unicode编码结果是00000000 01000001。当全部都使用Unicode编码时，乱码问题肯定是得到解决了，但是有个问题，Unicode编码时连个字节表示的一个字符，那么就会比原来使用ASCII编码多出了至少一倍的内存空间占用，怎么都觉得很亏。所以，为了节约内存空间，又出现了把Unicode编码转换为“可变长编码”的utf-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。 下面来弄清楚python的字符编码：在python3中，字符串是以Unicode编码的，也就是说，支持多语言。由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示：1x = b&apos;ABC&apos; 注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 编码及解码首先python使用的是Unicode编码，字符串进行网络或者磁盘存储时，需要先编码成指定类型bytes，使用encode()方法即可。例如：12print(&apos;中文&apos;.encode(&apos;utf-8&apos;))b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 反过来，从网络或者磁盘上读取字节流，那么读到的数据是bytes，要把bytes转换为str，就需要使用decode()方法进行解码，例如：12print(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;))中文 在进行日常python编程中，在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上:12#!/usr/bin/env python3# -*- coding: utf-8 -*- pycharm设置方法：File-Settings-Editor-File and Code Templates-Python Script设置中添加上这两行即可。 以前曾经写过一篇博，关于设置python编码的:python编码 参考链接 廖雪峰的python教程字符集合字符编码 后记：由于昨天公司发生的很无语加无理取闹的一些事，整个办公室氛围都是压抑的，网上的教程资料也没怎么细致的看进去，写出来的总结也就是乱七八糟的，估计静下来之后我自己都看不懂。。。以后再来修改吧。唉，做技术的，干嘛不追求技术的进步，弄一些有的没的办公室政治呢，有意思吗？]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现断言失败截图]]></title>
    <url>%2F2018%2F02%2F02%2F%E5%AE%9E%E7%8E%B0%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5%E6%88%AA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[python基于selenium进行自动化测试，实现断言失败进行截图 进行自动化测试过程中，经常会遇见断言失败，时候补查失败的场景，要么是保存日志，要么就是保存失败的截图。尝试实现，在断言失败时候，加入实时截图： 编码出错遇到问题：截图文件名编码格式转换时候，会报错（以下写法在python 2.7可以使用）1pic_path = os.path.join(save_path, str(pic_name).decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;) + &quot;.png&quot;) 报错：1AttributeError: &apos;str&apos; object has no attribute &apos;decode&apos; 查找原因：既然python 2.7可以正常执行，那就应该是python 3对于编码进行了变更。 Stack Overflow上大家好像都是经常踩我踩过的所有坑..又找到答案了：这位大哥的回答：1234Begin with Python 3, all string is unicode object. a = &apos;Happy New Year&apos; # Python 3 b = unicode(&apos;Happy New Year&apos;) # Python 2the code before are same. So I think you should remove the .decode(&apos;utf-8&apos;). Because you have already get the unicode object. python3的普通字符串是str，所以python3的str就相当于python2的Unicode。大致意思好像就是python3使用的str类型并不关心你最终是什么编码，无论是utf-8还是gb2312，它只是用Unicode字符集编码来表示每一个字符，直到输出到文件流，需要转换为bytes类型时，才用encode指定具体的编码实现方式。 python的中间编码是Unicode，所以python2就需要先进行解码（decode）到中间编码，再进行编码（encode）到指定编；，而python3直接可以转换到指定编码（encode）1在python3中，str-- encode -&gt; bytes-- decode -&gt; str python3编码系统编码123456789101112import sys# 系统默认编码print(sys.getdefaultencoding())# 字符串编码s = &quot;中文&quot;s_utf8 = s.encode(&apos;utf-8&apos;)print(type(s))print(type(s_utf8))utf-8&lt;class &apos;str&apos;&gt;&lt;class &apos;bytes&apos;&gt; 可以看到，python3的系统编码就是utf-8，为了避免自找麻烦，牢记使用utf-8即可！所以上述报错代码可以更改为：1pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;) 断言失败截图实例实现目标是在进行自动化测试过程中，一旦发生断言失败，就根据当前时间，在工程下创建名称为当前日期的目录，，目录下创建名称为当前时间的文件夹，文件夹中保存断言失败的屏幕截图 获取当前日期和时间123456789101112131415161718192021#!/usr/bin/env python3# -*- coding: utf-8 -*-import timefrom datetime import datetime as dt&quot;&quot;&quot;用于获取当前的日期以及时间用于生成保存截图文件目录名&quot;&quot;&quot;def current_date(): date = time.localtime() # 构造今天的日期字符串 today = str(date.tm_year) + &quot;-&quot; + str(date.tm_mon) + &quot;-&quot; + str(date.tm_mday) return todaydef current_time(): time_str = dt.now() # 构建当期时间字符串 now = time_str.strftime(&apos;%H-%M-%S&apos;) return now 创建目录和文件夹123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- coding: utf-8 -*-from DateUtil import current_time, current_dateimport os&quot;&quot;&quot;用于创建目录，用于存放异常截图&quot;&quot;&quot;def create_dir(): # 获得当前文件所在目录的绝对路径 current_path = os.path.abspath(&apos;.&apos;) # 获取今天的日期字符串 today = current_date() # 构造以今天日期命名的目录的绝对路径 date_dir = os.path.join(current_path, today) print(date_dir) if not os.path.exists(date_dir): # 如果以今天日期命名的目录不存在则创建 os.mkdir(date_dir) # 获取当前的时间字符串 now = current_time() # 构造以当前时间命名的目录的绝对路径 time_dir = os.path.join(date_dir, now) print(time_dir) if not os.path.exists(time_dir): # 如果以当前时间命名的目录不存在则创建 os.mkdir(time_dir) return time_dir 百度搜索示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom FileUtil import create_dirfrom nose.tools import assert_trueimport time,osimport traceback# 创建存放异常截图的目录，并得到本次实例中存放图片目录的绝对路径，作为全局变量，供本次所有测试用例调用pic_dir = create_dir()def take_screenshot(driver, save_path, pic_name): # 封装截屏方法 # 构造屏幕截图路径及图片名 # 因为windows默认编码是GBK，而传入的图片名是utf-8编码，所以需要进行转码，以便让图片名中的中文字符能够正常显示 pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;) try: # 调用webdriver提供的get_screenshot_as_file()方法，将截取的屏幕图片保存为本地文件 driver.get_screenshot_as_file(pic_path) except Exception as e: print(traceback.print_exc(), e)class TestFailCaptureScreen(): def __init__(self): &quot;&quot;&quot;启动浏览器&quot;&quot;&quot; self.browser = webdriver.Chrome() def test_baidu_search(self): url = &quot;https://www.baidu.com&quot; self.browser.get(url) try: self.browser.find_element_by_id(&apos;kw&apos;).send_keys(u&quot;自动化测试&quot;) self.browser.find_element_by_id(&apos;su&apos;).click() time.sleep(3) # 断言页面的代码中是否存在“自动化测试框架_百度百科”这几个字 assert_true(u&quot;纯净方糖&quot; in self.browser.page_source) # 页面中没有断言的几个字，所以会触发except语句的执行，并触发截图操作 except AssertionError as e: take_screenshot(self.browser, pic_dir, e) except Exception as e: take_screenshot(self.browser, pic_dir, e) time.sleep(2) self.browser.quit()if __name__ == &apos;__main__&apos;: testfailscreen = TestFailCaptureScreen() testfailscreen.test_baidu_search() 感觉是时候研究一波python字符编码了…]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现自动化测试数据分离]]></title>
    <url>%2F2018%2F02%2F01%2F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[使用数据分离自动化测试，测试执行完成自动邮件发送 配置文件配置文件中的内容为工程所有配置信息，各个模块的元素定位的方法以及值，服务器（应用服务器和数据库服务器）配置信息，用户账号密码等信息 实例，cashier.ini 1234567891011121314[login]storeNo = id &gt; com.anmav.cashierdesk:id/etStoreNousername = id &gt; com.anmav.cashierdesk:id/login_accountEdtpwd = id &gt; com.anmav.cashierdesk:id/login_paswEdtlogin = id &gt; com.anmav.cashierdesk:id/tvLoginlogin_store = ***login_user = ***login_pwd = ***[mailmsg]mail_user = ***mail_pwd = ***mail_to = ***mail_host = *** 该配置文件包含了login模块进行元素定位需要的方法以及值，在工程中进行元素定位值，只需要使用configparser模块完成配置文件读取即可。 邮件发送数据分离封装数据分离之后的邮件发送类(MailSend.py)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python3# -*- coding: utf-8 -*-from email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartimport smtplibimport configparserimport osclass MailSend(): &quot;&quot;&quot;邮件发送&quot;&quot;&quot; def __init__(self, mail_subject, report_file): self.mail_subject = mail_subject self.report_file = report_file self.settings = os.path.abspath(&apos;..&apos;) + &quot;\cashier_conf\cashier_setting.ini&quot; def send_mail(self): &quot;&quot;&quot;读取测试报告&quot;&quot;&quot; cf = configparser.ConfigParser() cf.read(self.settings) cf.sections() # 获取邮箱发件人，密码，收件人，邮件服务器 mail_user = cf.get(&apos;mailmsg&apos;, &apos;mail_user&apos;) mail_pwd = cf.get(&apos;mailmsg&apos;, &apos;mail_pwd&apos;) mail_to = cf.get(&apos;mailmsg&apos;, &apos;mail_to&apos;) mail_host = cf.get(&apos;mailmsg&apos;, &apos;mail_host&apos;) # 发送邮件配置 with open(self.report_file, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f_obj: content = f_obj.read() msg = MIMEMultipart(&apos;mixed&apos;) # 添加邮件内容 msg_html = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg.attach(msg_html) # 添加附件 msg_attachment = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg_attachment[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&#123;0&#125;&apos;.format(self.report_file) msg.attach(msg_attachment) msg[&apos;Subject&apos;] = self.mail_subject msg[&apos;Form&apos;] = mail_user msg[&apos;To&apos;] = mail_to try: # 连接邮箱服务器 s = smtplib.SMTP() s.connect(mail_host) # 登录 s.login(mail_user, mail_pwd) # 发送邮件 s.sendmail(mail_user, mail_to, msg.as_string()) s.quit() except Exception as e: print(&quot;发送邮件异常：&quot;, e) 元素定位数据分离封装了元素定位的方法（find_element_by…），实现在工程中进行元素定位时，直接调用方法(GetElement.py)：123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium.webdriver.support.ui import WebDriverWaitimport osimport configparserimport tracebackclass GetElement(): &quot;&quot;&quot;获取元素定位方法和值&quot;&quot;&quot; def __init__(self): # 读取配置文件 self.settings = os.path.abspath(&apos;..&apos;) + &quot;/cashier_conf/cashier_setting.ini&quot; self.cf = configparser.ConfigParser() self.cf.read(self.settings) self.cf.sections() def get_elementId(self, driver, webSiteName, webelement): try: # 获取配置文件中的定位方法以及定位元素 webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;) webelement_method = webElemnt[0].strip() webelement_expression = webElemnt[1].strip() element = WebDriverWait(driver, 10).until\ (lambda x: x.find_element(webelement_method, webelement_expression)) except Exception as e: print(traceback.print_exc(), e) else: return element 自动化测试实现数据分离使用数据分离的方式完成系统登录的自动化测试，方便维护，后期只需要维护cashier_setting.ini文件即可(testlogin.py)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparser, osimport tracebackfrom datetime import datetime as dtfrom appium import webdriverfrom nose.tools import assert_truefrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.common.exceptions import NoSuchElementException,TimeoutExceptionfrom cashier_tools.GetElement import GetElementfrom cashier_tools.MailSend import MailSendclass Login(): &quot;&quot;&quot;登录&quot;&quot;&quot; def __init__(self): # 初始化，配置环境 self.desired_caps = &#123;&#125; self.desired_caps[&apos;platformName&apos;] = &apos;Android&apos; self.desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos; self.desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos; self.desired_caps[&apos;noReset&apos;] = True self.desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos; self.desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.login.activity.LoginActivity&apos; self.driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, self.desired_caps) self.elementid = GetElement() def test_login(self): settings = os.path.abspath(&apos;..&apos;) + &quot;/cashier_conf/cashier_setting.ini&quot; cf = configparser.ConfigParser() cf.read(settings) cf.sections() # 定位门店编号输入框 storeno = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;storeNo&apos;) storeno.click() storeno.clear() store_no = cf.get(&apos;login&apos;, &apos;login_store&apos;) storeno.send_keys(store_no) self.driver.hide_keyboard() # 定位用户名 username = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;username&apos;) username.click() username.clear() user = cf.get(&apos;login&apos;, &apos;login_user&apos;) username.send_keys(user) self.driver.hide_keyboard() # 定位密码 pwd = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;pwd&apos;) pwd.click() pwd.clear() password = cf.get(&apos;login&apos;, &apos;login_pwd&apos;) pwd.send_keys(password) self.driver.hide_keyboard() # 登录 self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;login&apos;).click() try: # 显示等待，门店名称出现 WebDriverWait(self.driver, 10).until(lambda x:x.find_element_by_id(cf.get(&apos;order&apos;, &apos;store_name&apos;))) # 断言登录成功 assert_true(u&quot;点餐&quot; in self.driver.page_source) except NoSuchElementException as e: print(traceback.print_exc(), e) except TimeoutException as e: print(traceback.print_exc(), e)if __name__ == &apos;__main__&apos;: mail_subject = &apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;)) report_file = &apos;Login.html&apos; mailsend = MailSend(mail_subject, report_file) print(&apos;开始执行自动化测试...&apos;) os.system(&apos;nosetests -v &#123;0&#125; --with-html --html-file=&#123;1&#125;&apos;.format(__file__, report_file)) # 发送测试报告邮件 print(&apos;开始发送测试报告...&apos;) mailsend.send_mail() print(&apos;测试报告发送成功&apos;) 单独的邮件发送模块可参照之前一篇：python实现自动化测试报告邮件实时发送]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
        <tag>数据分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】python元类介绍]]></title>
    <url>%2F2018%2F01%2F31%2F%E3%80%90%E8%BD%AC%E3%80%91python%E5%85%83%E7%B1%BB%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[python元类 转自stackoverflow 神级人物e-satis的神级回复，以及国内翻译组汉化结果： 写在前面：经常在stackoverflow上看见一些神一般的回答，也看到过很多次创建Foo类，特意上维基百科搜了，解释如下：123foobar是计算机程序领域里的术语炒作，并无实际用途和参考意义。 在计算机程序设计与计算机技术的相关文档中，术语foobar是一个常见的无名氏化名，常被作为“伪变量”使用。单词“foobar”或分离的“foo”与“bar”常出现于程序设计的案例中，如同Hello World程序一样，它们常被用于向学习者介绍某种程序语言。“foo”常被作为函数／方法的名称，而“bar”则常被用作变量名。 正题类也是对象（Classes as objects）在理解元类之前，需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：123456class ObjectCreator(object): passmy_object = ObjectCreator()print(my_object)&lt;__main__.ObjectCreator object at 0x000001899B36E550&gt; 但是python中的类远不止如此。类同样也是一种对象 这个对象（类）自身用创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它本质上仍然是一个对象，所以，你可以对它进行如下操作：1、将它赋值给一个变量2、拷贝它3、为它增加属性4、将它作为函数参数进行传递 示例：12345678910111213141516171819202122class ObjectCreator(object): pass# 打印一个类，因为它其实也是一个对象print(ObjectCreator)&lt;class &apos;__main__.ObjectCreator&apos;&gt;# 将类作为参数传给函数def echo(o): print(o)echo(ObjectCreator)&lt;class &apos;__main__.ObjectCreator&apos;&gt;# 为类增加属性print(hasattr(ObjectCreator, &apos;new_attribute&apos;))ObjectCreator.new_attribute = &apos;foo&apos;print(hasattr(ObjectCreator, &apos;new_attribute&apos;))print(ObjectCreator.new_attribute)FalseTruefoo# 将类赋值给一个变量ObjectCreatorMirror = ObjectCreatorprint(ObjectCreatorMirror())&lt;__main__.ObjectCreator object at 0x000002C21DF1E550&gt; 动态地创建类因为类也是对象，你可以在运行时动态地创建它们，就想其他任何时候一样。首先，你可以在函数中创建类，使用class关键字即可。1234567891011121314def choose_class(name): if name == &apos;foo&apos;: class Foo(object): pass return Foo else: class Bar(object): pass return BarMyClass = choose_class(&apos;foo&apos;)print(MyClass)print(MyClass())&lt;class &apos;__main__.choose_class.&lt;locals&gt;.Foo&apos;&gt;&lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x000002B57928B518&gt; 但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是用过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象，但就和python中的大多数事情一样，python仍然提供给你手动处理的方法。內建函数type，可以让你知道一个对象的类型是什么：12345678print(type(1))print(type(&quot;1&quot;))print(type(ObjectCreator))print(type(ObjectCreator()))&lt;class &apos;int&apos;&gt;&lt;class &apos;str&apos;&gt;&lt;class &apos;type&apos;&gt;&lt;class &apos;__main__.ObjectCreator&apos;&gt; 这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类（同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后的兼容性） type可以像这样工作：1type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称知道）) 比如如下的代码：12class MyShinyClass(object): pass 可以手动像这样创建：123456# 返回一个对象MyShinyClass = type(&apos;MyShinyClASS&apos;, (), &#123;&#125;)print(MyShinyClass)print(MyShinyClass())&lt;class &apos;__main__.MyShinyClASS&apos;&gt;&lt;__main__.MyShinyClASS object at 0x00000214ED6FE5F8&gt; type接受一个字典来为类定义属性，因此12class Foo(object): bar = True 可以翻译为：1Foo = type(&apos;Foo&apos;, (), &#123;&apos;bar&apos;:True&#125;) 并且可以将Foo当做一个普通的类一样使用：123456789print(Foo)print(Foo.bar)f = Foo()print(f)print(f.bar)&lt;class &apos;__main__.Foo&apos;&gt;True&lt;__main__.Foo object at 0x000002C77F0FD4E0&gt;True 当然，你可以向这个类继承，所以，如下的代码：12class FooChild(Foo): pass 就可以写成：123FooChild = type(&apos;FooChild&apos;, (Foo,), &#123;&#125;)print(FooChild)print(FooChild.bar) 到底什么是元类元类就是用来创建类的“东西”，你创建类就是为了创建类的实例对象，但是我们知道python中的类也是对象，而元类就是用来创建这些类（对象）的，所以，元类就是类的类，可以这样理解：12MyClass = MetaClass()MyObject = MyClass() 你可以看到了type可以让你像这样做：1MyClass = type(&apos;MyClass&apos;, (), &#123;&#125;) 这是因为函数type实际上是一个元类，type就是python背后用来创建所有类的元类，所以type为什么不写成Type也就知道了吧，或许就是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type即使创建类对象的类。你可以通过class属性来看到这一点。Python中的所有的东西，注意，所有的东西——都是对象。这包含整数、字符串、函数和类。它们都是对象，而且它们都是从一个类创建来的。 12345678910age = 24print(age.__class__)name = &apos;bob&apos;print(name.__class__)def foo(): passprint(foo.__class__)&lt;class &apos;int&apos;&gt;&lt;class &apos;str&apos;&gt;&lt;class &apos;function&apos;&gt; 现在，对于任何一个class的class属性又是什么呢？123456print(age.__class__.__class__)print(name.__class__.__class__)print(foo.__class__.__class__)&lt;class &apos;type&apos;&gt;&lt;class &apos;type&apos;&gt;&lt;class &apos;type&apos;&gt; 因此，元类就是窗累类这种对象的东西，如果你喜欢的话，可以把元类称谓”类工厂”（不是工厂类）,type就是python內建的元类，当然了，你也可以创建自己的元类。 __metaclass__属性你可以在写一个类的时候为其添加metaclass属性。 123class Foo(object): __metaclass__ = somethind,.,[...] 如果你这么做了，python就会用元类来创建类Foo。这里面有技巧，你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它创建类Foo，如果没找到，就会用內建的type来创建这个类。 当你写下如下代码时：12class Foo(Bar): pass Python做了如下的操作： Foo中有__metaclass__这个属性吗？如果有，python会在内存中通过__metaclass__创建一个名字为Foo的类对象（注意是类对象）。如果python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果python在任何父类中都找不到__metaclass__，它就会在模块层面中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__，python就会用内置的type来创建这个类对象。 现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案是：可以是可以创建一个类的东西。那什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东西都可以。 自定义元类元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定你的模块里所有的类的属性都应该是大写形式，有好几种方法可以实现，单其中一种就是通过在模块级别设定__metaclass__，采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改写成大写形式就解决了。 幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我们都知道，名字里面带’class’的东西，并不一定是个class） 我们这里先以一个简单的函数作为例子开始：12345678910111213141516171819202122232425# 元类会自动将你通常传给&apos;type&apos;的参数作为自己的参数传入def upper_attr(future_class_name, future_class_parents, future_class_attr): &quot;&quot;&quot; 返回一个类对象，将属性都转为大写形式 &quot;&quot;&quot; # 识别所有不以&apos;__&apos;开头的属性，将它转换为大写 uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # type创建这个类 return type(future_class_name, future_class_parents, uppercase_attr)# 这行会影响模块中的所有类__metaclass__ = upper_attrclass Foo(): # 全局 __metaclass__不会和&apos;object&apos;一起生效，但是我们可以在这里定义__metaclass__来只对这个类生效 bar = &apos;bip&apos;print(hasattr(Foo, &apos;bar&apos;))print(hasattr(Foo, &apos;BAR&apos;)) 现在让我们再做一次，这一次用一个真正的class来当元类123456789101112131415161718192021# 请记住，&apos;type&apos;实际上是一个类，就像&apos;str&apos;和&apos;int&apos;一样# 所以，你可以从type继承class UpperAttrMetaclass(type): # __new__ 是在 __init__之前被调用的特殊方法 # __new__是用来创建对象并返回的方法 # __init__只是用来把传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type(future_class_name, future_class_parents, uppercase_at 但是这不是OOP（Object-oriented programming，面向对象编程）。我们直接调用了type，而且我们没有改写父类的new方法。现在，我们这样去处理：12345678910111213141516class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # 复用type.__new__方法 # 这就是基本的OOP编程，没什么魔法 return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr) 你可以已经注意到了有个额外的参数uppersttr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就想在普通的类方法中的self参数一样。当然了，为了清晰起见，这边将名字起的比较长。但是就想self一样，所有的参数都有它们的传统名称。因此，在真是的产品代码中一个元类应该像这样：123456789101112class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = &#123;&#125; for name, val in dct.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type.__new__(cls, clsname, bases, uppercase_attr) 如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）123456789101112class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = &#123;&#125; for name, val in dct.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr) 就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒不是因为元类本身，二十因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑魔法”是特别有用的，因而会搞出些复杂的东西来。但是元类本身而言，它们其实是很简单的： 1，拦截类的创建2，修改类3，返回修改之后的类 为什么要用metaclass类而不是函数由于__metaclass__可以接受任何可调用的对象，那为什么还要使用类呢，因为很显然使用类会更加复杂，这里有好几个原因： 1，意图会更加清晰，当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么2，你可以使用OOP编程。元类可以从元类中继承，改写父类方法，甚至可以使用元类3，你可以把代码组织的更好，当你使用元类的时候肯定不会像上述的简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。4，你可以使用__new__，__init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服点。 究竟为什么要使用元类现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，根本用不上它： “元类就是深度的魔法，99%的用户根本不必为此操心。如果你想搞清楚究竟是否需要用来元类，那么你就不需要它。那么实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类” ——Python界的领袖Tim Peters 元类的主要用途是创建API，一个典型的例子是Django ORM。它允许你像这样定义：123class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() 但是如果你像这样做的话：12guy = Person(name=&apos;bob&apos;, age=&apos;35&apos;)print guy.age 这并不会返回一个IntegerFied对象，而是会放回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__，并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 结语首先，你知道了类其实是能够创建出类实例的对象。事实上，类本身也是实例，当然，它们是元类的实例：1234class Foo(object): passprint(id(Foo))1973075749880 Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：12Monkey patchingclass decorators 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然，其实在99%的时间里你根本就不需要动态修改类。 原链接 stackoverflow原链接国内翻译站]]></content>
      <categories>
        <category>python黑科技</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS重建记]]></title>
    <url>%2F2018%2F01%2F24%2FVPS%E9%87%8D%E5%BB%BA%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[VPS重新部署日常环境，及hexo博客快速重建 VPS受灾记大早上来发现stackoverflow首页都打不开，对于天天科学上网的我来说，简直莫名其妙。 本地网络原因本地windows PC机，控制台ping IP：1ping VPS_IP 直接就超时了，匪夷所思。。VPS服务器 ping自己：1ping 127.0.0.1 好歹能通，那就是中间路由断了。 手机下载个网络工具，尝试在手机端ping VPS的IP（排除公司DNS搞的鬼），手机上ping也直接超时了，好吧，可以去检查是不是在某个不知名的时候自己把防火墙开了，还把22等端口关了。。 VPS排查我的VPS是在LA的CENTOS7主机，centos7查看防火墙状态：1firewall-cmd --state 发现是关着的。。。为了排除自己之前装过iptables的服务，查看iptables.service：1systemctl status iptables.service 这个果然是开着的，查看启用的端口：1cat /etc/sysconfig/iptables 该开的端口也都开了，好吧，无语了。 大环境排查基于大家都懂的网络环境，怀疑是IP被墙了，检测：1http://ping.chinaz.com 果然，除了香港和国外，其他都ping不通VPS，好吧，可以下结论了:IP被墙了… 真的很想骂人啊！到底是哪个JR没事瞎玩，搞出个异常流量，害的无辜躺枪！！！hexo还在VPS上，小飞机也在VPS上，没有梯子，科学上网个鬼啊！！！ 骂人几轮，该弄得还是得弄，方案嘛，无非就是换IP，还好Vultr重建台服务还是很方便的。 VPS重建Vultr重买服务器，这次比较幸运，居然有$2.5的，直接买：Vultr官网拿到IP之后，第一件事，肯定是ping IP，还好，可以ping通，就是你了！ VPS简单设置 防火墙设置xshell远程连接上VPS之后，习惯性操作，第一步，更新yum1yum update firewall设置由于centos7默认的防火墙服务时firewalld的，很不习惯，改！ 查看防火墙状态1firewall-cmd --state 关闭防火墙1systemctl stop firewalld.service 禁止开机启动启动防火墙1systemctl disable firewalld.service iptables设置安装iptables服务：1yum install iptables-services 开启iptables防火墙:1systemctl start iptables.service 开启特定端口：编辑文件：/etc/sysconfig/iptables，加入想要开放的端口即可，例如开放8090端口：1-A INPUT -p tcp -m tcp --dport 8090 -j ACCEPT 保存，退出之后，重启防火墙完成设置:1systemctl restart iptables.service ShadowsocksR（小飞机）配置科学上网必不可少的工具，ShadowsocksR 安装：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 完成配置：12345服务器端口：自己设定（如不设定，默认为 8989）密码：自己设定（如不设定，默认为 teddysun.com）加密方式：自己设定（如不设定，默认为 aes-256-cfb）协议（Protocol）：自己设定（如不设定，默认为 origin）混淆（obfs）：自己设定（如不设定，默认为 plain） 附上我的配置，仅供参考：123456Your Server IP : ***.***.***.*** Your Server Port : ***** Your Password : ******* Your Protocol : auth_sha1_v4 Your obfs : tls1.2_ticket_auth Your Encryption Method: aes-256-cfb 配置完成之后就可以在本地PC机使用客户端进行梯子配置，完了就可以科学上网啦！！！客户端度娘盘链接 Hexo重建预备动作：原来VPS上面的hexo所在目录，直接打成压缩包scp出来 安装node.js首先安装gcc用于编译：1yum -y install gcc gcc-c++ kernel-devel 开始安装node.js12wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gztar -xf node-v4.5.0.tar.gz 解压缩之后，进入目录，编译：1234cd node-v4.5.0./configuremakemake install 完成！验证：12node -vnpm 安装完成的是4.5的版本，升级：12npm install -g nn stable 安装git由于买的VPS已经集成了git，所以怎么安装，怎么配置环境变量啥的就不废话了。1、VPS设置git：12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 邮箱和用户名都对应于github 2、生成ssh秘钥1ssh-keygen -t rsa -C example@163.com 默认保存路径是/root/.ssh下：1cat /root/.ssh/id_rsa.pub 获取秘钥，然后到github的web页面将秘钥配置进去，完成！ 安装hexo1、安装hexo创建目录1mkdir blog 安装1234cd blognpm install -g hexo-cli#初始化hexo init 2、安装插件12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 3、修改Hexo配置文件，完成！ 或者，直接把原来VPS上面hexo的压缩包解压，再配置安装hexo即可1npm install hexo --save 环境测试12hexo new &quot;安装测试&quot;hexo g -d 执行不报错，进入博客可以看见安装测试该文章，部署成功！ 真的是坑啊，又重布环境，国内的网络环境啊，ε=(´ο｀*)))唉~ 参考链接 centos搭建hexo博客]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现自动化测试报告邮件实时发送]]></title>
    <url>%2F2018%2F01%2F23%2Fpython%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E9%82%AE%E4%BB%B6%E5%AE%9E%E6%97%B6%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[实现自动化用例执行完成之后，自动发送带html附件的邮件到邮箱 实现思路：读取html附件内容，添加到邮件正文中，添加html附件，实现用例执行完成，测试报告自动发送到邮箱。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env python3# -*- coding: utf-8 -*-import osimport smtplibfrom datetime import datetime as dtfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom nose.tools import assert_equaldef send_mail(): &quot;&quot;&quot;读取测试报告&quot;&quot;&quot; with open(report_file, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f_obj: content = f_obj.read() msg = MIMEMultipart(&apos;mixed&apos;) # 添加邮件内容 msg_html = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg.attach(msg_html) #添加附件 msg_attachment = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg_attachment[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;&#123;0&#125;&quot;&apos;.format(report_file) msg.attach(msg_attachment) msg[&apos;Subject&apos;] = mail_subject msg[&apos;Form&apos;] = mail_user msg[&apos;To&apos;] = mail_to try: # 连接邮件服务器 s = smtplib.SMTP() s.connect(mail_host) # 登录 s.login(mail_user, mail_pwd) # 发送邮件 s.sendmail(mail_user, mail_to, msg.as_string()) # 退出 s.quit() except Exception as e: print(&quot;Exception&quot;, e)class Mailsend(): def test_mul(self): a = 1 b = 2 res = 3 assert_equal(res, a+b)if __name__ == &apos;__main__&apos;: # 邮件服务器 mail_host = &apos;smtp.163.com&apos; # 发件人地址 mail_user = &apos;***&apos; # 发件人密码 mail_pwd = &apos;***&apos; # 邮件标题 mail_subject = u&apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;)) # 收件人地址 mail_to = &apos;***&apos; # 测试报告名称 report_file = &apos;NoseTestReport.html&apos; # 运行nosetests进行自动化测试并生成测试报告 print(&apos;Run NoseTests Now...&apos;) os.system(&apos;nosetests -v mail_html.py:Mailsend --with-html --html-file=NoseTestReport.html&apos;) # 发送测试报告邮件 print(&apos;Send Test Report Mail Now...&apos;) send_mail() tips:123python客户端进行163,126邮箱邮件发送前，需要在web版邮箱中设置允许客户端访问，设置客户端授权码设置完授权码之后，此时的客户端登录密码为授权码，不是原来的邮箱密码]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>smtplib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分离]]></title>
    <url>%2F2018%2F01%2F20%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[python数据分离——读取配置文件 版本：python 3.6 进行数据/配置和代码分离时，python3.6 可以使用configparser进行配置信息读取或创建。可以实现程序和数据的分离，便于后期维护程序，也能在一定程序上满足不会编码的人进行自动化测试（只需改配置文件。） 以创建/读取ini格式配置文件为例： 创建配置文件：每个ini文件都是有n个sections组成（可以理解为组成部分或者是段落。。我是这么理解的），每个sections包含若干个键值对（keys:values），所以某种程度上，你可以把每个section看成是个字典（dictionary），虽然这俩意义上完全无关。python3.6创建ini配置文件代码示例：1234567891011121314151617181920212223#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparsercf = configparser.ConfigParser()cf[&apos;DEFAULT&apos;] = &#123;&quot;browser&quot; : &quot;Chrome&quot;, &quot;version&quot; : &quot;63.0.3239.132&quot;, &quot;driver&quot; : &quot;chromedriver.exe&quot;, &#125;cf[&apos;tokyle.com&apos;] = &#123;&#125;cf[&apos;tokyle.com&apos;][&apos;Author&apos;] = &apos;kyle&apos;cf[&apos;baidu.com&apos;] = &#123;&#125;baiduSearch = cf[&apos;baidu.com&apos;]baiduSearch[&apos;searchBox&apos;] = &apos;id &gt; kw&apos;baiduSearch[&apos;searchButton&apos;] = &apos;id &gt; su&apos;cf[&apos;DEFAULT&apos;][&apos;noRetry&apos;] = &apos;yes&apos;with open(&apos;test.ini&apos;, &apos;w&apos;) as configfile: cf.write(configfile) 上述代码执行完成之后会在该.py文件所在目录下创建一个test.ini的配置文件，内容如下：123456789101112[DEFAULT]browser = Chromeversion = 63.0.3239.132driver = chromedriver.exenoretry = yes[tokyle.com]author = kyle[baidu.com]searchbox = id &gt; kwsearchbutton = id &gt; su 每个ini文件可以包含一个[&#39;DEFAULT&#39;] section，也可以没有，[&#39;DEFAULT&#39;]部分定义了默认设置，例如默认使用的浏览器，浏览器版本等。 读取配置信息1234import configparsercf = configparser.ConfigParser()cf.read(&apos;test.ini&apos;) 获取所有sections使用1cf.sections() 即可，需要注意的是，这样，是默认不会获取都[‘DEFAULT’]的，可以实验一下：12section = cf.sections()print(section) 打印出的结果：1[&apos;tokyle.com&apos;, &apos;baidu.com&apos;] 可以看见默认不包含[‘DEFAULT’]。 其实读取配置信息就和读取字典里的数据做法一样，使用for循环就可以打印出全部信息，例如进行自动化测试时想获取[‘baidu.com’]里存的百度搜索输入框以及百度一下按键，可以：123baidu_msg = cf[&apos;baidu.com&apos;]for key,value in baidu_msg.items(): print(key + &apos; : &apos; + value) 打印出的信息：123456searchbox : id &gt; kwsearchbutton : id &gt; subrowser : Chromeversion : 63.0.3239.132driver : chromedriver.exenoretry : yes 可以看见，这样不仅会把[‘baidu.com’]模块的信息全部打印，[‘DEFAULT’]模块的信息也会被打印出来。 使用配置文件实例(简单的数据分离)：123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparserimport traceback,timefrom selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom nose.tools import assert_trueclass ElementId(): def __init__(self): #读取配置文件 self.cf = configparser.ConfigParser() self.cf.read(&apos;test.ini&apos;) self.cf.sections() def get_elementId(self, driver, webSiteName, webelement): try: #获取配置文件中的定位方法以及定位元素 webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;) webelement_method = webElemnt[0].strip() webelement_expression = webElemnt[1].strip() element = WebDriverWait(driver, 10).until\ (lambda x: x.find_element(webelement_method, webelement_expression)) except Exception as e: print(traceback.print_exc(), e) else: return elementif __name__ == &apos;__main__&apos;: &quot;&quot;&quot;测试百度搜索&quot;&quot;&quot; #打开百度首页 browser = webdriver.Chrome() browser.get(&quot;https://www.baidu.com&quot;) #获取定位元素 elementid = ElementId() searchBox = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbox&apos;) searchBox.send_keys(&apos;selenium&apos;) searchButton = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbutton&apos;) searchButton.click() time.sleep(3) #断言完成百度搜索&quot;selenium&quot; assert_true(u&quot;Selenium - Web Browser Automation&quot; in browser.page_source) browser.quit() （我在执行上述示例之前，把test.ini中的[‘DEFAULT’]注释掉了，此例不需要[‘DEFAULT’]中的信息）]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自娱自乐一]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%87%AA%E5%A8%B1%E8%87%AA%E4%B9%90%E4%B8%80%2F</url>
    <content type="text"><![CDATA[自娱自乐系列一： 为了过年提前回家，周六过来加班调休，又不大想干活，就想着捣鼓点自娱自乐的东西： 输入年龄判断是否有投票资格：1234567891011121314151617def judge_age(): while True: try: age = int(input(&quot;\nPlease enter your age：&quot;)) except ValueError: print(&quot;Sorry,I can&apos;t understand what you entered.Please enter a correct number.&quot;) continue else: break if age &gt;= 18: print(&quot;You are able to vote in the United States!&quot;) else: print(&quot;You are too young to vote in the United States!&quot;)if __name__ == &apos;__main__&apos;: judge_age() 判断输入的正整数:12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-def get_non_negative_int(prompt): try: value = int(input(prompt)) except ValueError: print(&quot;Sorry,I can&apos;t understand that.&quot;) return get_non_negative_int(prompt) if value &lt; 0: print(&quot;Sorry,your response must not be negative.&quot;) return get_non_negative_int(prompt) else: return valuedef guess_number(): number = get_non_negative_int(&quot;Please enter a number to guess: (only positive integer can work,thanks!)&quot;) while True: guess = get_non_negative_int(&quot;guess the number.&quot;) if guess &gt; number: print(&quot;You could enter a lower one.&quot;) elif guess &lt; number: print(&quot;I think it could be higher.&quot;) else: print(&quot;Congratulations! You got it!&quot;) breakif __name__ == &apos;__main__&apos;: guess_number() 纯属自娱自乐，毫无技术含量 Thanks?(?ω?)? 顺便贴个常识坑：文件夹不能取名是code，否则pycharm的debug模式会报错！！！（stackoverflow真是个好网站！什么坑都能找到填的办法。。）原因：debug模式会引个包：1from code import InteractiveConsole 工程中有code文件夹，会找不到debug需要的方法]]></content>
      <categories>
        <category>just for fun</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lives</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium应用简介]]></title>
    <url>%2F2018%2F01%2F19%2Fappium%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[appium应用篇，简单介绍自己工作中用到的一些appium应用。 Appium等待类型固定时间等待123import timetime.sleep(3) 固定等待时间3秒，强制等待，必须等完3秒之后才会进行下一步操作。 隐式等待1driver.implicitly_wait(5) 隐式等待的好处是不用想固定时间（time.sleep()）一样死等固定时间，可以在一定程度上提高执行效率，但是这种等待方式也是需要等页面所有元素都加载完成才会去进行下一步操作，例如有的时候，页面你需要的元素已经加载完成，但是必须还是要等待个别资源加载完才会执行下一步，一定程度上来说还是效率降低。 显示等待1234from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver, 10).\ until(lambda x:x.find_element_by_id(&apos;com.anmav.cashierdesk:id/tvOpenTable&apos;)) 显示等待原理是每隔一段时间（默认0.5秒），执行一次判断条件，如果条件成立，就执行下一步，直到超过设定的最大等待时间，抛出TimeoutException异常 Appium定位弹窗切换webview原理和selenium一样，类似于selenium中先获取页面句柄，再切换。1234driver.contexts方法一：driver.switch_to.context(&quot;contextname&quot;) #contextname为想切换到的上下文方法二：driver.switch_to.context(contexts[1]) # 从contexts里取第二个参数 Appium连接真机使用真机作为测试机，进行app自动化测试（android）步骤： adb连接真机首先是本地PC连接到真机，保证真机所在网段PC可以ping通（局域网或者同一WiFi）12&#123;lamb&#125; adb connect 192.168.0.194:9555connected to 192.168.0.194:9555 进入cmd，输入adb连接命名，连接到真机 起appium服务本地PC装有appium-desktop，直接启动appium-desktop，即完成appium服务启动 运行自动化测试脚本配置：12345678910self.desired_caps = &#123;&#125;self.desired_caps[&apos;platformName&apos;] = &apos;Android&apos;self.desired_caps[&apos;platformVersion&apos;] = &apos;6.0.1&apos;self.desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;self.desired_caps[&apos;app&apos;] = &apos;‪G:/apk/1.2.5/test_release_v1.2.5.apk&apos;self.desired_caps[&apos;noReset&apos;] = Trueself.desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.test&apos;self.desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.test.login.activity.LoginActivity&apos;self.driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, self.desired_caps) 之后再加上用户名，密码等信息输入，即可完成远程真机app自动安装，登录。]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python项目依赖管理工具-pipenv]]></title>
    <url>%2F2018%2F01%2F18%2Fpython%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pipenv%2F</url>
    <content type="text"><![CDATA[偶然发现一个很好用的python项目包管理工具pipenv github上简介是一句话Pipenv: Python Development Workflow for Humans 现在已经是python.org官方推荐的工具。 具体功能：pipenv能够自动创建和管理你工程的虚拟环境，当你安装/卸载包时，会自动从你的Pipfile中添加/移除包；为啥要用这个工具，python的特点，python进行工程环境创建，一般是创建一个Virtualenv虚拟环境，然后列出所需要的工具包，pip安装，但是这样你就要手动去添加你需要的包，删除你已经不需要的包，并且由于工具包的更新，你可能还需要手动去更新你的工具包，而且，类似于单元测试这样的场景，需要安装nose包，但是生产环境又不需要该包，也就无法做到生产环境和开发环境安装包的分离，而以上这些，pipenv都可以解决。 使用简介首先安装pipenv使用pip安装pipenv及其依赖项1pip install pipenv macOS安装则使用1brew install pipenv 进入你项目所在文件夹，启动Pipenv12cd your_projectpipenv install 启动之后，项目文件夹下会多出两个文件Pipfile，Pipfile.lockPipfile文件包含项目的依赖包信息。 管理依赖包要为项目安装依赖包，跟pip类似1pipenv install nose 卸载1pipenv uninstall nose 可以通过更新Pipfile.lock来冻结软件包名称及其版本以及其自己的依赖关系的列表。 这是使用lock关键字完成:1pipenv lock 如果你同事或者朋友想clone你的依赖库，直接拿你的Pipfile，然后他本地安装pipenv之后，pipenv install即可完成依赖库安装 环境分离只为开发环境安装包：1pipenv install --dev nose 这样，在生产环境执行pipenv install是不会安装nose的，想要安装开发环境的依赖，执行：1pipenv install --dev 用法pipenv所有关键字及解释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update Update Pipenv &amp; pip to latest. --where Output project home information. --venv Output virtualenv information. --py Output Python interpreter information. --envs Output Environment Variable options. --rm Remove the virtualenv. --bare Minimal output. --completion Output completion (to be eval&apos;d). --man Display manpage. --three / --two Use Python 3/2 when creating virtualenv. --python TEXT Specify which version of Python virtualenv should use. --site-packages Enable site-packages for the virtualenv. --jumbotron An easter egg, effectively. --version Show the version and exit. -h, --help Show this message and exit.Usage Examples: Create a new project using Python 3.6, specifically: $ pipenv --python 3.6 Install all dependencies for a project (including dev): $ pipenv install --dev Create a lockfile containing pre-releases: $ pipenv lock --pre Show a graph of your installed dependencies: $ pipenv graph Check your installed dependencies for security vulnerabilities: $ pipenv check Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e .Commands: check Checks for security vulnerabilities and... graph Displays currently–installed dependency graph... install Installs provided packages and adds them to... lock Generates Pipfile.lock. open View a given module in your editor. run Spawns a command installed into the... shell Spawns a shell within the virtualenv. uninstall Un-installs a provided package and removes it... update Uninstalls all packages, and re-installs... 定位工程展示工程路径以及环境路径，进入工程(类似于linux)：1pipenv --where 1pipenv --venv 定位python解释器：1pipenv --py 其他使用激活工程环境1pipenv shell 运行python脚本1pipenv run python main.py 展示依赖关系图1pipenv graph 卸载所有1pipenv uninstall --all 参考地址 github项目地址python.org官网推荐地址]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder简介]]></title>
    <url>%2F2018%2F01%2F18%2Fcmder%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[windows小工具介绍 windows系统cmd工具，说实话，用的还是有点不舒服的，用习惯vim之后，真的是很想在windows上用类似的，还好，找到个小工具cmder。 下载地址：照旧，官方下载地址是托管在github上 github下载地址 但是不知道最近抽什么疯，github上n多项目下载页面直接404，索性提供本地度娘盘地址： 度娘盘地址 使用说明下载完成之后，解压缩，然后将cmder.exe所在目录添加到系统环境变量中，完成~双击打开即可使用。 简单设置解决中文乱码问题：类似于linux，alias文件中添加设置即可；alias文件位置：cmder/config/aliases添加：123l=ls --show-control-charsla=ls -aF --show-control-charsll=ls -alF --show-control-chars 中文字重叠在一起cmder进入设置（快捷键win+alt+p），找到main，取消monospace(固定宽度)勾选 基本就是设置完成了，可以进行使用了，后续再发现什么其他的好功能再更新。123456789#切换盘D:#展示文件lsll#查看文件内容cat xxx.txt#编辑文件内容vim xxx.txt]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium键盘事件]]></title>
    <url>%2F2018%2F01%2F17%2Fappium%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[appium键盘事件 语法：1driver.keyevent(keyCode) 电话键1234567891011121314KEYCODE_CALL 拨号键 5KEYCODE_ENDCALL 挂机键 6KEYCODE_HOME 按键Home 3KEYCODE_MENU 菜单键 82KEYCODE_BACK 返回键 4KEYCODE_SEARCH 搜索键 84KEYCODE_CAMERA 拍照键 27KEYCODE_FOCUS 拍照对焦键 80KEYCODE_POWER 电源键 26KEYCODE_NOTIFICATION 通知键 83KEYCODE_MUTE 话筒静音键 91KEYCODE_VOLUME_MUTE 扬声器静音键 164KEYCODE_VOLUME_UP 音量增加键 24KEYCODE_VOLUME_DOWN 音量减小键 25 控制键123456789101112131415161718192021KEYCODE_ENTER 回车键 66KEYCODE_ESCAPE ESC键 111KEYCODE_DPAD_CENTER 导航键 确定键 23KEYCODE_DPAD_UP 导航键 向上 19KEYCODE_DPAD_DOWN 导航键 向下 20KEYCODE_DPAD_LEFT 导航键 向左 21KEYCODE_DPAD_RIGHT 导航键 向右 22KEYCODE_MOVE_HOME 光标移动到开始键 122KEYCODE_MOVE_END 光标移动到末尾键 123KEYCODE_PAGE_UP 向上翻页键 92KEYCODE_PAGE_DOWN 向下翻页键 93KEYCODE_DEL 退格键 67KEYCODE_FORWARD_DEL 删除键 112KEYCODE_INSERT 插入键 124KEYCODE_TAB Tab键 61KEYCODE_NUM_LOCK 小键盘锁 143KEYCODE_CAPS_LOCK 大写锁定键 115KEYCODE_BREAK Break/Pause键 121KEYCODE_SCROLL_LOCK 滚动锁定键 116KEYCODE_ZOOM_IN 放大键 168KEYCODE_ZOOM_OUT 缩小键 169 组合键123456KEYCODE_ALT_LEFT Alt+LeftKEYCODE_ALT_RIGHT Alt+RightKEYCODE_CTRL_LEFT Control+LeftKEYCODE_CTRL_RIGHT Control+RightKEYCODE_SHIFT_LEFT Shift+LeftKEYCODE_SHIFT_RIGHT Shift+Right 基本123456789101112131415161718192021222324252627282930313233343536KEYCODE_0 按键&apos;0&apos; 7KEYCODE_1 按键&apos;1&apos; 8KEYCODE_2 按键&apos;2&apos; 9KEYCODE_3 按键&apos;3&apos; 10KEYCODE_4 按键&apos;4&apos; 11KEYCODE_5 按键&apos;5&apos; 12KEYCODE_6 按键&apos;6&apos; 13KEYCODE_7 按键&apos;7&apos; 14KEYCODE_8 按键&apos;8&apos; 15KEYCODE_9 按键&apos;9&apos; 16KEYCODE_A 按键&apos;A&apos; 29KEYCODE_B 按键&apos;B&apos; 30KEYCODE_C 按键&apos;C&apos; 31KEYCODE_D 按键&apos;D&apos; 32KEYCODE_E 按键&apos;E&apos; 33KEYCODE_F 按键&apos;F&apos; 34KEYCODE_G 按键&apos;G&apos; 35KEYCODE_H 按键&apos;H&apos; 36KEYCODE_I 按键&apos;I&apos; 37KEYCODE_J 按键&apos;J&apos; 38KEYCODE_K 按键&apos;K&apos; 39KEYCODE_L 按键&apos;L&apos; 40KEYCODE_M 按键&apos;M&apos; 41KEYCODE_N 按键&apos;N&apos; 42KEYCODE_O 按键&apos;O&apos; 43KEYCODE_P 按键&apos;P&apos; 44KEYCODE_Q 按键&apos;Q&apos; 45KEYCODE_R 按键&apos;R&apos; 46KEYCODE_S 按键&apos;S&apos; 47KEYCODE_T 按键&apos;T&apos; 48KEYCODE_U 按键&apos;U&apos; 49KEYCODE_V 按键&apos;V&apos; 50KEYCODE_W 按键&apos;W&apos; 51KEYCODE_X 按键&apos;X&apos; 52KEYCODE_Y 按键&apos;Y&apos; 53KEYCODE_Z 按键&apos;Z&apos; 54]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium定位]]></title>
    <url>%2F2018%2F01%2F17%2Fappium%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[appium的常用操作以及元素定位的简单介绍 appium常用操作锁屏1driver.lock(5) 切换应用至后台123driver.background_app(5) # 置于后台，持续5秒driver.background_app(-1) # 持续置于后台driver.background_app(&#123;&apos;timeout&apos;: None&#125;) # 持续置于后台 收起键盘1driver.hide_keyboard() 启动Activity1driver.start_activity(&apos;com.example.android.apis&apos;, &apos;.Foo&apos;) 检测应用是否被安装1driver.is_app_installed(&apos;com.example.android.apis&apos;) 安装应用1driver.install_app(&apos;path/to/my.apk&apos;) 卸载应用1driver.remove_app(&apos;com.example.android.apis&apos;) 模拟设备摇一摇1driver.shake() 关闭应用1driver.close_app() 启动应用使用前提是desired capabilities设置了 autoLaunch=false 关键字1driver.launch_app() 操作上下文（Contexts）获取所有1driver.contexts 获取当前1driver.current_context 切换至默认1driver.switch_to.context(None) 按键事件1driver.keyevent(176) 具体键值 点击操作/多点触控操作12action = TouchAction(driver)action.press(element=el, x=10, y=10).release().perform() 滑动屏幕1driver.swipe(start_x=75, start_y=500, end_x=75, end_y=0, duration=800) 从设备拉去文件1driver.pull_file(&apos;Library/AddressBook/AddressBook.sqlitedb&apos;) 推送文件到设备123data = &quot;some data for the file&quot;path = &quot;/data/local/tmp/file.txt&quot;driver.push_file(path, data.encode(&apos;base64&apos;)) appium元素定位使用id，class等和selenium基本没差别的定位就不介绍了，主要介绍appium独有uiautomator UiSelector 页面class和id等都不能唯一确定元素，但是元素有text属性时，可以使用以下进行定位：1234driver.find_element_by_android_uiautomator(&apos;new UiSelector().text(&quot;Custom View&quot;)&apos;).click() #textdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textContains(&quot;View&quot;)&apos;).click() #textContainsdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textStartsWith(&quot;Custom&quot;)&apos;).click() #textStartsWithdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textMatches(&quot;^Custom.*&quot;)&apos;).click() #textMatches 也可以加上class属性：12driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.TextView&quot;).text(&quot;Custom View&quot;)&apos;).click() #classNamedriver.find_element_by_android_uiautomator(&apos;new UiSelector().classNameMatches(&quot;.*TextView$&quot;).text(&quot;Custom View&quot;)&apos;).click() #classNameMatches 多条件精准定位1driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.EditText&quot;).resourceId(&quot;com.anmav.cashierdesk:id/etToPayPrice&quot;)&apos;) 操作坐标appium在进行元素定位时，定位不到唯一标志的元素，可以获取元素的坐标，使用坐标进行操作 appium以及uiautomatorviewer都可以很容易获取到坐标 appium操作坐标 1driver.tap([(100, 20), (100, 60), (100, 100)], 500) 三个坐标表示模拟三根手指，只需要一个手指，改成一个坐标即可，500表示持续时间500ms 或者使用adb命令也可实现同样效果：1os.popen(&quot;adb shell input tap &quot; + str(100) + &quot; &quot; + str(20)) 参考文章 appium 基础之键盘处理appium-bindings]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app安装卸载]]></title>
    <url>%2F2018%2F01%2F17%2Fapp%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[appium-模拟器安装卸载app 模拟器安装apk1adb install XXX.apk 卸载apk1adb uninstall your_package 例子： 启动android模拟器，参数：12345desired_caps[&apos;platformName&apos;] = &apos;Android&apos;desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos;desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.view.LoginActivity&apos; win10打开控制台，进入apk文件所在目录，执行命令1adb install cashierdesk.apk 在模拟器中可以发现该app已完成安装。 控制台执行命令：1adb uninstall com.anmav.cashierdesk 模拟器中可以看见该app完成卸载]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium入门篇]]></title>
    <url>%2F2018%2F01%2F16%2Fappium%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[appium环境搭建及简单使用 测试人员进行app自动化测试的可选框架之一—— appium 平台说明：12WIN10_64python 3.6 appium环境安装安装Android Studio网上之前的教程基本都是安装SDK或者ADT来进行安装，开始我也是这么装的，在最后创建完虚拟机，开启虚拟机时候报错了，报错信息只记得是建议安装Android Studio，索性也就换成了Android Studio。 Android Studio下载链接 如果下载的是不包含SDK的版本，还需要另外下载SDK。安装Android Studio很简单，和Pycharm一模一样，有使用Pycharm经验或者IntelliJ IDEA的应该很熟悉，安装完成之后，找到SDK Manager1File-Settings-Appearance&amp;Behavior &gt; System Settings &gt; Android SDK 如果本地有SDK，可以在此选择本地的SDK路径，该设置页也支持下载各种SDK Platforms。对应的SDK安装完成之后就可以进行创建虚拟机，找到AVD Manager按键，点击创建。 安装Android SDK（和安装Android Studio任选一种方式即可）官方下载地址 但是由于国内众所周知的某种原因，不能科学上网貌似无法保证可以下载~ 国内优质android工具网站 搜索android-sdk找到对应系统版本，进行下载。 配置android环境变量与配置JAVA环境变量类似，新增系统变量123456变量名：ANDROID_HOME 变量值：D:\android\android-sdk-windows变量名：PATH变量值：;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; SDK Manager安装模拟器在你本地解压完成之后的android-sdk-windows目录下找到SDK Manager.exe，双击打开； 配置参考 安装SDK Platform-Tools在AndroidDevTools.cn 网站上找到Android SDK Platform-tools下载链接，下载，解压，把解压出来的 platform-tools 文件夹放在android-sdk-windows目录下 安装Appium安装方式一： 使用NodeJS 安装1，首先到官网下载安装最新的NodeJS，Windows下属于傻瓜安装。安装完成验证npm或者node -v不报错表明安装完成 2，安装appium，npm install -g appium命令安装appium（个人实验的效果不好，太慢了，建议采用第二种，安装包安装） 安装方式二：安装包安装建议直接安装appium-desktop，appium server在2015年就不再更新，取而代之的是appium-desktop的出现。 Appium安装包托管在github上，下载地址 但是个人实验，很多版本都是跳转404页面。。。无语。。。 个人网盘地址，密码：v3lt（版本1.2.7） 下载完成后，安装即可。 appium环境检查可以使用appium-doctor工具进行环境检查，npm install -g appium-doctor进行安装。 Appium-desktop使用简介打开appium-desktop，点击“放大镜”图标进行设置， 设置完成后点击 Start Session 直接单击最左栏的元素，在中间和右边会显示该元素属性，找到对应的ID值等，定位方式和selenium类似。 查找appPackage和appActivityappium进行自动化测试，需要appPackage和appActivity两个参数，下面是从apk文件获取的方法： apk反编译apktool 地址： apktool 用法1java -jar apktool.jar d yourApkFile.apk 获取appPackage和appActivity打开apk反编译之后的文件夹，打开AndroidManifest.xml文件 package获取 appPackage，activity获取appActivity。 appium Demo实现计算器计算，代码：1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-from appium import webdriverimport timedesired_caps = &#123;&#125;desired_caps[&apos;platformName&apos;] = &apos;Android&apos;desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;desired_caps[&apos;appPackage&apos;] = &apos;com.android.calculator2&apos;desired_caps[&apos;appActivity&apos;] = &apos;.Calculator&apos;desired_caps[&apos;noReset&apos;] = Truedriver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, desired_caps)driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()driver.find_element_by_accessibility_id(&apos;multiply&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_9&apos;).click()driver.find_element_by_accessibility_id(&apos;plus&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_1&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()driver.find_element_by_accessibility_id(&apos;equals&apos;).click()time.sleep(3)driver.quit()]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smtp发邮件]]></title>
    <url>%2F2018%2F01%2F12%2Fsmtp%E5%8F%91%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用python3发送网易邮箱邮件 代码：12345678910111213141516import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerdef send_email(mail_host, from_account, from_passwd, to_account, subject, content): mail = smtplib.SMTP() mail.connect(mail_host) mail.login(from_account, from_passwd) # 发送邮件 message = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;) message[&apos;From&apos;] = from_account message[&apos;To&apos;] = to_account message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) mail.sendmail(from_account, to_account, message.as_string()) 菜鸟教程上有一种写法12345678910111213141516171819202122232425262728293031#!/usr/bin/python3 import smtplibfrom email.mime.text import MIMETextfrom email.header import Header # 第三方 SMTP 服务mail_host=&quot;smtp.XXX.com&quot; #设置服务器mail_user=&quot;XXXX&quot; #用户名mail_pass=&quot;XXXXXX&quot; #口令 sender = &apos;from@runoob.com&apos;receivers = [&apos;429240967@qq.com&apos;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)message[&apos;To&apos;] = Header(&quot;测试&quot;, &apos;utf-8&apos;) subject = &apos;Python SMTP 邮件测试&apos;message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print (&quot;邮件发送成功&quot;)except smtplib.SMTPException: print (&quot;Error: 无法发送邮件&quot;) 这样执行，会报错smtplib.SMTPDataError: (554, &#39;DT:SPM 126 smtp5,jtKowAD3MJz2c1JXLcK2AA--.52114S2 1465021431,please see http://mail.163.com/help/help_spam_16.htm?ip=123.114.121.110&amp;hostid=smtp5&amp;time=1465021431&#39;) 解决办法就是指定收发件人12message[&apos;From&apos;] = from_accountmessage[&apos;To&apos;] = to_account p.s 网易邮箱客户端默认授权码是关闭的，直接执行python调用会失败，要先进客户端，把客户授权码打开位置：设置-客户端授权密码设置完成之后，登录密码就使用你设置的授权码]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>smtplib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium无干预下载]]></title>
    <url>%2F2018%2F01%2F10%2Fselenium%E6%97%A0%E5%B9%B2%E9%A2%84%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[selenium自带了无人工干预实现下载功能的模块，下载时不需要弹窗点击确定下载 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverimport timeclass MacDownload(): def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; # 创建一个FirefoxProfile实例，用于存放自定义配置 profile = webdriver.FirefoxProfile() # 指定下载路径，默认自动创建一级目录 profile.set_preference(&apos;browser.download.dir&apos;, &apos;G:\idownload&apos;) # 将browser.download.folderLis设置为2，表示将文件下载到指定目录（0表示桌面，1表示默认路径） profile.set_preference(&quot;browser.download.folderList&quot;, 2) # browser.helperApps.alwaysAsk.force对于未知的MIME类型文件会弹出窗口 # 让用户处理，默认值为True，设定为False表示不会记录打开未知MIME类型文件的方式 profile.set_preference(&quot;browser.helperApps.alwaysAsk.force&quot;, False) # 在开始下载时是否显示下载管理器 profile.set_preference(&quot;browser.download.manager.showWhenStarting&quot;, False) # 设定为False会把下载狂隐藏 profile.set_preference(&quot;browser.download.manager.useWindow&quot;, False) # 默认为True，设定为False表示不获取焦点 profile.set_preference(&quot;browser.download.manager.focusWhenStarting&quot;, False) # 下载.exe文件弹出警告，默认值为True，设定为False则不会弹出警告 profile.set_preference(&quot;browser.download.manager.alertOnEXEOpen&quot;, False) # browser.helperApps.neverAsk.openFile表示直接打开下载文件，不显示确定框 # 默认值为空字符串，下行代码行设定了多种文件的MIME类型， # 例如application/exe,表示 .exe类型的文件；application/excel表示excel类型的文件 profile.set_preference(&quot;browser.helperApps.neverAsk.openFile&quot;, &quot;application/pdf&quot;) # 对所给出文件类型不在弹出提示框进行询问，直接保存到本地磁盘 profile.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/zip, application/octet-stream&quot;) # browser.download.manager.showAlertOnComplete设定下载文件结束后是否显示下载完成提示框 # 默认为True，设定为False表示下载完成后不显示下载完成提示框 profile.set_preference(&quot;browser.download.manager.showAlertOnComplete&quot;, False) # browser.download.manager.closeWhenDone设定下载结束后是都自动关闭下载框 # 默认为True，设定为False表示不关闭下载管理器 profile.set_preference(&quot;browser.download.manager.closeWhenDone&quot;, False) # 启动浏览器，通过firfox_profile参数将自动配置添加到FirefoxProfile对象中sef.driver = webdriver.Firefox(firefox_profile=profile) self.driver = webdriver.Firefox(firefox_profile=profile) def test_dataPicker(self): #访问WebDriver驱动firefox的驱动文件下载网址 # url1 = &quot;https://github.com/mozilla/geckodriver/releases&quot; # self.driver.get(url1) # #选择下载ZIP类型的文件，使用application/zip指代此类型文件 # self.driver.find_element_by_xpath(&apos;//strong[. = &quot;geckodriver-v0.19.1-win32.zip&quot;]&apos;).click() # time.sleep(10) #访问Python2.7.12文件下载页面，下载扩展名为msi的文件 #使用application/octet - stream来指明次文件类型 url = &quot;https://www.python.org/downloads/release/python-2712/&quot; self.driver.get(url) self.driver.find_element_by_link_text(&apos;Windows x86-64 MSI installer&apos;).click() time.sleep(100) self.driver.quit()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306余票监控]]></title>
    <url>%2F2018%2F01%2F10%2F12306%E4%BD%99%E7%A5%A8%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[翻日历突然意识到，好像要放假了，又是一年春运时，就想着可不可以用selenium做个自己的监控12306余票的程序。 动手：思路也就是输入起点，终点，选择列车，选择座位，查询是否有余票。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timeclass monitorTickets(): &quot;&quot;&quot; 查询12306硬座，硬卧，软卧余票 &quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; #使用chrome浏览器打开查询12306查询页面 self.browser = webdriver.Chrome() url = &apos;https://kyfw.12306.cn/otn/leftTicket/init&apos; self.browser.get(url) def search_tickets(self,train_name, start_stations, end_stations, ticket_id): &quot;&quot;&quot;循环获取余票&quot;&quot;&quot; print(&quot;开始查询【%s】次列车余票信息&quot; % train_name) for start_station in start_stations: try: for end_station in end_stations: #输入起点 starts = self.browser.find_element_by_id(&quot;fromStationText&quot;) starts.click() starts.clear() starts.send_keys(start_station) starts.send_keys(Keys.ENTER) #输入到站 ends = self.browser.find_element_by_id(&quot;toStationText&quot;) ends.click() ends.clear() ends.send_keys(end_station) ends.send_keys(Keys.ENTER) #选择时间 #使用js将只读属性去除，完成选择时间 js = &apos;document.getElementById(&quot;train_date&quot;).removeAttribute(&quot;readonly&quot;);&apos; self.browser.execute_script(js) date = self.browser.find_element_by_id(&apos;train_date&apos;) date.clear() date.send_keys(&apos;2018-02-10&apos;) date.click() self.browser.find_element_by_id(&quot;query_ticket&quot;).click() time.sleep(2) text = self.browser.find_element_by_id(ticket_id).text if text == u&quot;无&quot;: print(u&quot;【%s】到【%s】的余票为0，节哀～&quot; % (start_station, end_station)) time.sleep(1) elif text == u&quot;*&quot;: print(u&quot;【%s】到【%s】的车票还未开售，请耐心等待～&quot; % (start_station, end_station)) time.sleep(1) else: print(u&quot;发现【%s】到【%s】的余票，抢!&quot; % (start_station, end_station)) except: continue print(&quot;结束查询【%s】次列车余票信息&quot; % train_name) def close_browser(self): &quot;&quot;&quot;关浏览器&quot;&quot;&quot; time.sleep(3) self.browser.quit()if __name__ == &apos;__main__&apos;: #查票 time.sleep(1) search_ticket = monitorTickets() while True: print(&quot;监控硬座&quot;) search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YZ_550000T11671&apos;) search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;YZ_550000Z21605&apos;) search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YZ_560000T11251&apos;) search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YZ_550000T20450&apos;) search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YZ_5500000Z4061&apos;) print(&quot;监控硬座结束&quot;) # print(&quot;监控硬卧&quot;) # search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YW_550000T11671&apos;) # search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;YW_550000Z21605&apos;) # search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YW_560000T11251&apos;) # search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YW_550000T20450&apos;) # search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YW_5500000Z4061&apos;) # print(&quot;监控硬卧结束&quot;) # # print(&quot;监控软卧&quot;) # search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;RW_550000T11671&apos;) # search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;RW_550000Z21605&apos;) # search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;RW_560000T11251&apos;) # search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;RW_550000T20450&apos;) # search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;RW_5500000Z4061&apos;) # print(&quot;监控软卧结束&quot;) # msg = input(&quot;Enter &apos;q&apos; to quit&quot;) # if msg == &apos;q&apos;: # break # search_ticket.close_browser()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录网易邮箱]]></title>
    <url>%2F2018%2F01%2F05%2F%E7%99%BB%E5%BD%95%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[基于python3的自动化测试框架selenium3实践 登录网易邮箱（126,163） 登录163123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timebrowser = webdriver.Chrome()browser.get(&apos;http://mail.163.com/&apos;)browser.maximize_window()#切换进iframebrowser.implicitly_wait(5)browser.switch_to.frame(&apos;x-URS-iframe&apos;)time.sleep(1)#定位账号username = browser.find_element_by_name(&apos;email&apos;)username.clear()username.send_keys(&apos;***&apos;)time.sleep(1)#定位密码pwd = browser.find_element_by_name(&apos;password&apos;)pwd.clear()pwd.send_keys(&apos;***&apos;)#登录pwd.send_keys(Keys.ENTER)time.sleep(3)browser.quit() 或者123456789101112131415#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timedriver = webdriver.Firefox()driver.get(&apos;http://mail.163.com/&apos;)driver.implicitly_wait(10)#切换iframeiframe = driver.find_elements_by_tag_name(&apos;iframe&apos;)driver.switch_to_frame(iframe)#driver.switch_to.frame(&apos;x-URS-iframe&apos;)driver.find_element_by_name(&apos;email&apos;).send_keys(&apos;123&apos;)driver.find_element_by_name(&apos;password&apos;).send_keys(&apos;456&apos;)brower.find_element_by_name(&quot;password&quot;).send_keys(Keys.ENTER) 登录12612345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysbrowser = webdriver.Chrome()browser.get(&apos;http://mail.126.com/&apos;)browser.maximize_window()# 切换iframebrowser.implicitly_wait(5)browser.switch_to.frame(&apos;x-URS-iframe&apos;)time.sleep(1)# 定位用户名username = browser.find_element_by_name(&apos;email&apos;)username.clear()username.send_keys(&apos;***&apos;)time.sleep(1)#定位密码pwd = browser.find_element_by_name(&apos;password&apos;)pwd.clear()pwd.send_keys(&apos;***&apos;)#登录pwd.send_keys(Keys.ENTER)time.sleep(3)browser.quit() ~记小白入坑selenium]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nose跳过测试]]></title>
    <url>%2F2018%2F01%2F04%2Fnose%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[nose进行单元测试，和unittest一样，有跳过某个方法，指定特定类进行测试的功能。 识别规则使用nose进行单元测试，测试用例识别规则如下：12345nosetests only_test_this.pynosetests test.modulenosetests another.test:TestCase.test_methodnosetests a.test:TestCasenosetests /path/to/test/file.py:test.function 示例执行全部测试直接代码示例：12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-import tracebackfrom nose.tools import eq_from nose.plugins.attrib import attrfrom nose.plugins.skip import SkipTestfrom functools import reduceclass test_nosetests(): #测试加法 def test_sum(self): a = 1 b = 2 res = 3 eq_(a+b,res) #测试乘法 def test_mul(self): a = 1 b = 2 res = 2 eq_(a*b, res) #测试除法 def test_div(self): a = 2 b = 0 res = 1 try: eq_(a/b, res) except ZeroDivisionError as e: print(traceback.print_exc()) #测试reduce函数 def test_reduce(self): req = range(1,6) a = 120 res = reduce(lambda x, y: x*y, req) eq_(a, res) 想要对test_nosetests该方法进行测试，可以： 121. nosetests -v NoseTestsexercise.py --with-html --html-file=G:/workstation/report/test_nosetests.html2. nosetests -v NoseTestsexercise.py:test_nosetests --with-html --html-file=G:/workstation/report/test_nosetests.html 由于该python文件只有这一个测试类，所以直接nosetests该python文件即可以进行测试，或者是指定该python文件的测试类如NoseTestsexercise.py:test_nosetests方式 测试结果： 执行指定方法的测试执行指定的一个方法：1nosetests -v NoseTestsexercise.py:test_nosetests.test_reduce --with-html --html-file=G:/workstation/report/test_nosetests.html 示例执行了test_nosetests类下的test_reduce方法的测试 测试结果： 跳过指定方法的测试有的时候，只需要跳过某个方法：例如想跳过test_mul该方法，只需要在代码上增加跳过标志即可1234567#测试乘法 def test_mul(self): a = 1 b = 2 res = 2 eq_(a*b, res) raise SkipTest 执行：1nosetests -v NoseTestsexercise.py:test_nosetests --with-html --html-file=G:/workstation/report/test_nosetests.html 测试结果： 其他另外，nosetests也有用例执行优先级的功能1234from nose.plugins.attrib import attr @attr(speed=&apos;slow&apos;) def test_big_download(self): print(&apos;pass&apos;) 执行只需要：nosetests -a speed=slow即可 参考用法]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python单元测试框架-nose]]></title>
    <url>%2F2018%2F01%2F03%2Fpython%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-nose%2F</url>
    <content type="text"><![CDATA[python单元测试框架 nose简介 简介nose是python单元测试的另一框架，nose可以自动识别继承于unittest.TestCase的测试单元，并执行测试，而且，nose也可以测试非继承于unittest.TestCase的测试单元。nose提供了丰富的API便于编写测试代码。 安装及使用安装：1pip install nose 基本语法：1nosetests [options] [(optional) test files or directories] 扩展使用nose自动收集单元测试，收集它当前工作目录下的源代码文件、目录以及包。任何的源代码文件、目录或者包只要匹配正则表达式，他们就会被自动收集。包的测试收集按照树的层级级别一级一级进行，因此package.tests、package.sub.tests、package.sub.sub2.tests将会被收集。 扩展插件nose支持多种插件，可完成基本大部分测试需要。nose拥有很多内置的插件帮助进行输出抓取、错误查找、代码覆盖、文档测试（doctest）等等。 命令行执行命令可查看插件：1nosetests –plugins 若想查看详细信息，可执行12nosetests –plugins -vnosetests –plugins -vv nose使用nose使用和unittest类似，unittest的断言，nose.tools中都可以选择使用使用示例：unittest：123456789101112131415161718import unittestclass NoseTest(unittest.TestCase): def setUp(self): print(&quot;=============setUp===============&quot;) def test_Pass(self): print(&quot;==========begin test=========&quot;) a = 1 b = 2 self.assertTrue(a == b, &apos;断言失败, %a != %a&apos;% (a, b)) def tearDown(self): print(&quot;==============tearDown===============&quot;)if __name__ == &apos;__main__&apos;: unittest.main() nose:12345678from nose.tools import eq_from nose.tools import assert_equalclass noseTest(): a = 1 b = 2 #assert_equal(a, b, &apos;%a != %a&apos;%(a,b)) eq_(a, b) nose也支持在代码中直接运行nose.main()或者nose.run()这样类似于unittest的方式，但是还是建议在命令行中运行nosetests来执行单元测试参考示例：1nosetests -v HandleFrameByPageSource.py:test_handleFrameByPageSource --with-html --html-file=G:\workstation\report\handleframe.html 说明：1234nosetests -v: 显示详细的运行信息和调试信息HandleFrameByPageSource.py:test_handleFrameByPageSource ：测试对象为该python文件下的test_handleFrameByPageSource类--with-html ：使用html插件,生成标准HTML格式测试报告--html-file=G:\workstation\report\handleframe.html ：测试结果输出为该路径下handleframe.html文件]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32api_VK_CODE]]></title>
    <url>%2F2018%2F01%2F02%2Fwin32api-VK-CODE%2F</url>
    <content type="text"><![CDATA[python使用win32api模块，可模拟键盘按键，应用于爬虫及自动化测试。 键盘按键对应的Vitual keystroke如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535#Giant dictonary to hold key name and VK valueVK_CODE = &#123;&apos;backspace&apos;:0x08, &apos;tab&apos;:0x09, &apos;clear&apos;:0x0C, &apos;enter&apos;:0x0D, &apos;shift&apos;:0x10, &apos;ctrl&apos;:0x11, &apos;alt&apos;:0x12, &apos;pause&apos;:0x13, &apos;caps_lock&apos;:0x14, &apos;esc&apos;:0x1B, &apos;spacebar&apos;:0x20, &apos;page_up&apos;:0x21, &apos;page_down&apos;:0x22, &apos;end&apos;:0x23, &apos;home&apos;:0x24, &apos;left_arrow&apos;:0x25, &apos;up_arrow&apos;:0x26, &apos;right_arrow&apos;:0x27, &apos;down_arrow&apos;:0x28, &apos;select&apos;:0x29, &apos;print&apos;:0x2A, &apos;execute&apos;:0x2B, &apos;print_screen&apos;:0x2C, &apos;ins&apos;:0x2D, &apos;del&apos;:0x2E, &apos;help&apos;:0x2F, &apos;0&apos;:0x30, &apos;1&apos;:0x31, &apos;2&apos;:0x32, &apos;3&apos;:0x33, &apos;4&apos;:0x34, &apos;5&apos;:0x35, &apos;6&apos;:0x36, &apos;7&apos;:0x37, &apos;8&apos;:0x38, &apos;9&apos;:0x39, &apos;a&apos;:0x41, &apos;b&apos;:0x42, &apos;c&apos;:0x43, &apos;d&apos;:0x44, &apos;e&apos;:0x45, &apos;f&apos;:0x46, &apos;g&apos;:0x47, &apos;h&apos;:0x48, &apos;i&apos;:0x49, &apos;j&apos;:0x4A, &apos;k&apos;:0x4B, &apos;l&apos;:0x4C, &apos;m&apos;:0x4D, &apos;n&apos;:0x4E, &apos;o&apos;:0x4F, &apos;p&apos;:0x50, &apos;q&apos;:0x51, &apos;r&apos;:0x52, &apos;s&apos;:0x53, &apos;t&apos;:0x54, &apos;u&apos;:0x55, &apos;v&apos;:0x56, &apos;w&apos;:0x57, &apos;x&apos;:0x58, &apos;y&apos;:0x59, &apos;z&apos;:0x5A, &apos;numpad_0&apos;:0x60, &apos;numpad_1&apos;:0x61, &apos;numpad_2&apos;:0x62, &apos;numpad_3&apos;:0x63, &apos;numpad_4&apos;:0x64, &apos;numpad_5&apos;:0x65, &apos;numpad_6&apos;:0x66, &apos;numpad_7&apos;:0x67, &apos;numpad_8&apos;:0x68, &apos;numpad_9&apos;:0x69, &apos;multiply_key&apos;:0x6A, &apos;add_key&apos;:0x6B, &apos;separator_key&apos;:0x6C, &apos;subtract_key&apos;:0x6D, &apos;decimal_key&apos;:0x6E, &apos;divide_key&apos;:0x6F, &apos;F1&apos;:0x70, &apos;F2&apos;:0x71, &apos;F3&apos;:0x72, &apos;F4&apos;:0x73, &apos;F5&apos;:0x74, &apos;F6&apos;:0x75, &apos;F7&apos;:0x76, &apos;F8&apos;:0x77, &apos;F9&apos;:0x78, &apos;F10&apos;:0x79, &apos;F11&apos;:0x7A, &apos;F12&apos;:0x7B, &apos;F13&apos;:0x7C, &apos;F14&apos;:0x7D, &apos;F15&apos;:0x7E, &apos;F16&apos;:0x7F, &apos;F17&apos;:0x80, &apos;F18&apos;:0x81, &apos;F19&apos;:0x82, &apos;F20&apos;:0x83, &apos;F21&apos;:0x84, &apos;F22&apos;:0x85, &apos;F23&apos;:0x86, &apos;F24&apos;:0x87, &apos;num_lock&apos;:0x90, &apos;scroll_lock&apos;:0x91, &apos;left_shift&apos;:0xA0, &apos;right_shift &apos;:0xA1, &apos;left_control&apos;:0xA2, &apos;right_control&apos;:0xA3, &apos;left_menu&apos;:0xA4, &apos;right_menu&apos;:0xA5, &apos;browser_back&apos;:0xA6, &apos;browser_forward&apos;:0xA7, &apos;browser_refresh&apos;:0xA8, &apos;browser_stop&apos;:0xA9, &apos;browser_search&apos;:0xAA, &apos;browser_favorites&apos;:0xAB, &apos;browser_start_and_home&apos;:0xAC, &apos;volume_mute&apos;:0xAD, &apos;volume_Down&apos;:0xAE, &apos;volume_up&apos;:0xAF, &apos;next_track&apos;:0xB0, &apos;previous_track&apos;:0xB1, &apos;stop_media&apos;:0xB2, &apos;play/pause_media&apos;:0xB3, &apos;start_mail&apos;:0xB4, &apos;select_media&apos;:0xB5, &apos;start_application_1&apos;:0xB6, &apos;start_application_2&apos;:0xB7, &apos;attn_key&apos;:0xF6, &apos;crsel_key&apos;:0xF7, &apos;exsel_key&apos;:0xF8, &apos;play_key&apos;:0xFA, &apos;zoom_key&apos;:0xFB, &apos;clear_key&apos;:0xFE, &apos;+&apos;:0xBB, &apos;,&apos;:0xBC, &apos;-&apos;:0xBD, &apos;.&apos;:0xBE, &apos;/&apos;:0xBF, &apos;`&apos;:0xC0, &apos;;&apos;:0xBA, &apos;[&apos;:0xDB, &apos;\\&apos;:0xDC, &apos;]&apos;:0xDD, &quot;&apos;&quot;:0xDE, &apos;`&apos;:0xC0&#125;def press(*args): &apos;&apos;&apos; one press, one release. accepts as many arguments as you want. e.g. press(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)def pressAndHold(*args): &apos;&apos;&apos; press and hold. Do NOT release. accepts as many arguments as you want. e.g. pressAndHold(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) def pressHoldRelease(*args): &apos;&apos;&apos; press and hold passed in strings. Once held, release accepts as many arguments as you want. e.g. pressAndHold(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). this is useful for issuing shortcut command or shift commands. e.g. pressHoldRelease(&apos;ctrl&apos;, &apos;alt&apos;, &apos;del&apos;), pressHoldRelease(&apos;shift&apos;,&apos;a&apos;) &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) for i in args: win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0) time.sleep(.1) def release(*args): &apos;&apos;&apos; release depressed keys accepts as many arguments as you want. e.g. release(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)def typer(string=None,*args):## time.sleep(4) for i in string: if i == &apos; &apos;: win32api.keybd_event(VK_CODE[&apos;spacebar&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;spacebar&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;!&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;1&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;1&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;@&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;2&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;2&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&#123;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;[&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;[&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;?&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;/&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;/&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;:&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;;&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;;&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&quot;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;\&apos;&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;\&apos;&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&#125;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;]&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;]&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;#&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;3&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;3&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;$&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;4&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;4&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;%&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;5&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;5&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;^&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;6&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;6&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&amp;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;7&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;7&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;*&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;8&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;8&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;(&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;9&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;9&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;)&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;0&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;0&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;_&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;-&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;-&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;=&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;+&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;+&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;~&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;`&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;`&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&lt;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;,&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;,&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&gt;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;.&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;.&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;A&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;a&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;a&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;B&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;b&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;b&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;C&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;c&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;c&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;D&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;d&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;d&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;E&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;e&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;e&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;F&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;f&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;f&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;G&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;g&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;g&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;H&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;h&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;h&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;I&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;i&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;i&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;J&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;j&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;j&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;K&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;k&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;k&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;L&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;l&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;l&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;M&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;m&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;m&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;N&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;n&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;n&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;O&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;o&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;o&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;P&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;p&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;p&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Q&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;q&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;q&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;R&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;r&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;r&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;S&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;s&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;s&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;T&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;t&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;t&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;U&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;u&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;u&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;V&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;v&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;v&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;W&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;w&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;w&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;X&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;x&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;x&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Y&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;y&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;y&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Z&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;z&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;z&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) else: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0) 参考地址]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
        <tag>win32api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3.6安装pywin32]]></title>
    <url>%2F2017%2F12%2F28%2Fpython3-6%E5%AE%89%E8%A3%85pywin32%2F</url>
    <content type="text"><![CDATA[python3.6装载win32api模块 使用pip安装win32报错 1Could not find a version that satisfies the requirement win32api (from versions: )No matching distribution found for win32api stack overflow上面有两种回答 pip install pypiwin32 从windowsapi官网下载安装程序，点击安装 首先尝试了第一种方式，没啥用，还是找不到win32api尝试第二种方法，直接报错：1Python version 3.6-32 required, which was not found in the registry. 找半天问题，首先本地python是64位版本，下载的也是64位安装包，报这莫名其妙的注册表错误。后来在注册表里加了个python3.6-32就能安装了，莫名其妙。。1HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\3.6-32 导入了个奇奇怪怪的win32api，貌似用不了12345#!/usr/bin/env python3# -*- coding: utf-8 -*-import win32.win32apiimport win32.win32clipboardimport win32com 根据以往踩坑经验，改注册表好像都没什么好下场，于是乎，把装好的win32全部删除，注册表还原，重新下载更新版本的pywin32：下载链接 重新安装之后，重启pycharm，这次好像是成功了。。123456import win32apiimport win32condef keyDown(keyName): win32api.keybd_event() win32con.KEYEVENTF_KEYUP 反正过程是挺无语的，莫名其妙的就好了。 附上环境信息：123WIN-10 64位python-3.6 64位pywin32-221.win-amd64-py3.6]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pywin32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3_map()函数]]></title>
    <url>%2F2017%2F12%2F27%2Fpython3-map-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[坑爹python3改动之map()函数 做自动化测试，获取并校验下拉列表中所有值，由于实在不想先写个空列表，再来个for循环全部加到列表中，就想到了map()函数，折腾半天，各种报错，墙里墙外翻半天，终于找到跟我一样入坑的人。 map()函数，python3改动 在python2中，以下代码可输出一个列表[1, 2, 3, 4, 5]12a = map(lambda x:x, [1, 2, 3, 4, 5])print(a) 但是python3，这玩意只能输出个map对象：&lt;map object at 0x00000278CB45D4E0&gt; 遇到这玩意也很多次了，直接加list：12a = list(map(lambda x: x, [1, 2, 3, 4, 5]))print(a) 这样，在python3就可以输出[1, 2, 3, 4, 5] 附自动化测试比较下拉列表值是否符合预期示例代码（百度新闻高级设置-显示条数为例）：12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.support.ui import Selectimport unittestimport timeclass News_Baidu(unittest.TestCase): def setUp(self): #打开浏览器 self.brower = webdriver.Chrome() def test_Checklist(self): #打开百度新闻页面 self.brower.get(&quot;http://news.baidu.com/&quot;) #定位“高级设置”，并点击 self.brower.find_element_by_link_text(&quot;高级搜索&quot;).click() #定位“搜索结果显示条数” select_element = Select(self.brower.find_element_by_name(&apos;rn&apos;)) #获取下拉列表所有元素对象 select_options = select_element.options #声明一个期望下拉列表值的列表(百度也是够坑的，值前面还有一个空格) expect_optionlist = [&apos; 每页显示10条&apos;, &apos; 每页显示20条&apos;, &apos; 每页显示50条&apos;] #获取实际的下拉列表值的列表 actual_optionlist = list(map(lambda option:option.text, select_options)) #断言结果是否适合期望 self.assertListEqual(actual_optionlist, expect_optionlist) def tearDown(self): #休眠 time.sleep(5) #退出浏览器 self.brower.quit()if __name__ == &apos;__main__&apos;: unittest.main()]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html报告乱码]]></title>
    <url>%2F2017%2F12%2F26%2Fhtml%E6%8A%A5%E5%91%8A%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用HTMLTestRunner进行测试报告输出时，错误说明，中午乱码，版本：12python3.6HTMLTestRunner 1.1.1 网上搜了一堆，全是用python2.x的，心痛，2.X到2020年不就不支持了嘛，为啥一个个的都在2.X上面，没办法，自己去捣鼓源码。 报告输出的html文件，使用类似于notepad的编辑器打开，编码格式改为UTF-8，重新在浏览器中打开，错误描述的中文显示就是正常文字。所以，只要在输出时，设置编码为“utf-8”应该就可以。 找到本地的HTMLTestRunner安装路径，一般都是在G:\skills\python36\Lib\site-packages\HtmlTestRunner类似这样的路径下，毕竟扩展包。下面有三个文件，和一个文件夹，文件夹里是报告的模板，不考虑，三个文件，一个是HtmlTestRunner的介绍，一个是runner.py，一个是result.py，输出报告，应该就在result.py文件中。 编辑器打开result.py，找到第350行1with open(path_file, &apos;w&apos;) as report_file: 只要修改成1with open(path_file, &apos;w&apos;,encoding=&apos;utf-8&apos;) as report_file: 即可。 附上百度搜索自动化测试代码 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3# -*- coding: utf-8 -*-import unittestimport timefrom selenium import webdriverfrom HtmlTestRunner import HTMLTestRunnerclass GloryRoad(unittest.TestCase): def setUp(self): #启动chrome浏览器 self.brower = webdriver.Chrome() def test_baidu(self): #访问百度首页 self.brower.get(&quot;https://www.baidu.com&quot;) #清空输入框内容 self.brower.find_element_by_id(&apos;kw&apos;).clear() #搜索框输入“selenium3” self.brower.find_element_by_id(&apos;kw&apos;).send_keys(&apos;selenium3&apos;) #点击“百度一下”按键 self.brower.find_element_by_id(&apos;su&apos;).click() #休眠3s time.sleep(3) assert &quot;google&quot; in self.brower.page_source, &quot;页面中不存在要寻找的关键字！&quot; def tearDown(self): #退出浏览器 self.brower.quit()if __name__ == &apos;__main__&apos;: suite = unittest.TestLoader().loadTestsFromTestCase(GloryRoad) runner = HTMLTestRunner(output=&apos;G:/workstation/report&apos;, report_title=&apos;Test Result&apos;) runner.run(suite)]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm单元测试]]></title>
    <url>%2F2017%2F12%2F25%2Fpycharm%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用pycharm编写/执行单元测试用例 python单元测试用例，调用方式使用1unittest.main() 该方式，在python shell中可执行成功，在pycharm中会一直报错，参考网上的写法，最后校验调用改为：12if _name_ == &apos;_main_&apos;: unittest.main() 结果一直报错，NameError: name &#39;_name_&#39; is not defined 简直了，找了半天，还是在墙外找到跟我有一样经历的哥们的求救，报错原因是_name_和_main都是双下划线，正确写法是： 12if __name__ == &apos;__main__&apos;: unittest.main() 真是日常坑自己…]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>unittest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium3+python3.6搭建测试]]></title>
    <url>%2F2017%2F12%2F25%2Fselenium3-python3-6%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[python3.6selenium3chrome64firefox57 selenium3开始，需要浏览器驱动，加载驱动方式：121，驱动放在任意位置，代码中，引驱动，打开浏览器（webdriver.Chrome(executable_path=&quot;驱动路径&quot;）2，将驱动放到浏览器安装目录下，和浏览器启动程序同级，将浏览器安装路径加到环境变量Path中，重启pycharm 自动化测试示例： 12345678910111213141516171819202122232425262728#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverimport time#加载驱动程序#firefox(驱动放到浏览器安装目录，目录加到Path)#driver = webdriver.Firefox()#chrome(驱动放到浏览器安装目录，目录加到Path)driver = webdriver.Chrome()#chrome默认安装路径，驱动指定路径#driver = webdriver.Chrome(executable_path=&quot;G:/Selenium/drivers/chromedriver.exe&quot;)#打开百度首页driver.get(&quot;https://www.baidu.com&quot;)#清空搜索输入框默认内容driver.find_element_by_id(&quot;kw&quot;).clear()#输入框中输入“自动化测试”driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;自动化测试&quot;)#单击搜索按钮driver.find_element_by_id(&quot;su&quot;).click()#等待3秒time.sleep(3)#退出浏览器driver.quit()]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world_map]]></title>
    <url>%2F2017%2F12%2F21%2Fworld-map%2F</url>
    <content type="text"><![CDATA[pygal-2.4pygal-maps-world-1.0.2 世界地图模块位置变更 pygal内置世界地图模块，包括国别码模块COUNTRIES以及世界地图模块World。 当前版本下，绘制世界地图，需要从pygal_maps_world.i18n中引国别码，需要从pygal_maps_world.maps中引世界地图。 参考代码如下： countries.py12345678910#!/usr/bin/env python3# -*- coding: utf-8 -*-from pygal_maps_world.i18n import COUNTRIESdef get_country_code(country_name): &quot;&quot;&quot;根据指定国家，返回国别码&quot;&quot;&quot; for code, name in COUNTRIES.items(): if name == country_name or name == country_name.title(): return code return None population_data.py123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3# -*- coding: utf-8 -*-from settings import Settingsfrom countries import get_country_codefrom pygal.style import RotateStyle as RS,LightColorizedStyle as LCSimport pygal_maps_world.mapsimport jsondata_setting = Settings()filename = data_setting.json_populationwith open(filename) as f_obj: pop_data = json.load(f_obj)#打印每个国家2010年的人口cc_population = &#123;&#125;for pop_dict in pop_data: if pop_dict[&apos;Year&apos;] == &apos;2010&apos;: country_name = pop_dict[&apos;Country Name&apos;] population = int(float(pop_dict[&apos;Value&apos;])) code = get_country_code(country_name) if code: cc_population[code] = population#按人口给国家分组cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;for cc, pop in cc_population.items(): if pop &lt; 10000000: cc_pops_1[cc] = pop elif pop &lt; 1000000000: cc_pops_2[cc] = pop else: cc_pops_3[cc] = popwm_style = RS(&apos;#336699&apos;,base_style=LCS)wm = pygal_maps_world.maps.World(style=wm_style)wm.title = &quot;World Population in 2010.by Country&quot;wm.add(&apos;0-10m&apos;, cc_pops_1)wm.add(&apos;10m-1bn&apos;, cc_pops_2)wm.add(&apos;&gt;1bn&apos;, cc_pops_3)wm.render_to_file(&apos;world_population.svg&apos;)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制随机漫步图]]></title>
    <url>%2F2017%2F12%2F20%2F%E7%BB%98%E5%88%B6%E9%9A%8F%E6%9C%BA%E6%BC%AB%E6%AD%A5%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[matplotlib可绘制随机漫步图，取随机X个数，在画布上绘制，并加入渐变颜色，效果还是挺好看的 代码如下： random_walk.py1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python3# -*- coding: utf-8 -*-from random import choiceclass RandomWalk(): &quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot; def __init__(self,num_point=5000): &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot; self.num_point = num_point #所有随机漫步的点都始于（0,0） self.x_values = [0] self.y_values = [0] def get_step(self): &quot;&quot;&quot;设置前进方向及距离&quot;&quot;&quot; direction = choice([1, -1]) distance = choice([0, 1, 2, 3, 4]) step = distance * direction return step def fill_walk(self): &quot;&quot;&quot;计算随机漫步的所有点&quot;&quot;&quot; while len(self.x_values) &lt; self.num_point: x_step = self.get_step() y_step = self.get_step() #排除原地踏步情况 if x_step == 0 and y_step == 0: continue #计算下一个点的位置 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step self.x_values.append(next_x) self.y_values.append(next_y) rw_visual.py123456789101112131415161718192021222324252627#!/usr/bin/env python3# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: #创建一个随机漫步实例，并将所有包含的点绘制出 rw = RandomWalk(30000) rw.fill_walk() point_num = list(range(rw.num_point)) plt.scatter(rw.x_values, rw.y_values, c=point_num, cmap=plt.cm.Blues, s=5) #突出起点和终点 plt.scatter(0, 0, c=&apos;green&apos;, s=100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, s=100) #隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) #plt.subplot().set_xticks([]) #plt.subplot().set_yticks([]) plt.show() keep_drawing = input(&quot;Make another walk?y/n&quot;) if keep_drawing == &apos;n&apos;: break 可成功绘制随机漫步图，然而有个警告报错：1MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.warnings.warn(message, mplDeprecation, stacklevel=1) 原因是matplotlib版本问题，出在隐藏坐标轴plt.axes().get_yaxis()处，尝试修改为：12plt.subplot().set_xticks([])plt.subplot().set_yticks([]) 然而没啥用，还是在警告，暂时没解决。。好在不影响功能，不是强迫症也就无视这红字了。。]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib绘制渐变图]]></title>
    <url>%2F2017%2F12%2F20%2Fmatplotlib%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[使用matplotlib绘制1-1000所有整数立方值图形报错 绘制1~1000所有整数的立方图，颜色采用渐变蓝色，点越接近坐标原点，颜色越浅。代码：123456789101112131415161718import matplotlib.pyplot as pltx_values = list(range(1,1001))y_values = [x**3 for x in x_values]plt.scatter(x_values, y_values, c=y_values,cmap=plt.cm.Blues,s=40)#设置图表坐标并设置坐标标签plt.title(&quot;Square Numbers&quot;,fontsize=24)plt.xlabel(&quot;Values&quot;,fontsize=14)plt.ylabel(&quot;Square of Value&quot;,fontsize=14)#设置坐标轴刻度plt.tick_params(axis=&apos;both&apos;, labelsize=14)#设置坐标轴取值plt.axes([0,1100,0,1100000])plt.show() 可以成功绘制图形，但是有警告报错：1UserWarning: Unable to find pixel distance along axis for interval padding of ticks; assuming no interval padding needed.warnings.warn(&quot;Unable to find pixel distance along axis &quot; 原因：设置坐标轴取值时，使用的是plt.axes，该函数创建的是一个轴对象，并将输入解释为指定位置的矩形，绘制的坐标轴中取值0在绘制的图形之外，超出了限制范围，所以警告报错。 解决方案：使用plt.axis()代替plt.axes()123#设置坐标轴取值plt.axis([0,1100,0,1100000])plt.show()]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.0更新内容记录]]></title>
    <url>%2F2017%2F12%2F19%2FDjango2-0%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Django 2.0 变更内容(不按版本敲着实是有点坑o(╥﹏╥)o) 外键Django 1.9在创建models.ForeignKey外键时，可写成1topic = models.ForeignKey(Topic） Django 2.0需要多传一个字段on_delete，且可给定默认值models.CASCADE所以上述可写为：1topic = models.ForeignKey(Topic,on_delete=models.CASCADE) 指定app_nameDjango 1.9在映射URL时，工程的urls.py可写成：1234567from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;&apos;,include(&apos;learning_logs.urls&apos;, namespace=&apos;learning_logs&apos;))] 应用的urls.py可写成：12345678&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsurlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 该写法在Django 2.0中会出现报错：12&apos;Specifying a namespace in include() without providing an app_name &apos;django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead. 意思是缺少了app_name，所以需要指定app_name，我的做法是在应用的urls.py文件中指定app_name，也就是工程的urls.py保持不变，应用的urls.py增加app_name指定：123456789&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsapp_name = &apos;learning_logs&apos;urlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 映射URL对于django.urls.path()函数，允许有简单的表示方法： 1url(r’^articles/(?P[0-9]&#123;4&#125;)/$’, views.year_archive), 可以写成： 1path(‘articles//‘, views.year_archive), 用法参见前博客记录]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试-理发师模型]]></title>
    <url>%2F2017%2F12%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E7%90%86%E5%8F%91%E5%B8%88%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[性能测试有个有名的模型，理发店模型，理发店标配：一间或大或小的店面，一个或几个理发师，几张理发的椅子和顾客休息的椅子。本文介绍一下理发店模型（相关资料网上一堆，只是为了自己记录） 场景假设 1234该理发店：1. 理发店共有3名理发师；2. 每位理发师剪一个发的时间都是1小时；3. 我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，我们的顾客会立马生气的走人。 场景模拟1231. 当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；2. 当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；3. 很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时； 从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从1位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。 当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。 不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。 通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。 在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。 抽象 这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示资源的利用情况（Utilization，包括硬件资源和软件资源）、吞吐量（Throughput，这里是指每秒事务数）以及响应时间（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。 在这张图中我们可以看到，最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。 根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。 当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。 对应到我们上面理发店的例子，每小时3个顾客就是这个理发店的最佳并发用户数，而每小时9个顾客则是它的最大并发用户数。当每小时都有3个顾客到来时，理发店的整体工作效率最高；而当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。当然，如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。 大神原网址]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系统监控配置]]></title>
    <url>%2F2017%2F12%2F15%2FJmeter%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Jmeter是测试人员经常会使用的一款压力测试工具，经常会使用来测试接口的性能；Jmeter同时具备监控服务器资源使用情况的功能。 主要介绍一下怎么使用Jmeter来监控服务器的CPU,内存,IO等信息。 下载使用Jmeter监控系统性能，实际上是插件的使用，可以认为是在Jmeter中装载了一个小型监控系统的客户端，同时在需要监控的系统内装载服务端，在允许Jmeter时，同时打开监控服务端，进行系统资源的监控。 12客户端：JMeterPlugins-Standard服务端：ServerAgent 下载地址： 官网下载 百度云链接： JMeterPlugins-Standard-1.4.0ServerAgent-2.2.1 配置说明将 JMeterPlugins-Standard-1.4.0.zip 中 lib\ext 目录下的 JmeterPlugins-Standard.jar 文件都放到apache-jmeter-2.13\lib\ext目录中。将 ServerAgent-2.2.1.zip 解压后放到要监控的服务器中待使用。 监控设置 启动Jmeter后，右击线程组，选择添加- 监听器- jp@gc-PerfMon Metrics Collector 打开jp@gc - PerfMon Metrics Collector，点击Add Row选择相应监控对象（服务器IP和监控内容），端口默认4444即可。 开启监控 设置永远循环，否则监控会运行一次就断开，设置方式：线程组-循环次数（选择永远） 服务端运行ServerAgent，Linux系统运行shell脚本，windows系统执行bat脚本（系统需事先完成jdk配置） 成功完成系统资源监控]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客中加入图片]]></title>
    <url>%2F2017%2F12%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[好不容易搭好了hexo，插个图片各种错 本地引用绝对路径markdown语法实现 12source/images/image.jpg ![](/images/image.jpg) 这样，图片既可以在首页内容访问，也可以在文章正文中使用 相对路径首先在/blog/_config.yml 中设置 post_asset_folder: true ，这样在 hexo new “文章” 时会生成与文章标题一样的目录，将文章中需要使用的图片存在该目录下（source//_posts/文章） 12_posts/post_name/image.jpg ![](image.jpg) CDN引用现在大多数做法是使用图床，自己也看过七牛云之类的做为图床，但是，七牛云个流氓，还要手持身份证认证，所以暂时放弃。（该方法就是在图床中生成链接，直接引链接即可） Markdown 语法介绍]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码]]></title>
    <url>%2F2017%2F12%2F13%2Fpython%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列（二） 日常编写python脚本，鉴于java各种坑编码经历，首先就会把pycharm编码设置成utf-8，但是不知道什么鬼，设置完成之后，编译还是会报编码gbk的错误 问题如下： “UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 34: illegal multibyte sequence” 解决方案： 1，设置所有文件编码默认为utf-8（文件最前面指定） 2，处理数据时进行转码： with open(“population.json”,encoding=’UTF-8’) as data: –完 (#^.^#)]]></content>
      <categories>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django获取不到特定链接]]></title>
    <url>%2F2017%2F12%2F13%2FDjango%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列 按照教程方式打开本地特定链接报错源码如下： 12345678910111213from django.conf.urls import urlfrom . import viewsurlpatterns = [ # Home page. url(r'^$', views.index, name='index'), # Show all topics. url(r'^topics/$', views.topics, name='topics'), # Detail page for a single topic. url(r'^topics/(?P&lt;topic_id&gt;\d+)/$', views.topic, name='topic'),] 打开http://127.0.0.1:8000/topics/1/报错： 123456 Using the URLconf defined in learning_log.urls, Django tried these URL patterns, in this order: 1. admin/ 2. [name='index'] 3. topics [name='topics'] 4. topics/?P&lt;topic_id&gt;\d+/ [name='topic']The current path, topics/1/, didn't match any of these. 原因：Django2.0有更新对于django.urls.path()函数，允许有简单的表示方法： url(r’^articles/(?P[0-9]{4})/$’, views.year_archive), 可以写成： path(‘articles//‘, views.year_archive), 所以代码可更改为：12345678910111213from django.urls import pathfrom . import viewsapp_name = 'lerning_logs'urlpatterns = [ #主页 path('', views.index, name='index'), #显示所有主题 path('topics', views.topics, name='topics'), #特定主题的详细页面 #path('topics/?P&lt;topic_id&gt;\d+/', views.topic, name='topic'), path('topics/&lt;topic_id&gt;/', views.topic, name='topic'),]]]></content>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
