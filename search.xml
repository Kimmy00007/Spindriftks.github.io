<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python数据分离]]></title>
    <url>%2F2018%2F01%2F20%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[python数据分离——读取配置文件 版本：python 3.6 进行数据/配置和代码分离时，python3.6 可以使用configparser进行配置信息读取或创建。可以实现程序和数据的分离，便于后期维护程序，也能在一定程序上满足不会编码的人进行自动化测试（只需改配置文件。） 以创建/读取ini格式配置文件为例： 创建配置文件：每个ini文件都是有n个sections组成（可以理解为组成部分或者是段落。。我是这么理解的），每个sections包含若干个键值对（keys:values），所有某种程度上，你可以把每个section看成是个字典（dictionary），虽然这俩意义上完全无关。python3.6创建ini配置文件代码示例：1234567891011121314151617181920212223#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparsercf = configparser.ConfigParser()cf[&apos;DEFAULT&apos;] = &#123;&quot;browser&quot; : &quot;Chrome&quot;, &quot;version&quot; : &quot;63.0.3239.132&quot;, &quot;driver&quot; : &quot;chromedriver.exe&quot;, &#125;cf[&apos;tokyle.com&apos;] = &#123;&#125;cf[&apos;tokyle.com&apos;][&apos;Author&apos;] = &apos;kyle&apos;cf[&apos;baidu.com&apos;] = &#123;&#125;baiduSearch = cf[&apos;baidu.com&apos;]baiduSearch[&apos;searchBox&apos;] = &apos;id &gt; kw&apos;baiduSearch[&apos;searchButton&apos;] = &apos;id &gt; su&apos;cf[&apos;DEFAULT&apos;][&apos;noRetry&apos;] = &apos;yes&apos;with open(&apos;test.ini&apos;, &apos;w&apos;) as configfile: cf.write(configfile) 上述代码执行完成之后会在该.py文件所在目录下创建一个test.ini的配置文件，内容如下：123456789101112[DEFAULT]browser = Chromeversion = 63.0.3239.132driver = chromedriver.exenoretry = yes[tokyle.com]author = kyle[baidu.com]searchbox = id &gt; kwsearchbutton = id &gt; su 每个ini文件可以包含一个[&#39;DEFAULT&#39;] section，也可以没有，[&#39;DEFAULT&#39;]部分定义了默认设置，例如默认使用的浏览器，浏览器版本等。 读取配置信息1234import configparsercf = configparser.ConfigParser()cf.read(&apos;test.ini&apos;) 获取所有sections使用1cf.sections() 即可，需要注意的是，这样，是默认不会获取都[‘DEFAULT’]的，可以实验一下：12section = cf.sections()print(section) 打印出的结果：1[&apos;tokyle.com&apos;, &apos;baidu.com&apos;] 可以看见默认不包含[‘DEFAULT’]。 其实读取配置信息就喝读取字典里的数据做法一样，使用for循环就可以打印出全部信息，例如进行自动化测试时想获取[‘baidu.com’]里存的百度搜索输入框以及百度一下按键，可以：123baidu_msg = cf[&apos;baidu.com&apos;]for key,value in baidu_msg.items(): print(key + &apos; : &apos; + value) 打印出的信息：123456searchbox : id &gt; kwsearchbutton : id &gt; subrowser : Chromeversion : 63.0.3239.132driver : chromedriver.exenoretry : yes 可以看见，这样不仅会把[‘baidu.com’]模块的信息全部打印，[‘DEFAULT’]模块的信息也会被打印出来。 使用配置文件实例(简单的数据分离)：123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparserimport traceback,timefrom selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom nose.tools import assert_trueclass ElementId(): def __init__(self): #读取配置文件 self.cf = configparser.ConfigParser() self.cf.read(&apos;test.ini&apos;) self.cf.sections() def get_elementId(self, driver, webSiteName, webelement): try: #获取配置文件中的定位方法以及定位元素 webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;) webelement_method = webElemnt[0].strip() webelement_expression = webElemnt[1].strip() element = WebDriverWait(driver, 10).until\ (lambda x: x.find_element(webelement_method, webelement_expression)) except Exception as e: print(traceback.print_exc(), e) else: return elementif __name__ == &apos;__main__&apos;: &quot;&quot;&quot;测试百度搜索&quot;&quot;&quot; #打开百度首页 browser = webdriver.Chrome() browser.get(&quot;https://www.baidu.com&quot;) #获取定位元素 elementid = ElementId() searchBox = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbox&apos;) searchBox.send_keys(&apos;selenium&apos;) searchButton = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbutton&apos;) searchButton.click() time.sleep(3) #断言完成百度搜索&quot;selenium&quot; assert_true(u&quot;Selenium - Web Browser Automation&quot; in browser.page_source) browser.quit() （我在执行上述示例之前，把test.ini中的[‘DEFAULT’]注释掉了，此例不需要[‘DEFAULT’]中的信息）]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自娱自乐一]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%87%AA%E5%A8%B1%E8%87%AA%E4%B9%90%E4%B8%80%2F</url>
    <content type="text"><![CDATA[自娱自乐系列一： 为了过年提前回家，周六过来加班调休，又不大想干活，就想着捣鼓点自娱自乐的东西： 输入年龄判断是否有投票资格：1234567891011121314151617def judge_age(): while True: try: age = int(input(&quot;\nPlease enter your age：&quot;)) except ValueError: print(&quot;Sorry,I can&apos;t understand what you entered.Please enter a correct number.&quot;) continue else: break if age &gt;= 18: print(&quot;You are able to vote in the United States!&quot;) else: print(&quot;You are too young to vote in the United States!&quot;)if __name__ == &apos;__main__&apos;: judge_age() 判断输入的正整数:12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-def get_non_negative_int(prompt): try: value = int(input(prompt)) except ValueError: print(&quot;Sorry,I can&apos;t understand that.&quot;) return get_non_negative_int(prompt) if value &lt; 0: print(&quot;Sorry,your response must not be negative.&quot;) return get_non_negative_int(prompt) else: return valuedef guess_number(): number = get_non_negative_int(&quot;Please enter a number to guess: (only positive integer can work,thanks!)&quot;) while True: guess = get_non_negative_int(&quot;guess the number.&quot;) if guess &gt; number: print(&quot;You could enter a lower one.&quot;) elif guess &lt; number: print(&quot;I think it could be higher.&quot;) else: print(&quot;Congratulations! You got it!&quot;) breakif __name__ == &apos;__main__&apos;: guess_number() 纯属自娱自乐，毫无技术含量 Thanks?(?ω?)? 顺便贴个常识坑：文件夹不能取名是code，否则pycharm的debug模式会报错！！！（stackoverflow真是个好网站！什么坑都能找到填的办法。。）原因：debug模式会引个包：1from code import InteractiveConsole 工程中有code文件夹，会找不到debug需要的方法]]></content>
      <categories>
        <category>just for fun</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lives</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium应用简介]]></title>
    <url>%2F2018%2F01%2F19%2Fappium%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[appium应用篇，简单介绍自己工作中用到的一些appium应用。 Appium等待类型固定时间等待123import timetime.sleep(3) 固定等待时间3秒，强制等待，必须等完3秒之后才会进行下一步操作。 隐式等待1driver.implicitly_wait(5) 隐式等待的好处是不用想固定时间（time.sleep()）一样死等固定时间，可以在一定程度上提高执行效率，但是这种等待方式也是需要等页面所有元素都加载完成才会去进行下一步操作，例如有的时候，页面你需要的元素已经加载完成，但是必须还是要等待个别资源加载完才会执行下一步，一定程度上来说还是效率降低。 显示等待1234from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver, 10).\ until(lambda x:x.find_element_by_id(&apos;com.anmav.cashierdesk:id/tvOpenTable&apos;)) 显示等待原理是每隔一段时间（默认0.5秒），执行一次判断条件，如果条件成立，就执行下一步，直到超过设定的最大等待时间，抛出TimeoutException异常 Appium定位弹窗切换webview原理和selenium一样，类似于selenium中先获取页面句柄，再切换。1234driver.contexts方法一：driver.switch_to.context(&quot;contextname&quot;) #contextname为想切换到的上下文方法二：driver.switch_to.context(contexts[1]) # 从contexts里取第二个参数]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python项目依赖管理工具-pipenv]]></title>
    <url>%2F2018%2F01%2F18%2Fpython%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pipenv%2F</url>
    <content type="text"><![CDATA[偶然发现一个很好用的python项目包管理工具pipenv github上简介是一句话Pipenv: Python Development Workflow for Humans 现在已经是python.org官方推荐的工具。 具体功能：pipenv能够自动创建和管理你工程的虚拟环境，当你安装/卸载包时，会自动从你的Pipfile中添加/移除包；为啥要用这个工具，python的特点，python进行工程环境创建，一般是创建一个Virtualenv虚拟环境，然后列出所需要的工具包，pip安装，但是这样你就要手动去添加你需要的包，删除你已经不需要的包，并且由于工具包的更新，你可能还需要手动去更新你的工具包，而且，类似于单元测试这样的场景，需要安装nose包，但是生产环境又不需要该包，也就无法做到生产环境和开发环境安装包的分离，而以上这些，pipenv都可以解决。 使用简介首先安装pipenv使用pip安装pipenv及其依赖项1pip install pipenv macOS安装则使用1brew install pipenv 进入你项目所在文件夹，启动Pipenv12cd your_projectpipenv install 启动之后，项目文件夹下会多出两个文件Pipfile，Pipfile.lockPipfile文件包含项目的依赖包信息。 管理依赖包要为项目安装依赖包，跟pip类似1pipenv install nose 卸载1pipenv uninstall nose 可以通过更新Pipfile.lock来冻结软件包名称及其版本以及其自己的依赖关系的列表。 这是使用lock关键字完成:1pipenv lock 如果你同事或者朋友想clone你的依赖库，直接拿你的Pipfile，然后他本地安装pipenv之后，pipenv install即可完成依赖库安装 环境分离只为开发环境安装包：1pipenv install --dev nose 这样，在生产环境执行pipenv install是不会安装nose的，想要安装开发环境的依赖，执行：1pipenv install --dev 用法pipenv所有关键字及解释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update Update Pipenv &amp; pip to latest. --where Output project home information. --venv Output virtualenv information. --py Output Python interpreter information. --envs Output Environment Variable options. --rm Remove the virtualenv. --bare Minimal output. --completion Output completion (to be eval&apos;d). --man Display manpage. --three / --two Use Python 3/2 when creating virtualenv. --python TEXT Specify which version of Python virtualenv should use. --site-packages Enable site-packages for the virtualenv. --jumbotron An easter egg, effectively. --version Show the version and exit. -h, --help Show this message and exit.Usage Examples: Create a new project using Python 3.6, specifically: $ pipenv --python 3.6 Install all dependencies for a project (including dev): $ pipenv install --dev Create a lockfile containing pre-releases: $ pipenv lock --pre Show a graph of your installed dependencies: $ pipenv graph Check your installed dependencies for security vulnerabilities: $ pipenv check Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e .Commands: check Checks for security vulnerabilities and... graph Displays currently–installed dependency graph... install Installs provided packages and adds them to... lock Generates Pipfile.lock. open View a given module in your editor. run Spawns a command installed into the... shell Spawns a shell within the virtualenv. uninstall Un-installs a provided package and removes it... update Uninstalls all packages, and re-installs... 定位工程展示工程路径以及环境路径，进入工程(类似于linux)：1pipenv --where 1pipenv --venv 定位python解释器：1pipenv --py 其他使用激活工程环境1pipenv shell 运行python脚本1pipenv run python main.py 展示依赖关系图1pipenv graph 卸载所有1pipenv uninstall --all 参考地址 github项目地址python.org官网推荐地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder简介]]></title>
    <url>%2F2018%2F01%2F18%2Fcmder%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[windows小工具介绍 windows系统cmd工具，说实话，用的还是有点不舒服的，用习惯vim之后，真的是很想在windows上用类似的，还好，找到个小工具cmder。 下载地址：照旧，官方下载地址是托管在github上 github下载地址 但是不知道最近抽什么疯，github上n多项目下载页面直接404，索性提供本地度娘盘地址： 度娘盘地址 使用说明下载完成之后，解压缩，然后将cmder.exe所在目录添加到系统环境变量中，完成~双击打开即可使用。 简单设置解决中文乱码问题：类似于linux，alias文件中添加设置即可；alias文件位置：cmder/config/aliases添加：123l=ls --show-control-charsla=ls -aF --show-control-charsll=ls -alF --show-control-chars 中文字重叠在一起cmder进入设置（快捷键win+alt+p），找到main，取消monospace(固定宽度)勾选 基本就是设置完成了，可以进行使用了，后续再发现什么其他的好功能再更新。123456789#切换盘D:#展示文件lsll#查看文件内容cat xxx.txt#编辑文件内容vim xxx.txt]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium键盘事件]]></title>
    <url>%2F2018%2F01%2F17%2Fappium%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[appium键盘事件 语法：1driver.keyevent(keyCode) 电话键1234567891011121314KEYCODE_CALL 拨号键 5KEYCODE_ENDCALL 挂机键 6KEYCODE_HOME 按键Home 3KEYCODE_MENU 菜单键 82KEYCODE_BACK 返回键 4KEYCODE_SEARCH 搜索键 84KEYCODE_CAMERA 拍照键 27KEYCODE_FOCUS 拍照对焦键 80KEYCODE_POWER 电源键 26KEYCODE_NOTIFICATION 通知键 83KEYCODE_MUTE 话筒静音键 91KEYCODE_VOLUME_MUTE 扬声器静音键 164KEYCODE_VOLUME_UP 音量增加键 24KEYCODE_VOLUME_DOWN 音量减小键 25 控制键123456789101112131415161718192021KEYCODE_ENTER 回车键 66KEYCODE_ESCAPE ESC键 111KEYCODE_DPAD_CENTER 导航键 确定键 23KEYCODE_DPAD_UP 导航键 向上 19KEYCODE_DPAD_DOWN 导航键 向下 20KEYCODE_DPAD_LEFT 导航键 向左 21KEYCODE_DPAD_RIGHT 导航键 向右 22KEYCODE_MOVE_HOME 光标移动到开始键 122KEYCODE_MOVE_END 光标移动到末尾键 123KEYCODE_PAGE_UP 向上翻页键 92KEYCODE_PAGE_DOWN 向下翻页键 93KEYCODE_DEL 退格键 67KEYCODE_FORWARD_DEL 删除键 112KEYCODE_INSERT 插入键 124KEYCODE_TAB Tab键 61KEYCODE_NUM_LOCK 小键盘锁 143KEYCODE_CAPS_LOCK 大写锁定键 115KEYCODE_BREAK Break/Pause键 121KEYCODE_SCROLL_LOCK 滚动锁定键 116KEYCODE_ZOOM_IN 放大键 168KEYCODE_ZOOM_OUT 缩小键 169 组合键123456KEYCODE_ALT_LEFT Alt+LeftKEYCODE_ALT_RIGHT Alt+RightKEYCODE_CTRL_LEFT Control+LeftKEYCODE_CTRL_RIGHT Control+RightKEYCODE_SHIFT_LEFT Shift+LeftKEYCODE_SHIFT_RIGHT Shift+Right 基本123456789101112131415161718192021222324252627282930313233343536KEYCODE_0 按键&apos;0&apos; 7KEYCODE_1 按键&apos;1&apos; 8KEYCODE_2 按键&apos;2&apos; 9KEYCODE_3 按键&apos;3&apos; 10KEYCODE_4 按键&apos;4&apos; 11KEYCODE_5 按键&apos;5&apos; 12KEYCODE_6 按键&apos;6&apos; 13KEYCODE_7 按键&apos;7&apos; 14KEYCODE_8 按键&apos;8&apos; 15KEYCODE_9 按键&apos;9&apos; 16KEYCODE_A 按键&apos;A&apos; 29KEYCODE_B 按键&apos;B&apos; 30KEYCODE_C 按键&apos;C&apos; 31KEYCODE_D 按键&apos;D&apos; 32KEYCODE_E 按键&apos;E&apos; 33KEYCODE_F 按键&apos;F&apos; 34KEYCODE_G 按键&apos;G&apos; 35KEYCODE_H 按键&apos;H&apos; 36KEYCODE_I 按键&apos;I&apos; 37KEYCODE_J 按键&apos;J&apos; 38KEYCODE_K 按键&apos;K&apos; 39KEYCODE_L 按键&apos;L&apos; 40KEYCODE_M 按键&apos;M&apos; 41KEYCODE_N 按键&apos;N&apos; 42KEYCODE_O 按键&apos;O&apos; 43KEYCODE_P 按键&apos;P&apos; 44KEYCODE_Q 按键&apos;Q&apos; 45KEYCODE_R 按键&apos;R&apos; 46KEYCODE_S 按键&apos;S&apos; 47KEYCODE_T 按键&apos;T&apos; 48KEYCODE_U 按键&apos;U&apos; 49KEYCODE_V 按键&apos;V&apos; 50KEYCODE_W 按键&apos;W&apos; 51KEYCODE_X 按键&apos;X&apos; 52KEYCODE_Y 按键&apos;Y&apos; 53KEYCODE_Z 按键&apos;Z&apos; 54]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium定位]]></title>
    <url>%2F2018%2F01%2F17%2Fappium%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[appium的常用操作以及元素定位的简单介绍 appium常用操作锁屏1driver.lock(5) 切换应用至后台123driver.background_app(5) # 置于后台，持续5秒driver.background_app(-1) # 持续置于后台driver.background_app(&#123;&apos;timeout&apos;: None&#125;) # 持续置于后台 收起键盘1driver.hide_keyboard() 启动Activity1driver.start_activity(&apos;com.example.android.apis&apos;, &apos;.Foo&apos;) 检测应用是否被安装1driver.is_app_installed(&apos;com.example.android.apis&apos;) 安装应用1driver.install_app(&apos;path/to/my.apk&apos;) 卸载应用1driver.remove_app(&apos;com.example.android.apis&apos;) 模拟设备摇一摇1driver.shake() 关闭应用1driver.close_app() 启动应用使用前提是desired capabilities设置了 autoLaunch=false 关键字1driver.launch_app() 操作上下文（Contexts）获取所有1driver.contexts 获取当前1driver.current_context 切换至默认1driver.switch_to.context(None) 按键事件1driver.keyevent(176) 具体键值 点击操作/多点触控操作12action = TouchAction(driver)action.press(element=el, x=10, y=10).release().perform() 滑动屏幕1driver.swipe(start_x=75, start_y=500, end_x=75, end_y=0, duration=800) 从设备拉去文件1driver.pull_file(&apos;Library/AddressBook/AddressBook.sqlitedb&apos;) 推送文件到设备123data = &quot;some data for the file&quot;path = &quot;/data/local/tmp/file.txt&quot;driver.push_file(path, data.encode(&apos;base64&apos;)) appium元素定位使用id，class等和selenium基本没差别的定位就不介绍了，主要介绍appium独有uiautomator UiSelector 页面class和id等都不能唯一确定元素，但是元素有text属性时，可以使用以下进行定位：1234driver.find_element_by_android_uiautomator(&apos;new UiSelector().text(&quot;Custom View&quot;)&apos;).click() #textdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textContains(&quot;View&quot;)&apos;).click() #textContainsdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textStartsWith(&quot;Custom&quot;)&apos;).click() #textStartsWithdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textMatches(&quot;^Custom.*&quot;)&apos;).click() #textMatches 也可以加上class属性：12driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.TextView&quot;).text(&quot;Custom View&quot;)&apos;).click() #classNamedriver.find_element_by_android_uiautomator(&apos;new UiSelector().classNameMatches(&quot;.*TextView$&quot;).text(&quot;Custom View&quot;)&apos;).click() #classNameMatches 多条件精准定位1driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.EditText&quot;).resourceId(&quot;com.anmav.cashierdesk:id/etToPayPrice&quot;)&apos;) 操作坐标appium在进行元素定位时，定位不到唯一标志的元素，可以获取元素的坐标，使用坐标进行操作 appium以及uiautomatorviewer都可以很容易获取到坐标 appium操作坐标 1driver.tap([(100, 20), (100, 60), (100, 100)], 500) 三个坐标表示模拟三根手指，只需要一个手指，改成一个坐标即可，500表示持续时间500ms 或者使用adb命令也可实现同样效果：1os.popen(&quot;adb shell input tap &quot; + str(100) + &quot; &quot; + str(20)) 参考文章 appium 基础之键盘处理appium-bindings]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app安装卸载]]></title>
    <url>%2F2018%2F01%2F17%2Fapp%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[appium-模拟器安装卸载app 模拟器安装apk1adb install XXX.apk 卸载apk1adb uninstall your_package 例子： 启动android模拟器，参数：12345desired_caps[&apos;platformName&apos;] = &apos;Android&apos;desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos;desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.view.LoginActivity&apos; win10打开控制台，进入apk文件所在目录，执行命令1adb install cashierdesk.apk 在模拟器中可以发现该app已完成安装。 控制台执行命令：1adb remove com.anmav.cashierdesk 模拟器中可以看见该app完成卸载]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium入门篇]]></title>
    <url>%2F2018%2F01%2F16%2Fappium%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[appium环境搭建及简单使用 测试人员进行app自动化测试的可选框架之一—— appium 平台说明：12WIN10_64python 3.6 appium环境安装安装Android Studio网上之前的教程基本都是安装SDK或者ADT来进行安装，开始我也是这么装的，在最后创建完虚拟机，开启虚拟机时候报错了，报错信息只记得是建议安装Android Studio，索性也就换成了Android Studio。 Android Studio下载链接 如果下载的是不包含SDK的版本，还需要另外下载SDK。安装Android Studio很简单，和Pycharm一模一样，有使用Pycharm经验或者IntelliJ IDEA的应该很熟悉，安装完成之后，找到SDK Manager1File-Settings-Appearance&amp;Behavior &gt; System Settings &gt; Android SDK 如果本地有SDK，可以在此选择本地的SDK路径，该设置页也支持下载各种SDK Platforms。对应的SDK安装完成之后就可以进行创建虚拟机，找到AVD Manager按键，点击创建。 安装Android SDK（和安装Android Studio任选一种方式即可）官方下载地址 但是由于国内众所周知的某种原因，不能科学上网貌似无法保证可以下载~ 国内优质android工具网站 搜索android-sdk找到对应系统版本，进行下载。 配置android环境变量与配置JAVA环境变量类似，新增系统变量123456变量名：ANDROID_HOME 变量值：D:\android\android-sdk-windows变量名：PATH变量值：;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; SDK Manager安装模拟器在你本地解压完成之后的android-sdk-windows目录下找到SDK Manager.exe，双击打开； 配置参考 安装SDK Platform-Tools在AndroidDevTools.cn 网站上找到Android SDK Platform-tools下载链接，下载，解压，把解压出来的 platform-tools 文件夹放在android-sdk-windows目录下 安装Appium安装方式一： 使用NodeJS 安装1，首先到官网下载安装最新的NodeJS，Windows下属于傻瓜安装。安装完成验证npm或者node -v不报错表明安装完成 2，安装appium，npm install -g appium命令安装appium（个人实验的效果不好，太慢了，建议采用第二种，安装包安装） 安装方式二：安装包安装建议直接安装appium-desktop，appium server在2015年就不再更新，取而代之的是appium-desktop的出现。 Appium安装包托管在github上，下载地址 但是个人实验，很多版本都是跳转404页面。。。无语。。。 个人网盘地址，密码：v3lt（版本1.2.7） 下载完成后，安装即可。 appium环境检查可以使用appium-doctor工具进行环境检查，npm install -g appium-doctor进行安装。 Appium-desktop使用简介打开appium-desktop，点击“放大镜”图标进行设置， 设置完成后点击 Start Session 直接单击最左栏的元素，在中间和右边会显示该元素属性，找到对应的ID值等，定位方式和selenium类似。 查找appPackage和appActivityappium进行自动化测试，需要appPackage和appActivity两个参数，下面是从apk文件获取的方法： apk反编译apktool 地址： apktool 用法1java -jar apktool.jar d yourApkFile.apk 获取appPackage和appActivity打开apk反编译之后的文件夹，打开AndroidManifest.xml文件 package获取 appPackage，activity获取appActivity。 appium Demo实现计算器计算，代码：1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-from appium import webdriverimport timedesired_caps = &#123;&#125;desired_caps[&apos;platformName&apos;] = &apos;Android&apos;desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;desired_caps[&apos;appPackage&apos;] = &apos;com.android.calculator2&apos;desired_caps[&apos;appActivity&apos;] = &apos;.Calculator&apos;desired_caps[&apos;noReset&apos;] = Truedriver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, desired_caps)driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()driver.find_element_by_accessibility_id(&apos;multiply&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_9&apos;).click()driver.find_element_by_accessibility_id(&apos;plus&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_1&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()driver.find_element_by_accessibility_id(&apos;equals&apos;).click()time.sleep(3)driver.quit()]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smtp发邮件]]></title>
    <url>%2F2018%2F01%2F12%2Fsmtp%E5%8F%91%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用python3发送网易邮箱邮件 代码：12345678910111213141516import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerdef send_email(mail_host, from_account, from_passwd, to_account, subject, content): mail = smtplib.SMTP() mail.connect(mail_host) mail.login(from_account, from_passwd) # 发送邮件 message = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;) message[&apos;From&apos;] = from_account message[&apos;To&apos;] = to_account message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) mail.sendmail(from_account, to_account, message.as_string()) 菜鸟教程上有一种写法12345678910111213141516171819202122232425262728293031#!/usr/bin/python3 import smtplibfrom email.mime.text import MIMETextfrom email.header import Header # 第三方 SMTP 服务mail_host=&quot;smtp.XXX.com&quot; #设置服务器mail_user=&quot;XXXX&quot; #用户名mail_pass=&quot;XXXXXX&quot; #口令 sender = &apos;from@runoob.com&apos;receivers = [&apos;429240967@qq.com&apos;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)message[&apos;To&apos;] = Header(&quot;测试&quot;, &apos;utf-8&apos;) subject = &apos;Python SMTP 邮件测试&apos;message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print (&quot;邮件发送成功&quot;)except smtplib.SMTPException: print (&quot;Error: 无法发送邮件&quot;) 这样执行，会报错smtplib.SMTPDataError: (554, &#39;DT:SPM 126 smtp5,jtKowAD3MJz2c1JXLcK2AA--.52114S2 1465021431,please see http://mail.163.com/help/help_spam_16.htm?ip=123.114.121.110&amp;hostid=smtp5&amp;time=1465021431&#39;) 解决办法就是指定收发件人12message[&apos;From&apos;] = from_accountmessage[&apos;To&apos;] = to_account p.s 网易邮箱客户端默认授权码是关闭的，直接执行python调用会失败，要先进客户端，把客户授权码打开位置：设置-客户端授权密码设置完成之后，登录密码就使用你设置的授权码]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>smtplib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium无干预下载]]></title>
    <url>%2F2018%2F01%2F10%2Fselenium%E6%97%A0%E5%B9%B2%E9%A2%84%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[selenium自带了无人工干预实现下载功能的模块，下载时不需要弹窗点击确定下载 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverimport timeclass MacDownload(): def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; # 创建一个FirefoxProfile实例，用于存放自定义配置 profile = webdriver.FirefoxProfile() # 指定下载路径，默认自动创建一级目录 profile.set_preference(&apos;browser.download.dir&apos;, &apos;G:\idownload&apos;) # 将browser.download.folderLis设置为2，表示将文件下载到指定目录（0表示桌面，1表示默认路径） profile.set_preference(&quot;browser.download.folderList&quot;, 2) # browser.helperApps.alwaysAsk.force对于未知的MIME类型文件会弹出窗口 # 让用户处理，默认值为True，设定为False表示不会记录打开未知MIME类型文件的方式 profile.set_preference(&quot;browser.helperApps.alwaysAsk.force&quot;, False) # 在开始下载时是否显示下载管理器 profile.set_preference(&quot;browser.download.manager.showWhenStarting&quot;, False) # 设定为False会把下载狂隐藏 profile.set_preference(&quot;browser.download.manager.useWindow&quot;, False) # 默认为True，设定为False表示不获取焦点 profile.set_preference(&quot;browser.download.manager.focusWhenStarting&quot;, False) # 下载.exe文件弹出警告，默认值为True，设定为False则不会弹出警告 profile.set_preference(&quot;browser.download.manager.alertOnEXEOpen&quot;, False) # browser.helperApps.neverAsk.openFile表示直接打开下载文件，不显示确定框 # 默认值为空字符串，下行代码行设定了多种文件的MIME类型， # 例如application/exe,表示 .exe类型的文件；application/excel表示excel类型的文件 profile.set_preference(&quot;browser.helperApps.neverAsk.openFile&quot;, &quot;application/pdf&quot;) # 对所给出文件类型不在弹出提示框进行询问，直接保存到本地磁盘 profile.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/zip, application/octet-stream&quot;) # browser.download.manager.showAlertOnComplete设定下载文件结束后是否显示下载完成提示框 # 默认为True，设定为False表示下载完成后不显示下载完成提示框 profile.set_preference(&quot;browser.download.manager.showAlertOnComplete&quot;, False) # browser.download.manager.closeWhenDone设定下载结束后是都自动关闭下载框 # 默认为True，设定为False表示不关闭下载管理器 profile.set_preference(&quot;browser.download.manager.closeWhenDone&quot;, False) # 启动浏览器，通过firfox_profile参数将自动配置添加到FirefoxProfile对象中sef.driver = webdriver.Firefox(firefox_profile=profile) self.driver = webdriver.Firefox(firefox_profile=profile) def test_dataPicker(self): #访问WebDriver驱动firefox的驱动文件下载网址 # url1 = &quot;https://github.com/mozilla/geckodriver/releases&quot; # self.driver.get(url1) # #选择下载ZIP类型的文件，使用application/zip指代此类型文件 # self.driver.find_element_by_xpath(&apos;//strong[. = &quot;geckodriver-v0.19.1-win32.zip&quot;]&apos;).click() # time.sleep(10) #访问Python2.7.12文件下载页面，下载扩展名为msi的文件 #使用application/octet - stream来指明次文件类型 url = &quot;https://www.python.org/downloads/release/python-2712/&quot; self.driver.get(url) self.driver.find_element_by_link_text(&apos;Windows x86-64 MSI installer&apos;).click() time.sleep(100) self.driver.quit()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306余票监控]]></title>
    <url>%2F2018%2F01%2F10%2F12306%E4%BD%99%E7%A5%A8%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[翻日历突然意识到，好像要放假了，又是一年春运时，就想着可不可以用selenium做个自己的监控12306余票的程序。 动手：思路也就是输入起点，终点，选择列车，选择座位，查询是否有余票。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timeclass monitorTickets(): &quot;&quot;&quot; 查询12306硬座，硬卧，软卧余票 &quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; #使用chrome浏览器打开查询12306查询页面 self.browser = webdriver.Chrome() url = &apos;https://kyfw.12306.cn/otn/leftTicket/init&apos; self.browser.get(url) def search_tickets(self,train_name, start_stations, end_stations, ticket_id): &quot;&quot;&quot;循环获取余票&quot;&quot;&quot; print(&quot;开始查询【%s】次列车余票信息&quot; % train_name) for start_station in start_stations: try: for end_station in end_stations: #输入起点 starts = self.browser.find_element_by_id(&quot;fromStationText&quot;) starts.click() starts.clear() starts.send_keys(start_station) starts.send_keys(Keys.ENTER) #输入到站 ends = self.browser.find_element_by_id(&quot;toStationText&quot;) ends.click() ends.clear() ends.send_keys(end_station) ends.send_keys(Keys.ENTER) #选择时间 #使用js将只读属性去除，完成选择时间 js = &apos;document.getElementById(&quot;train_date&quot;).removeAttribute(&quot;readonly&quot;);&apos; self.browser.execute_script(js) date = self.browser.find_element_by_id(&apos;train_date&apos;) date.clear() date.send_keys(&apos;2018-02-10&apos;) date.click() self.browser.find_element_by_id(&quot;query_ticket&quot;).click() time.sleep(2) text = self.browser.find_element_by_id(ticket_id).text if text == u&quot;无&quot;: print(u&quot;【%s】到【%s】的余票为0，节哀～&quot; % (start_station, end_station)) time.sleep(1) elif text == u&quot;*&quot;: print(u&quot;【%s】到【%s】的车票还未开售，请耐心等待～&quot; % (start_station, end_station)) time.sleep(1) else: print(u&quot;发现【%s】到【%s】的余票，抢!&quot; % (start_station, end_station)) except: continue print(&quot;结束查询【%s】次列车余票信息&quot; % train_name) def close_browser(self): &quot;&quot;&quot;关浏览器&quot;&quot;&quot; time.sleep(3) self.browser.quit()if __name__ == &apos;__main__&apos;: #查票 time.sleep(1) search_ticket = monitorTickets() while True: print(&quot;监控硬座&quot;) search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YZ_550000T11671&apos;) search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;YZ_550000Z21605&apos;) search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YZ_560000T11251&apos;) search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YZ_550000T20450&apos;) search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YZ_5500000Z4061&apos;) print(&quot;监控硬座结束&quot;) # print(&quot;监控硬卧&quot;) # search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YW_550000T11671&apos;) # search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;YW_550000Z21605&apos;) # search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YW_560000T11251&apos;) # search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YW_550000T20450&apos;) # search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YW_5500000Z4061&apos;) # print(&quot;监控硬卧结束&quot;) # # print(&quot;监控软卧&quot;) # search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;RW_550000T11671&apos;) # search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;RW_550000Z21605&apos;) # search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;RW_560000T11251&apos;) # search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;RW_550000T20450&apos;) # search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;RW_5500000Z4061&apos;) # print(&quot;监控软卧结束&quot;) # msg = input(&quot;Enter &apos;q&apos; to quit&quot;) # if msg == &apos;q&apos;: # break # search_ticket.close_browser()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录网易邮箱]]></title>
    <url>%2F2018%2F01%2F05%2F%E7%99%BB%E5%BD%95%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[基于python3的自动化测试框架selenium3实践 登录网易邮箱（126,163） 登录16312345678910111213#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timedriver = webdriver.Firefox()driver.get(&apos;http://mail.163.com/&apos;)driver.implicitly_wait(10)#切换iframedriver.switch_to_frame(&apos;x-URS-iframe&apos;)driver.find_element_by_name(&apos;email&apos;).send_keys(&apos;123&apos;)driver.find_element_by_name(&apos;password&apos;).send_keys(&apos;456&apos;)brower.find_element_by_name(&quot;password&quot;).send_keys(Keys.ENTER) 或者123456789101112131415#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timedriver = webdriver.Firefox()driver.get(&apos;http://mail.163.com/&apos;)driver.implicitly_wait(10)#切换iframeiframe = driver.find_elements_by_tag_name(&apos;iframe&apos;)driver.switch_to_frame(iframe)#driver.switch_to.frame(&apos;x-URS-iframe&apos;)driver.find_element_by_name(&apos;email&apos;).send_keys(&apos;123&apos;)driver.find_element_by_name(&apos;password&apos;).send_keys(&apos;456&apos;)brower.find_element_by_name(&quot;password&quot;).send_keys(Keys.ENTER) 登录12612345678910#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.keys import Keysdriver=webdriver.Firefox()driver.get(&quot;http://mail.126.com&quot;)driver.implicitly_wait(10)driver.switch_to.frame(&quot;x-URS-iframe&quot;) #切换framedriver.find_element_by_name(&quot;email&quot;).send_keys(&quot;123&quot;) #使用name定位driver.find_element_by_name(&apos;password&apos;).send_keys(&apos;456&apos;)brower.find_element_by_name(&quot;password&quot;).send_keys(Keys.ENTER)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nose跳过测试]]></title>
    <url>%2F2018%2F01%2F04%2Fnose%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[nose进行单元测试，和unittest一样，有跳过某个方法，指定特定类进行测试的功能。 识别规则使用nose进行单元测试，测试用例识别规则如下：12345nosetests only_test_this.pynosetests test.modulenosetests another.test:TestCase.test_methodnosetests a.test:TestCasenosetests /path/to/test/file.py:test.function 示例执行全部测试直接代码示例：12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-import tracebackfrom nose.tools import eq_from nose.plugins.attrib import attrfrom nose.plugins.skip import SkipTestfrom functools import reduceclass test_nosetests(): #测试加法 def test_sum(self): a = 1 b = 2 res = 3 eq_(a+b,res) #测试乘法 def test_mul(self): a = 1 b = 2 res = 2 eq_(a*b, res) #测试除法 def test_div(self): a = 2 b = 0 res = 1 try: eq_(a/b, res) except ZeroDivisionError as e: print(traceback.print_exc()) #测试reduce函数 def test_reduce(self): req = range(1,6) a = 120 res = reduce(lambda x, y: x*y, req) eq_(a, res) 想要对test_nosetests该方法进行测试，可以： 121. nosetests -v NoseTestsexercise.py --with-html --html-file=G:/workstation/report/test_nosetests.html2. nosetests -v NoseTestsexercise.py:test_nosetests --with-html --html-file=G:/workstation/report/test_nosetests.html 由于该python文件只有这一个测试类，所以直接nosetests该python文件即可以进行测试，或者是指定该python文件的测试类如NoseTestsexercise.py:test_nosetests方式 测试结果： 执行指定方法的测试执行指定的一个方法：1nosetests -v NoseTestsexercise.py:test_nosetests.test_reduce --with-html --html-file=G:/workstation/report/test_nosetests.html 示例执行了test_nosetests类下的test_reduce方法的测试 测试结果： 跳过指定方法的测试有的时候，只需要跳过某个方法：例如想跳过test_mul该方法，只需要在代码上增加跳过标志即可1234567#测试乘法 def test_mul(self): a = 1 b = 2 res = 2 eq_(a*b, res) raise SkipTest 执行：1nosetests -v NoseTestsexercise.py:test_nosetests --with-html --html-file=G:/workstation/report/test_nosetests.html 测试结果： 其他另外，nosetests也有用例执行优先级的功能1234from nose.plugins.attrib import attr @attr(speed=&apos;slow&apos;) def test_big_download(self): print(&apos;pass&apos;) 执行只需要：nosetests -a speed=slow即可 参考用法]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python单元测试框架-nose]]></title>
    <url>%2F2018%2F01%2F03%2Fpython%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-nose%2F</url>
    <content type="text"><![CDATA[python单元测试框架 nose简介 简介nose是python单元测试的另一框架，nose可以自动识别继承于unittest.TestCase的测试单元，并执行测试，而且，nose也可以测试非继承于unittest.TestCase的测试单元。nose提供了丰富的API便于编写测试代码。 安装及使用安装：1pip install nose 基本语法：1nosetests [options] [(optional) test files or directories] 扩展使用nose自动收集单元测试，收集它当前工作目录下的源代码文件、目录以及包。任何的源代码文件、目录或者包只要匹配正则表达式，他们就会被自动收集。包的测试收集按照树的层级级别一级一级进行，因此package.tests、package.sub.tests、package.sub.sub2.tests将会被收集。 扩展插件nose支持多种插件，可完成基本大部分测试需要。nose拥有很多内置的插件帮助进行输出抓取、错误查找、代码覆盖、文档测试（doctest）等等。 命令行执行命令可查看插件：1nosetests –plugins 若想查看详细信息，可执行12nosetests –plugins -vnosetests –plugins -vv nose使用nose使用和unittest类似，unittest的断言，nose.tools中都可以选择使用使用示例：unittest：123456789101112131415161718import unittestclass NoseTest(unittest.TestCase): def setUp(self): print(&quot;=============setUp===============&quot;) def test_Pass(self): print(&quot;==========begin test=========&quot;) a = 1 b = 2 self.assertTrue(a == b, &apos;断言失败, %a != %a&apos;% (a, b)) def tearDown(self): print(&quot;==============tearDown===============&quot;)if __name__ == &apos;__main__&apos;: unittest.main() nose:12345678from nose.tools import eq_from nose.tools import assert_equalclass noseTest(): a = 1 b = 2 #assert_equal(a, b, &apos;%a != %a&apos;%(a,b)) eq_(a, b) nose也支持在代码中直接运行nose.main()或者nose.run()这样类似于unittest的方式，但是还是建议在命令行中运行nosetests来执行单元测试参考示例：1nosetests -v HandleFrameByPageSource.py:test_handleFrameByPageSource --with-html --html-file=G:\workstation\report\handleframe.html 说明：1234nosetests -v: 显示详细的运行信息和调试信息HandleFrameByPageSource.py:test_handleFrameByPageSource ：测试对象为该python文件下的test_handleFrameByPageSource类--with-html ：使用html插件,生成标准HTML格式测试报告--html-file=G:\workstation\report\handleframe.html ：测试结果输出为该路径下handleframe.html文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32api_VK_CODE]]></title>
    <url>%2F2018%2F01%2F02%2Fwin32api-VK-CODE%2F</url>
    <content type="text"><![CDATA[python使用win32api模块，可模拟键盘按键，应用于爬虫及自动化测试。 键盘按键对应的Vitual keystroke如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535#Giant dictonary to hold key name and VK valueVK_CODE = &#123;&apos;backspace&apos;:0x08, &apos;tab&apos;:0x09, &apos;clear&apos;:0x0C, &apos;enter&apos;:0x0D, &apos;shift&apos;:0x10, &apos;ctrl&apos;:0x11, &apos;alt&apos;:0x12, &apos;pause&apos;:0x13, &apos;caps_lock&apos;:0x14, &apos;esc&apos;:0x1B, &apos;spacebar&apos;:0x20, &apos;page_up&apos;:0x21, &apos;page_down&apos;:0x22, &apos;end&apos;:0x23, &apos;home&apos;:0x24, &apos;left_arrow&apos;:0x25, &apos;up_arrow&apos;:0x26, &apos;right_arrow&apos;:0x27, &apos;down_arrow&apos;:0x28, &apos;select&apos;:0x29, &apos;print&apos;:0x2A, &apos;execute&apos;:0x2B, &apos;print_screen&apos;:0x2C, &apos;ins&apos;:0x2D, &apos;del&apos;:0x2E, &apos;help&apos;:0x2F, &apos;0&apos;:0x30, &apos;1&apos;:0x31, &apos;2&apos;:0x32, &apos;3&apos;:0x33, &apos;4&apos;:0x34, &apos;5&apos;:0x35, &apos;6&apos;:0x36, &apos;7&apos;:0x37, &apos;8&apos;:0x38, &apos;9&apos;:0x39, &apos;a&apos;:0x41, &apos;b&apos;:0x42, &apos;c&apos;:0x43, &apos;d&apos;:0x44, &apos;e&apos;:0x45, &apos;f&apos;:0x46, &apos;g&apos;:0x47, &apos;h&apos;:0x48, &apos;i&apos;:0x49, &apos;j&apos;:0x4A, &apos;k&apos;:0x4B, &apos;l&apos;:0x4C, &apos;m&apos;:0x4D, &apos;n&apos;:0x4E, &apos;o&apos;:0x4F, &apos;p&apos;:0x50, &apos;q&apos;:0x51, &apos;r&apos;:0x52, &apos;s&apos;:0x53, &apos;t&apos;:0x54, &apos;u&apos;:0x55, &apos;v&apos;:0x56, &apos;w&apos;:0x57, &apos;x&apos;:0x58, &apos;y&apos;:0x59, &apos;z&apos;:0x5A, &apos;numpad_0&apos;:0x60, &apos;numpad_1&apos;:0x61, &apos;numpad_2&apos;:0x62, &apos;numpad_3&apos;:0x63, &apos;numpad_4&apos;:0x64, &apos;numpad_5&apos;:0x65, &apos;numpad_6&apos;:0x66, &apos;numpad_7&apos;:0x67, &apos;numpad_8&apos;:0x68, &apos;numpad_9&apos;:0x69, &apos;multiply_key&apos;:0x6A, &apos;add_key&apos;:0x6B, &apos;separator_key&apos;:0x6C, &apos;subtract_key&apos;:0x6D, &apos;decimal_key&apos;:0x6E, &apos;divide_key&apos;:0x6F, &apos;F1&apos;:0x70, &apos;F2&apos;:0x71, &apos;F3&apos;:0x72, &apos;F4&apos;:0x73, &apos;F5&apos;:0x74, &apos;F6&apos;:0x75, &apos;F7&apos;:0x76, &apos;F8&apos;:0x77, &apos;F9&apos;:0x78, &apos;F10&apos;:0x79, &apos;F11&apos;:0x7A, &apos;F12&apos;:0x7B, &apos;F13&apos;:0x7C, &apos;F14&apos;:0x7D, &apos;F15&apos;:0x7E, &apos;F16&apos;:0x7F, &apos;F17&apos;:0x80, &apos;F18&apos;:0x81, &apos;F19&apos;:0x82, &apos;F20&apos;:0x83, &apos;F21&apos;:0x84, &apos;F22&apos;:0x85, &apos;F23&apos;:0x86, &apos;F24&apos;:0x87, &apos;num_lock&apos;:0x90, &apos;scroll_lock&apos;:0x91, &apos;left_shift&apos;:0xA0, &apos;right_shift &apos;:0xA1, &apos;left_control&apos;:0xA2, &apos;right_control&apos;:0xA3, &apos;left_menu&apos;:0xA4, &apos;right_menu&apos;:0xA5, &apos;browser_back&apos;:0xA6, &apos;browser_forward&apos;:0xA7, &apos;browser_refresh&apos;:0xA8, &apos;browser_stop&apos;:0xA9, &apos;browser_search&apos;:0xAA, &apos;browser_favorites&apos;:0xAB, &apos;browser_start_and_home&apos;:0xAC, &apos;volume_mute&apos;:0xAD, &apos;volume_Down&apos;:0xAE, &apos;volume_up&apos;:0xAF, &apos;next_track&apos;:0xB0, &apos;previous_track&apos;:0xB1, &apos;stop_media&apos;:0xB2, &apos;play/pause_media&apos;:0xB3, &apos;start_mail&apos;:0xB4, &apos;select_media&apos;:0xB5, &apos;start_application_1&apos;:0xB6, &apos;start_application_2&apos;:0xB7, &apos;attn_key&apos;:0xF6, &apos;crsel_key&apos;:0xF7, &apos;exsel_key&apos;:0xF8, &apos;play_key&apos;:0xFA, &apos;zoom_key&apos;:0xFB, &apos;clear_key&apos;:0xFE, &apos;+&apos;:0xBB, &apos;,&apos;:0xBC, &apos;-&apos;:0xBD, &apos;.&apos;:0xBE, &apos;/&apos;:0xBF, &apos;`&apos;:0xC0, &apos;;&apos;:0xBA, &apos;[&apos;:0xDB, &apos;\\&apos;:0xDC, &apos;]&apos;:0xDD, &quot;&apos;&quot;:0xDE, &apos;`&apos;:0xC0&#125;def press(*args): &apos;&apos;&apos; one press, one release. accepts as many arguments as you want. e.g. press(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)def pressAndHold(*args): &apos;&apos;&apos; press and hold. Do NOT release. accepts as many arguments as you want. e.g. pressAndHold(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) def pressHoldRelease(*args): &apos;&apos;&apos; press and hold passed in strings. Once held, release accepts as many arguments as you want. e.g. pressAndHold(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). this is useful for issuing shortcut command or shift commands. e.g. pressHoldRelease(&apos;ctrl&apos;, &apos;alt&apos;, &apos;del&apos;), pressHoldRelease(&apos;shift&apos;,&apos;a&apos;) &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) for i in args: win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0) time.sleep(.1) def release(*args): &apos;&apos;&apos; release depressed keys accepts as many arguments as you want. e.g. release(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)def typer(string=None,*args):## time.sleep(4) for i in string: if i == &apos; &apos;: win32api.keybd_event(VK_CODE[&apos;spacebar&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;spacebar&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;!&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;1&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;1&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;@&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;2&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;2&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&#123;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;[&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;[&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;?&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;/&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;/&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;:&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;;&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;;&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&quot;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;\&apos;&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;\&apos;&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&#125;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;]&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;]&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;#&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;3&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;3&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;$&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;4&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;4&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;%&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;5&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;5&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;^&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;6&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;6&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&amp;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;7&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;7&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;*&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;8&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;8&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;(&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;9&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;9&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;)&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;0&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;0&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;_&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;-&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;-&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;=&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;+&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;+&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;~&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;`&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;`&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&lt;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;,&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;,&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&gt;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;.&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;.&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;A&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;a&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;a&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;B&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;b&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;b&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;C&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;c&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;c&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;D&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;d&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;d&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;E&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;e&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;e&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;F&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;f&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;f&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;G&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;g&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;g&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;H&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;h&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;h&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;I&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;i&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;i&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;J&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;j&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;j&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;K&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;k&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;k&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;L&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;l&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;l&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;M&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;m&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;m&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;N&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;n&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;n&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;O&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;o&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;o&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;P&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;p&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;p&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Q&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;q&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;q&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;R&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;r&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;r&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;S&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;s&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;s&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;T&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;t&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;t&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;U&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;u&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;u&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;V&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;v&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;v&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;W&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;w&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;w&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;X&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;x&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;x&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Y&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;y&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;y&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Z&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;z&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;z&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) else: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0) 参考地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
        <tag>win32api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3.6安装pywin32]]></title>
    <url>%2F2017%2F12%2F28%2Fpython3-6%E5%AE%89%E8%A3%85pywin32%2F</url>
    <content type="text"><![CDATA[python3.6装载win32api模块 使用pip安装win32报错 1Could not find a version that satisfies the requirement win32api (from versions: )No matching distribution found for win32api stack overflow上面有两种回答 pip install pypiwin32 从windowsapi官网下载安装程序，点击安装 首先尝试了第一种方式，没啥用，还是找不到win32api尝试第二种方法，直接报错：1Python version 3.6-32 required, which was not found in the registry. 找半天问题，首先本地python是64位版本，下载的也是64位安装包，报这莫名其妙的注册表错误。后来在注册表里加了个python3.6-32就能安装了，莫名其妙。。1HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\3.6-32 导入了个奇奇怪怪的win32api，貌似用不了12345#!/usr/bin/env python3# -*- coding: utf-8 -*-import win32.win32apiimport win32.win32clipboardimport win32com 根据以往踩坑经验，改注册表好像都没什么好下场，于是乎，把装好的win32全部删除，注册表还原，重新下载更新版本的pywin32：下载链接 重新安装之后，重启pycharm，这次好像是成功了。。123456import win32apiimport win32condef keyDown(keyName): win32api.keybd_event() win32con.KEYEVENTF_KEYUP 反正过程是挺无语的，莫名其妙的就好了。 附上环境信息：123WIN-10 64位python-3.6 64位pywin32-221.win-amd64-py3.6]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pywin32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3_map()函数]]></title>
    <url>%2F2017%2F12%2F27%2Fpython3-map-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[坑爹python3改动之map()函数 做自动化测试，获取并校验下拉列表中所有值，由于实在不想先写个空列表，再来个for循环全部加到列表中，就想到了map()函数，折腾半天，各种报错，墙里墙外翻半天，终于找到跟我一样入坑的人。 map()函数，python3改动 在python2中，以下代码可输出一个列表[1, 2, 3, 4, 5]12a = map(lambda x:x, [1, 2, 3, 4, 5])print(a) 但是python3，这玩意只能输出个map对象：&lt;map object at 0x00000278CB45D4E0&gt; 遇到这玩意也很多次了，直接加list：12a = list(map(lambda x: x, [1, 2, 3, 4, 5]))print(a) 这样，在python3就可以输出[1, 2, 3, 4, 5] 附自动化测试比较下拉列表值是否符合预期示例代码（百度新闻高级设置-显示条数为例）：12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.support.ui import Selectimport unittestimport timeclass News_Baidu(unittest.TestCase): def setUp(self): #打开浏览器 self.brower = webdriver.Chrome() def test_Checklist(self): #打开百度新闻页面 self.brower.get(&quot;http://news.baidu.com/&quot;) #定位“高级设置”，并点击 self.brower.find_element_by_link_text(&quot;高级搜索&quot;).click() #定位“搜索结果显示条数” select_element = Select(self.brower.find_element_by_name(&apos;rn&apos;)) #获取下拉列表所有元素对象 select_options = select_element.options #声明一个期望下拉列表值的列表(百度也是够坑的，值前面还有一个空格) expect_optionlist = [&apos; 每页显示10条&apos;, &apos; 每页显示20条&apos;, &apos; 每页显示50条&apos;] #获取实际的下拉列表值的列表 actual_optionlist = list(map(lambda option:option.text, select_options)) #断言结果是否适合期望 self.assertListEqual(actual_optionlist, expect_optionlist) def tearDown(self): #休眠 time.sleep(5) #退出浏览器 self.brower.quit()if __name__ == &apos;__main__&apos;: unittest.main()]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html报告乱码]]></title>
    <url>%2F2017%2F12%2F26%2Fhtml%E6%8A%A5%E5%91%8A%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用HTMLTestRunner进行测试报告输出时，错误说明，中午乱码，版本：12python3.6HTMLTestRunner 1.1.1 网上搜了一堆，全是用python2.x的，心痛，2.X到2020年不就不支持了嘛，为啥一个个的都在2.X上面，没办法，自己去捣鼓源码。 报告输出的html文件，使用类似于notepad的编辑器打开，编码格式改为UTF-8，重新在浏览器中打开，错误描述的中文显示就是正常文字。所以，只要在输出时，设置编码为“utf-8”应该就可以。 找到本地的HTMLTestRunner安装路径，一般都是在G:\skills\python36\Lib\site-packages\HtmlTestRunner类似这样的路径下，毕竟扩展包。下面有三个文件，和一个文件夹，文件夹里是报告的模板，不考虑，三个文件，一个是HtmlTestRunner的介绍，一个是runner.py，一个是result.py，输出报告，应该就在result.py文件中。 编辑器打开result.py，找到第350行1with open(path_file, &apos;w&apos;) as report_file: 只要修改成1with open(path_file, &apos;w&apos;,encoding=&apos;utf-8&apos;) as report_file: 即可。 附上百度搜索自动化测试代码 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3# -*- coding: utf-8 -*-import unittestimport timefrom selenium import webdriverfrom HtmlTestRunner import HTMLTestRunnerclass GloryRoad(unittest.TestCase): def setUp(self): #启动chrome浏览器 self.brower = webdriver.Chrome() def test_baidu(self): #访问百度首页 self.brower.get(&quot;https://www.baidu.com&quot;) #清空输入框内容 self.brower.find_element_by_id(&apos;kw&apos;).clear() #搜索框输入“selenium3” self.brower.find_element_by_id(&apos;kw&apos;).send_keys(&apos;selenium3&apos;) #点击“百度一下”按键 self.brower.find_element_by_id(&apos;su&apos;).click() #休眠3s time.sleep(3) assert &quot;google&quot; in self.brower.page_source, &quot;页面中不存在要寻找的关键字！&quot; def tearDown(self): #退出浏览器 self.brower.quit()if __name__ == &apos;__main__&apos;: suite = unittest.TestLoader().loadTestsFromTestCase(GloryRoad) runner = HTMLTestRunner(output=&apos;G:/workstation/report&apos;, report_title=&apos;Test Result&apos;) runner.run(suite)]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm单元测试]]></title>
    <url>%2F2017%2F12%2F25%2Fpycharm%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用pycharm编写/执行单元测试用例 python单元测试用例，调用方式使用1unittest.main() 该方式，在python shell中可执行成功，在pycharm中会一直报错，参考网上的写法，最后校验调用改为：12if _name_ == &apos;_main_&apos;: unittest.main() 结果一直报错，NameError: name &#39;_name_&#39; is not defined 简直了，找了半天，还是在墙外找到跟我有一样经历的哥们的求救，报错原因是_name_和_main都是双下划线，正确写法是： 12if __name__ == &apos;__main__&apos;: unittest.main() 真是日常坑自己…]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>unittest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium3+python3.6搭建测试]]></title>
    <url>%2F2017%2F12%2F25%2Fselenium3-python3-6%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[python3.6selenium3chrome64firefox57 selenium3开始，需要浏览器驱动，加载驱动方式：121，驱动放在任意位置，代码中，引驱动，打开浏览器（webdriver.Chrome(executable_path=&quot;驱动路径&quot;）2，将驱动放到浏览器安装目录下，和浏览器启动程序同级，将浏览器安装路径加到环境变量Path中，重启pycharm 自动化测试示例： 12345678910111213141516171819202122232425262728#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverimport time#加载驱动程序#firefox(驱动放到浏览器安装目录，目录加到Path)#driver = webdriver.Firefox()#chrome(驱动放到浏览器安装目录，目录加到Path)driver = webdriver.Chrome()#chrome默认安装路径，驱动指定路径#driver = webdriver.Chrome(executable_path=&quot;G:/Selenium/drivers/chromedriver.exe&quot;)#打开百度首页driver.get(&quot;https://www.baidu.com&quot;)#清空搜索输入框默认内容driver.find_element_by_id(&quot;kw&quot;).clear()#输入框中输入“自动化测试”driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;自动化测试&quot;)#单击搜索按钮driver.find_element_by_id(&quot;su&quot;).click()#等待3秒time.sleep(3)#退出浏览器driver.quit()]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world_map]]></title>
    <url>%2F2017%2F12%2F21%2Fworld-map%2F</url>
    <content type="text"><![CDATA[pygal-2.4pygal-maps-world-1.0.2 世界地图模块位置变更 pygal内置世界地图模块，包括国别码模块COUNTRIES以及世界地图模块World。 当前版本下，绘制世界地图，需要从pygal_maps_world.i18n中引国别码，需要从pygal_maps_world.maps中引世界地图。 参考代码如下： countries.py12345678910#!/usr/bin/env python3# -*- coding: utf-8 -*-from pygal_maps_world.i18n import COUNTRIESdef get_country_code(country_name): &quot;&quot;&quot;根据指定国家，返回国别码&quot;&quot;&quot; for code, name in COUNTRIES.items(): if name == country_name or name == country_name.title(): return code return None population_data.py123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3# -*- coding: utf-8 -*-from settings import Settingsfrom countries import get_country_codefrom pygal.style import RotateStyle as RS,LightColorizedStyle as LCSimport pygal_maps_world.mapsimport jsondata_setting = Settings()filename = data_setting.json_populationwith open(filename) as f_obj: pop_data = json.load(f_obj)#打印每个国家2010年的人口cc_population = &#123;&#125;for pop_dict in pop_data: if pop_dict[&apos;Year&apos;] == &apos;2010&apos;: country_name = pop_dict[&apos;Country Name&apos;] population = int(float(pop_dict[&apos;Value&apos;])) code = get_country_code(country_name) if code: cc_population[code] = population#按人口给国家分组cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;for cc, pop in cc_population.items(): if pop &lt; 10000000: cc_pops_1[cc] = pop elif pop &lt; 1000000000: cc_pops_2[cc] = pop else: cc_pops_3[cc] = popwm_style = RS(&apos;#336699&apos;,base_style=LCS)wm = pygal_maps_world.maps.World(style=wm_style)wm.title = &quot;World Population in 2010.by Country&quot;wm.add(&apos;0-10m&apos;, cc_pops_1)wm.add(&apos;10m-1bn&apos;, cc_pops_2)wm.add(&apos;&gt;1bn&apos;, cc_pops_3)wm.render_to_file(&apos;world_population.svg&apos;)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制随机漫步图]]></title>
    <url>%2F2017%2F12%2F20%2F%E7%BB%98%E5%88%B6%E9%9A%8F%E6%9C%BA%E6%BC%AB%E6%AD%A5%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[matplotlib可绘制随机漫步图，取随机X个数，在画布上绘制，并加入渐变颜色，效果还是挺好看的 代码如下： random_walk.py1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python3# -*- coding: utf-8 -*-from random import choiceclass RandomWalk(): &quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot; def __init__(self,num_point=5000): &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot; self.num_point = num_point #所有随机漫步的点都始于（0,0） self.x_values = [0] self.y_values = [0] def get_step(self): &quot;&quot;&quot;设置前进方向及距离&quot;&quot;&quot; direction = choice([1, -1]) distance = choice([0, 1, 2, 3, 4]) step = distance * direction return step def fill_walk(self): &quot;&quot;&quot;计算随机漫步的所有点&quot;&quot;&quot; while len(self.x_values) &lt; self.num_point: x_step = self.get_step() y_step = self.get_step() #排除原地踏步情况 if x_step == 0 and y_step == 0: continue #计算下一个点的位置 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step self.x_values.append(next_x) self.y_values.append(next_y) rw_visual.py123456789101112131415161718192021222324252627#!/usr/bin/env python3# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: #创建一个随机漫步实例，并将所有包含的点绘制出 rw = RandomWalk(30000) rw.fill_walk() point_num = list(range(rw.num_point)) plt.scatter(rw.x_values, rw.y_values, c=point_num, cmap=plt.cm.Blues, s=5) #突出起点和终点 plt.scatter(0, 0, c=&apos;green&apos;, s=100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, s=100) #隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) #plt.subplot().set_xticks([]) #plt.subplot().set_yticks([]) plt.show() keep_drawing = input(&quot;Make another walk?y/n&quot;) if keep_drawing == &apos;n&apos;: break 可成功绘制随机漫步图，然而有个警告报错：1MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.warnings.warn(message, mplDeprecation, stacklevel=1) 原因是matplotlib版本问题，出在隐藏坐标轴plt.axes().get_yaxis()处，尝试修改为：12plt.subplot().set_xticks([])plt.subplot().set_yticks([]) 然而没啥用，还是在警告，暂时没解决。。好在不影响功能，不是强迫症也就无视这红字了。。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib绘制渐变图]]></title>
    <url>%2F2017%2F12%2F20%2Fmatplotlib%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[使用matplotlib绘制1-1000所有整数立方值图形报错 绘制1~1000所有整数的立方图，颜色采用渐变蓝色，点越接近坐标原点，颜色越浅。代码：123456789101112131415161718import matplotlib.pyplot as pltx_values = list(range(1,1001))y_values = [x**3 for x in x_values]plt.scatter(x_values, y_values, c=y_values,cmap=plt.cm.Blues,s=40)#设置图表坐标并设置坐标标签plt.title(&quot;Square Numbers&quot;,fontsize=24)plt.xlabel(&quot;Values&quot;,fontsize=14)plt.ylabel(&quot;Square of Value&quot;,fontsize=14)#设置坐标轴刻度plt.tick_params(axis=&apos;both&apos;, labelsize=14)#设置坐标轴取值plt.axes([0,1100,0,1100000])plt.show() 可以成功绘制图形，但是有警告报错：1UserWarning: Unable to find pixel distance along axis for interval padding of ticks; assuming no interval padding needed.warnings.warn(&quot;Unable to find pixel distance along axis &quot; 原因：设置坐标轴取值时，使用的是plt.axes，该函数创建的是一个轴对象，并将输入解释为指定位置的矩形，绘制的坐标轴中取值0在绘制的图形之外，超出了限制范围，所以警告报错。 解决方案：使用plt.axis()代替plt.axes()123#设置坐标轴取值plt.axis([0,1100,0,1100000])plt.show()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.0更新内容记录]]></title>
    <url>%2F2017%2F12%2F19%2FDjango2-0%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Django 2.0 变更内容(不按版本敲着实是有点坑o(╥﹏╥)o) 外键Django 1.9在创建models.ForeignKey外键时，可写成1topic = models.ForeignKey(Topic） Django 2.0需要多传一个字段on_delete，且可给定默认值models.CASCADE所以上述可写为：1topic = models.ForeignKey(Topic,on_delete=models.CASCADE) 指定app_nameDjango 1.9在映射URL时，工程的urls.py可写成：1234567from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;&apos;,include(&apos;learning_logs.urls&apos;, namespace=&apos;learning_logs&apos;))] 应用的urls.py可写成：12345678&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsurlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 该写法在Django 2.0中会出现报错：12&apos;Specifying a namespace in include() without providing an app_name &apos;django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead. 意思是缺少了app_name，所以需要指定app_name，我的做法是在应用的urls.py文件中指定app_name，也就是工程的urls.py保持不变，应用的urls.py增加app_name指定：123456789&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsapp_name = &apos;learning_logs&apos;urlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 映射URL对于django.urls.path()函数，允许有简单的表示方法： 1url(r’^articles/(?P[0-9]&#123;4&#125;)/$’, views.year_archive), 可以写成： 1path(‘articles//‘, views.year_archive), 用法参见前博客记录]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试-理发师模型]]></title>
    <url>%2F2017%2F12%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E7%90%86%E5%8F%91%E5%B8%88%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[性能测试有个有名的模型，理发店模型，理发店标配：一间或大或小的店面，一个或几个理发师，几张理发的椅子和顾客休息的椅子。本文介绍一下理发店模型（相关资料网上一堆，只是为了自己记录） 场景假设 1234该理发店：1. 理发店共有3名理发师；2. 每位理发师剪一个发的时间都是1小时；3. 我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，我们的顾客会立马生气的走人。 场景模拟1231. 当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；2. 当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；3. 很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时； 从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从1位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。 当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。 不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。 通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。 在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。 抽象 这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示资源的利用情况（Utilization，包括硬件资源和软件资源）、吞吐量（Throughput，这里是指每秒事务数）以及响应时间（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。 在这张图中我们可以看到，最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。 根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。 当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。 对应到我们上面理发店的例子，每小时3个顾客就是这个理发店的最佳并发用户数，而每小时9个顾客则是它的最大并发用户数。当每小时都有3个顾客到来时，理发店的整体工作效率最高；而当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。当然，如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。 大神原网址]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系统监控配置]]></title>
    <url>%2F2017%2F12%2F15%2FJmeter%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Jmeter是测试人员经常会使用的一款压力测试工具，经常会使用来测试接口的性能；Jmeter同时具备监控服务器资源使用情况的功能。 主要介绍一下怎么使用Jmeter来监控服务器的CPU,内存,IO等信息。 下载使用Jmeter监控系统性能，实际上是插件的使用，可以认为是在Jmeter中装载了一个小型监控系统的客户端，同时在需要监控的系统内装载服务端，在允许Jmeter时，同时打开监控服务端，进行系统资源的监控。 12客户端：JMeterPlugins-Standard服务端：ServerAgent 下载地址： 官网下载 百度云链接： JMeterPlugins-Standard-1.4.0ServerAgent-2.2.1 配置说明将 JMeterPlugins-Standard-1.4.0.zip 中 lib\ext 目录下的 JmeterPlugins-Standard.jar 文件都放到apache-jmeter-2.13\lib\ext目录中。将 ServerAgent-2.2.1.zip 解压后放到要监控的服务器中待使用。 监控设置 启动Jmeter后，右击线程组，选择添加- 监听器- jp@gc-PerfMon Metrics Collector 打开jp@gc - PerfMon Metrics Collector，点击Add Row选择相应监控对象（服务器IP和监控内容），端口默认4444即可。 开启监控 设置永远循环，否则监控会运行一次就断开，设置方式：线程组-循环次数（选择永远） 服务端运行ServerAgent，Linux系统运行shell脚本，windows系统执行bat脚本（系统需事先完成jdk配置） 成功完成系统资源监控]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客中加入图片]]></title>
    <url>%2F2017%2F12%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[好不容易搭好了hexo，插个图片各种错 本地引用绝对路径markdown语法实现 12source/images/image.jpg ![](/images/image.jpg) 这样，图片既可以在首页内容访问，也可以在文章正文中使用 相对路径首先在/blog/_config.yml 中设置 post_asset_folder: true ，这样在 hexo new “文章” 时会生成与文章标题一样的目录，将文章中需要使用的图片存在该目录下（source//_posts/文章） 12_posts/post_name/image.jpg ![](image.jpg) CDN引用现在大多数做法是使用图床，自己也看过七牛云之类的做为图床，但是，七牛云个流氓，还要手持身份证认证，所以暂时放弃。（该方法就是在图床中生成链接，直接引链接即可） Markdown 语法介绍]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码]]></title>
    <url>%2F2017%2F12%2F13%2Fpython%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列（二） 日常编写python脚本，鉴于java各种坑编码经历，首先就会把pycharm编码设置成utf-8，但是不知道什么鬼，设置完成之后，编译还是会报编码gbk的错误 问题如下： “UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 34: illegal multibyte sequence” 解决方案： 1，设置所有文件编码默认为utf-8（文件最前面指定） 2，处理数据时进行转码： with open(“population.json”,encoding=’UTF-8’) as data: –完 (#^.^#)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django获取不到特定链接]]></title>
    <url>%2F2017%2F12%2F13%2FDjango%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列 按照教程方式打开本地特定链接报错源码如下： 12345678910111213from django.conf.urls import urlfrom . import viewsurlpatterns = [ # Home page. url(r'^$', views.index, name='index'), # Show all topics. url(r'^topics/$', views.topics, name='topics'), # Detail page for a single topic. url(r'^topics/(?P&lt;topic_id&gt;\d+)/$', views.topic, name='topic'),] 打开http://127.0.0.1:8000/topics/1/报错： 123456 Using the URLconf defined in learning_log.urls, Django tried these URL patterns, in this order: 1. admin/ 2. [name='index'] 3. topics [name='topics'] 4. topics/?P&lt;topic_id&gt;\d+/ [name='topic']The current path, topics/1/, didn't match any of these. 原因：Django2.0有更新对于django.urls.path()函数，允许有简单的表示方法： url(r’^articles/(?P[0-9]{4})/$’, views.year_archive), 可以写成： path(‘articles//‘, views.year_archive), 所以代码可更改为：12345678910111213from django.urls import pathfrom . import viewsapp_name = 'lerning_logs'urlpatterns = [ #主页 path('', views.index, name='index'), #显示所有主题 path('topics', views.topics, name='topics'), #特定主题的详细页面 #path('topics/?P&lt;topic_id&gt;\d+/', views.topic, name='topic'), path('topics/&lt;topic_id&gt;/', views.topic, name='topic'),]]]></content>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
