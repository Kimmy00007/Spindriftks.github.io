<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[world_map]]></title>
    <url>%2F2017%2F12%2F21%2Fworld-map%2F</url>
    <content type="text"><![CDATA[pygal-2.4pygal-maps-world-1.0.2 世界地图模块位置变更 pygal内置世界地图模块，包括国别码模块COUNTRIES以及世界地图模块World。 当前版本下，绘制世界地图，需要从pygal_maps_world.i18n中引国别码，需要从pygal_maps_world.maps中引世界地图。 参考代码如下： countries.py12345678910#!/usr/bin/env python3# -*- coding: utf-8 -*-from pygal_maps_world.i18n import COUNTRIESdef get_country_code(country_name): &quot;&quot;&quot;根据指定国家，返回国别码&quot;&quot;&quot; for code, name in COUNTRIES.items(): if name == country_name or name == country_name.title(): return code return None population_data.py123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3# -*- coding: utf-8 -*-from settings import Settingsfrom countries import get_country_codefrom pygal.style import RotateStyle as RS,LightColorizedStyle as LCSimport pygal_maps_world.mapsimport jsondata_setting = Settings()filename = data_setting.json_populationwith open(filename) as f_obj: pop_data = json.load(f_obj)#打印每个国家2010年的人口cc_population = &#123;&#125;for pop_dict in pop_data: if pop_dict[&apos;Year&apos;] == &apos;2010&apos;: country_name = pop_dict[&apos;Country Name&apos;] population = int(float(pop_dict[&apos;Value&apos;])) code = get_country_code(country_name) if code: cc_population[code] = population#按人口给国家分组cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;for cc, pop in cc_population.items(): if pop &lt; 10000000: cc_pops_1[cc] = pop elif pop &lt; 1000000000: cc_pops_2[cc] = pop else: cc_pops_3[cc] = popwm_style = RS(&apos;#336699&apos;,base_style=LCS)wm = pygal_maps_world.maps.World(style=wm_style)wm.title = &quot;World Population in 2010.by Country&quot;wm.add(&apos;0-10m&apos;, cc_pops_1)wm.add(&apos;10m-1bn&apos;, cc_pops_2)wm.add(&apos;&gt;1bn&apos;, cc_pops_3)wm.render_to_file(&apos;world_population.svg&apos;)]]></content>
      <categories>
        <category>coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制随机漫步图]]></title>
    <url>%2F2017%2F12%2F20%2F%E7%BB%98%E5%88%B6%E9%9A%8F%E6%9C%BA%E6%BC%AB%E6%AD%A5%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[matplotlib可绘制随机漫步图，取随机X个数，在画布上绘制，并加入渐变颜色，效果还是挺好看的 代码如下： random_walk.py1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python3# -*- coding: utf-8 -*-from random import choiceclass RandomWalk(): &quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot; def __init__(self,num_point=5000): &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot; self.num_point = num_point #所有随机漫步的点都始于（0,0） self.x_values = [0] self.y_values = [0] def get_step(self): &quot;&quot;&quot;设置前进方向及距离&quot;&quot;&quot; direction = choice([1, -1]) distance = choice([0, 1, 2, 3, 4]) step = distance * direction return step def fill_walk(self): &quot;&quot;&quot;计算随机漫步的所有点&quot;&quot;&quot; while len(self.x_values) &lt; self.num_point: x_step = self.get_step() y_step = self.get_step() #排除原地踏步情况 if x_step == 0 and y_step == 0: continue #计算下一个点的位置 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step self.x_values.append(next_x) self.y_values.append(next_y) rw_visual.py123456789101112131415161718192021222324252627#!/usr/bin/env python3# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: #创建一个随机漫步实例，并将所有包含的点绘制出 rw = RandomWalk(30000) rw.fill_walk() point_num = list(range(rw.num_point)) plt.scatter(rw.x_values, rw.y_values, c=point_num, cmap=plt.cm.Blues, s=5) #突出起点和终点 plt.scatter(0, 0, c=&apos;green&apos;, s=100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, s=100) #隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) #plt.subplot().set_xticks([]) #plt.subplot().set_yticks([]) plt.show() keep_drawing = input(&quot;Make another walk?y/n&quot;) if keep_drawing == &apos;n&apos;: break 可成功绘制随机漫步图，然而有个警告报错：1MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.warnings.warn(message, mplDeprecation, stacklevel=1) 原因是matplotlib版本问题，出在隐藏坐标轴plt.axes().get_yaxis()处，尝试修改为：12plt.subplot().set_xticks([])plt.subplot().set_yticks([]) 然而没啥用，还是在警告，暂时没解决。。好在不影响功能，不是强迫症也就无视这红字了。。]]></content>
      <categories>
        <category>coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib绘制渐变图]]></title>
    <url>%2F2017%2F12%2F20%2Fmatplotlib%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[使用matplotlib绘制1-1000所有整数立方值图形报错 绘制1~1000所有整数的立方图，颜色采用渐变蓝色，点越接近坐标原点，颜色越浅。代码：123456789101112131415161718import matplotlib.pyplot as pltx_values = list(range(1,1001))y_values = [x**3 for x in x_values]plt.scatter(x_values, y_values, c=y_values,cmap=plt.cm.Blues,s=40)#设置图表坐标并设置坐标标签plt.title(&quot;Square Numbers&quot;,fontsize=24)plt.xlabel(&quot;Values&quot;,fontsize=14)plt.ylabel(&quot;Square of Value&quot;,fontsize=14)#设置坐标轴刻度plt.tick_params(axis=&apos;both&apos;, labelsize=14)#设置坐标轴取值plt.axes([0,1100,0,1100000])plt.show() 可以成功绘制图形，但是有警告报错：1UserWarning: Unable to find pixel distance along axis for interval padding of ticks; assuming no interval padding needed.warnings.warn(&quot;Unable to find pixel distance along axis &quot; 原因：设置坐标轴取值时，使用的是plt.axes，该函数创建的是一个轴对象，并将输入解释为指定位置的矩形，绘制的坐标轴中取值0在绘制的图形之外，超出了限制范围，所以警告报错。 解决方案：使用plt.axis()代替plt.axes()123#设置坐标轴取值plt.axis([0,1100,0,1100000])plt.show()]]></content>
      <categories>
        <category>coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.0更新内容记录]]></title>
    <url>%2F2017%2F12%2F19%2FDjango2-0%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Django 2.0 变更内容(不按版本敲着实是有点坑o(╥﹏╥)o) 外键Django 1.9在创建models.ForeignKey外键时，可写成1topic = models.ForeignKey(Topic） Django 2.0需要多传一个字段on_delete，且可给定默认值models.CASCADE所以上述可写为：1topic = models.ForeignKey(Topic,on_delete=models.CASCADE) 指定app_nameDjango 1.9在映射URL时，工程的urls.py可写成：1234567from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;&apos;,include(&apos;learning_logs.urls&apos;, namespace=&apos;learning_logs&apos;))] 应用的urls.py可写成：12345678&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsurlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 该写法在Django 2.0中会出现报错：12&apos;Specifying a namespace in include() without providing an app_name &apos;django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead. 意思是缺少了app_name，所以需要指定app_name，我的做法是在应用的urls.py文件中指定app_name，也就是工程的urls.py保持不变，应用的urls.py增加app_name指定：123456789&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsapp_name = &apos;learning_logs&apos;urlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 映射URL对于django.urls.path()函数，允许有简单的表示方法： 1url(r’^articles/(?P[0-9]&#123;4&#125;)/$’, views.year_archive), 可以写成： 1path(‘articles//‘, views.year_archive), 用法参见前博客记录]]></content>
      <categories>
        <category>coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试-理发师模型]]></title>
    <url>%2F2017%2F12%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E7%90%86%E5%8F%91%E5%B8%88%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[性能测试有个有名的模型，理发店模型，理发店标配：一间或大或小的店面，一个或几个理发师，几张理发的椅子和顾客休息的椅子。本文介绍一下理发店模型（相关资料网上一堆，只是为了自己记录） 场景假设 1234该理发店：1. 理发店共有3名理发师；2. 每位理发师剪一个发的时间都是1小时；3. 我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，我们的顾客会立马生气的走人。 场景模拟1231. 当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；2. 当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；3. 很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时； 从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从1位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。 当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。 不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。 通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。 在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。 抽象 这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示资源的利用情况（Utilization，包括硬件资源和软件资源）、吞吐量（Throughput，这里是指每秒事务数）以及响应时间（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。 在这张图中我们可以看到，最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。 根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。 当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。 对应到我们上面理发店的例子，每小时3个顾客就是这个理发店的最佳并发用户数，而每小时9个顾客则是它的最大并发用户数。当每小时都有3个顾客到来时，理发店的整体工作效率最高；而当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。当然，如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。 大神原网址]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系统监控配置]]></title>
    <url>%2F2017%2F12%2F15%2FJmeter%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Jmeter是测试人员经常会使用的一款压力测试工具，经常会使用来测试接口的性能；Jmeter同时具备监控服务器资源使用情况的功能。 主要介绍一下怎么使用Jmeter来监控服务器的CPU,内存,IO等信息。 下载使用Jmeter监控系统性能，实际上是插件的使用，可以认为是在Jmeter中装载了一个小型监控系统的客户端，同时在需要监控的系统内装载服务端，在允许Jmeter时，同时打开监控服务端，进行系统资源的监控。 12客户端：JMeterPlugins-Standard服务端：ServerAgent 下载地址： 官网下载 百度云链接： JMeterPlugins-Standard-1.4.0ServerAgent-2.2.1 配置说明将 JMeterPlugins-Standard-1.4.0.zip 中 lib\ext 目录下的 JmeterPlugins-Standard.jar 文件都放到apache-jmeter-2.13\lib\ext目录中。将 ServerAgent-2.2.1.zip 解压后放到要监控的服务器中待使用。 监控设置 启动Jmeter后，右击线程组，选择添加- 监听器- jp@gc-PerfMon Metrics Collector 打开jp@gc - PerfMon Metrics Collector，点击Add Row选择相应监控对象（服务器IP和监控内容），端口默认4444即可。 开启监控 设置永远循环，否则监控会运行一次就断开，设置方式：线程组-循环次数（选择永远） 服务端运行ServerAgent，Linux系统运行shell脚本，windows系统执行bat脚本（系统需事先完成jdk配置） 成功完成系统资源监控]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客中加入图片]]></title>
    <url>%2F2017%2F12%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[好不容易搭好了hexo，插个图片各种错 本地引用绝对路径markdown语法实现 12source/images/image.jpg ![](/images/image.jpg) 这样，图片既可以在首页内容访问，也可以在文章正文中使用 相对路径首先在/blog/_config.yml 中设置 post_asset_folder: true ，这样在 hexo new “文章” 时会生成与文章标题一样的目录，将文章中需要使用的图片存在该目录下（source//_posts/文章） 12_posts/post_name/image.jpg ![](image.jpg) CDN引用现在大多数做法是使用图床，自己也看过七牛云之类的做为图床，但是，七牛云个流氓，还要手持身份证认证，所以暂时放弃。（该方法就是在图床中生成链接，直接引链接即可） Markdown 语法介绍]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码]]></title>
    <url>%2F2017%2F12%2F13%2Fpython%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列（二） 日常编写python脚本，鉴于java各种坑编码经历，首先就会把pycharm编码设置成utf-8，但是不知道什么鬼，设置完成之后，编译还是会报编码gbk的错误 问题如下： “UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 34: illegal multibyte sequence” 解决方案： 1，设置所有文件编码默认为utf-8（文件最前面指定） 2，处理数据时进行转码： with open(“population.json”,encoding=’UTF-8’) as data: –完 (#^.^#)]]></content>
      <categories>
        <category>coding</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django获取不到特定链接]]></title>
    <url>%2F2017%2F12%2F13%2FDjango%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列 按照教程方式打开本地特定链接报错源码如下： 12345678910111213from django.conf.urls import urlfrom . import viewsurlpatterns = [ # Home page. url(r'^$', views.index, name='index'), # Show all topics. url(r'^topics/$', views.topics, name='topics'), # Detail page for a single topic. url(r'^topics/(?P&lt;topic_id&gt;\d+)/$', views.topic, name='topic'),] 打开http://127.0.0.1:8000/topics/1/报错： 123456 Using the URLconf defined in learning_log.urls, Django tried these URL patterns, in this order: 1. admin/ 2. [name='index'] 3. topics [name='topics'] 4. topics/?P&lt;topic_id&gt;\d+/ [name='topic']The current path, topics/1/, didn't match any of these. 原因：Django2.0有更新对于django.urls.path()函数，允许有简单的表示方法： url(r’^articles/(?P[0-9]{4})/$’, views.year_archive), 可以写成： path(‘articles//‘, views.year_archive), 所以代码可更改为：12345678910111213from django.urls import pathfrom . import viewsapp_name = 'lerning_logs'urlpatterns = [ #主页 path('', views.index, name='index'), #显示所有主题 path('topics', views.topics, name='topics'), #特定主题的详细页面 #path('topics/?P&lt;topic_id&gt;\d+/', views.topic, name='topic'), path('topics/&lt;topic_id&gt;/', views.topic, name='topic'),]]]></content>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
