<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单元测试异常捕获]]></title>
    <url>%2F2018%2F02%2F08%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[关于自动化测试执行期间断言的异常的选择迷茫 大概是这段时间有点压抑，昨天下午就不知道怎么钻在了单元测试断言失败需不需要捕获异常这个问题上。大家都知道，进行单元测试时，加入断言验证单元测试结果，断言失败会报错，通过会打印ok标识。 nose进行单元测试使用nose进行单元测试示例：123456789#!/usr/bin/env python3# -*- coding: utf-8 -*-from nose.tools import assert_equaldef test_sum(): a = 1 b = 2 res = 5 assert_equal(res, a+b) 控制台执行1nosetests -v -s Testexec.py 打印信息12345678910111213141516Testexec.test_sum ... FAIL======================================================================FAIL: Testexec.test_sum----------------------------------------------------------------------Traceback (most recent call last): File &quot;g:\skills\python36\lib\site-packages\nose\case.py&quot;, line 198, in runTest self.test(*self.arg) File &quot;G:\workstation\py_workstation\DataDriverTest\Testexec.py&quot;, line 17, in test_sum assert_equal(res, a+b)AssertionError: 5 != 3----------------------------------------------------------------------Ran 1 test in 0.007sFAILED (failures=1) 可以看出，断言失败了，控制台也打印出了断言失败的信息。但是在进行自动化测试过程中，如果你想加入日志模块，在执行过程中就在控制台或者文件中打印日志，例如：Testexec.test_sum ... 断言失败，3不等于5这样的信息，很明显，直接用上述写法是不会走到打印失败信息这一步，所以就需要将断言失败的异常捕获，类似这样：123456789101112#!/usr/bin/env python3# -*- coding: utf-8 -*-from nose.tools import assert_equaldef test_sum(): try: a = 1 b = 2 res = 5 assert_equal(res, a+b) except AssertionError as e: print(&quot;断言失败，&#123;0&#125;不等于&#123;1&#125;&quot;.format(a+b, res)) 这种写法执行单元测试，结果：12345678&#123;lamb&#125; nosetests -v -s Testexec.pyTestexec.test_sum ... 断言失败，3不等于5ok----------------------------------------------------------------------Ran 1 test in 0.002sOK 可以看见在断言失败的情况下，打印出了自定义的断言失败信息，这样也就满足进行自动化测试时，实时有日志生成，方便查看，但是这样有个问题，你一旦把断言失败的异常捕获了，那该条测试执行结果就是OK状态，到最后统计时候就不容易看出是哪条执行失败了，只能查看日志；而且日志中也没有展示具体在哪一行有报错，所以这样的方式需要改进。 打印堆栈信息在断言失败时，把异常捕获，此时不会展示具体断言错误的信息，所以就需要添加堆栈信息打印：123456789def test_sum(): try: a = 1 b = 2 res = 5 assert_equal(res, a+b) except AssertionError as e: logging.error(&quot;断言失败，&#123;0&#125;不等于&#123;1&#125;&quot;.format(a+b, res) + str(traceback.print_exc()) 这样就可以获取堆栈信息，可以查看具体哪一行有报错，但是，这样堆栈的日志也只会打印在控制台上，不利于查看，好traceback.print_exc()可以指定日志输出路径，所以只需要修改为：123456789def test_sum(): try: a = 1 b = 2 res = 5 assert_equal(res, a+b) except AssertionError as e: logging.error(&quot;断言失败，&#123;0&#125;不等于&#123;1&#125;&quot;.format(a+b, res) + str(traceback.print_exc(file=open(&apos;test.log&apos;, &apos;a&apos;)))) 这样就可以完成，错误日志打印到文件中，其中a表示append。 邮件附件在进行自动化测试时，我们经常不仅需要日志文件，更多用到的是测试报告，在自动化用例执行完成之后以邮件形式发送到指定邮箱，只需要查看邮件的附件，就可以知晓用例执行情况；但是使用unittest或者nose时，一旦把断言异常捕获，那该条用例结果就是ok状态，实际上我们知道这条用例其实是执行失败了，这样，使用HTMLTestRunner或者是nosetests --with-html --html-file生成的html文件中，用例执行状态就都是success状态，很显然是不正确的。 所以我考虑的是，自己写自定义的测试报告样式，定义一个状态标志status，初始状态为success，在用例执行过程中，一旦捕获了断言异常，就将状态更新为fail，在测试报告中，执行结果栏展示的是该状态，这样就可以实现结果查看了。 自定义测试报告样式。。现在还是只有这个想法，未完待续，待实现了再来更新！（前端知识匮乏啊，越来越觉得自己弱。。。） 断言捕获，可以生成日志，在屏幕和日志文件中打印显示，但是，这样，所有的单元测试都是通过状态，没有一条fail； 断言不捕获，直接邮件发送结果，可以在邮件中看出具体哪条用例执行失败，可以点开失败，查看具体失败信息]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nose执行顺序]]></title>
    <url>%2F2018%2F02%2F07%2Fnose%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[nose单元测试执行顺序 nose和unittest一样，都可以在用例中指定setUp()和tearDown()（用户测试初始化以及测试结束后的操作），在nose中，package、module、class都可以设置setup()和teardown()； package中设置在package中设置，整个测试的运行期间只会执行一次（新建python package时，会生成一个init.py文件，在其中设置setUp()以及tearDown()即可） 用例中每次都执行setup及teardown在模块、类中执行顺序示例：新建Testexec.py文件，内容：1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/7 10:39&quot;&quot;&quot;from nose.plugins.skip import SkipTestclass TestClass(): def setUp(self): print(&quot;=============-My Testcase is setup-===========&quot;) def tearDown(self): print(&quot;============My Testcase is teardown===========&quot;) def test_fun1(self): print(&quot;This is test_fun1*******&quot;) pass def test_fun2(self): print(&quot;This is test_fun2=====&quot;) pass def test_fun3(self): print(&quot;This is test_fun3~~~~~~~~~&quot;) raise SkipTest def test_Fun1(self): print(&quot;This is test_Fun1***====***&quot;) pass 命令行执行nosetests：1nosetests -v -s Testexec.py 执行结果：12345678910111213141516171819202122&#123;lamb&#125; nosetests -v -s Testexec.py Testexec.TestClass.test_Fun1 ... =============-My Testcase is setup-=========== This is test_Fun1***====*** ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun1 ... =============-My Testcase is setup-=========== This is test_fun1******* ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun2 ... =============-My Testcase is setup-=========== This is test_fun2===== ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun3 ... =============-My Testcase is setup-=========== This is test_fun3~~~~~~~~~ ============My Testcase is teardown=========== SKIP ---------------------------------------------------------------------- Ran 4 tests in 0.005s OK (SKIP=1) 可以看见在对每一个函数进行测试时，都执行了一次setUp()以及tearDown()；且用例执行顺序是：1test_Fun1 -&gt; test_fun1 -&gt; test_fun2 -&gt; test_fun3 其中test_fun3跳过了测试，执行顺序是按照先大写字母，再小写字母，然后再按阿拉伯数字排列的。 用例中只执行一次setup及teardown只需要在setUpClass()及tearDownClass()前加修饰器@classmethod即可：12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/7 10:39&quot;&quot;&quot;from nose.plugins.skip import SkipTestclass TestClass(): @classmethod def setUpClass(cls): print(&quot;只初始化一次setup=======&quot;) @classmethod def tearDownClass(cls): print(&quot;只teardown一次***********&quot;) def setUp(self): print(&quot;=============-My Testcase is setup-===========&quot;) def tearDown(self): print(&quot;============My Testcase is teardown===========&quot;) def test_fun1(self): print(&quot;This is test_fun1*******&quot;) pass def test_fun2(self): print(&quot;This is test_fun2=====&quot;) pass def test_fun3(self): print(&quot;This is test_fun3~~~~~~~~~&quot;) raise SkipTest def test_Fun1(self): print(&quot;This is test_Fun1***====***&quot;) pass 执行测试：1nosetests -v -s Testexec.py 执行结果：123456789101112131415161718192021222324&#123;lamb&#125; nosetests -v -s Testexec.py 只初始化一次setup======= Testexec.TestClass.test_Fun1 ... =============-My Testcase is setup-=========== This is test_Fun1***====*** ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun1 ... =============-My Testcase is setup-=========== This is test_fun1******* ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun2 ... =============-My Testcase is setup-=========== This is test_fun2===== ============My Testcase is teardown=========== ok Testexec.TestClass.test_fun3 ... =============-My Testcase is setup-=========== This is test_fun3~~~~~~~~~ ============My Testcase is teardown=========== SKIP 只teardown一次*********** ---------------------------------------------------------------------- Ran 4 tests in 0.006s OK (SKIP=1) 可以看见，setUpClass()以及tearDownClass都只执行了一次。在自动化测试中，可用来加载配置信息，只需要加载一次即可。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于python3的appium UI自动化框架搭建系列（一）]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%9F%BA%E4%BA%8Epython3%E7%9A%84appium-UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基于python3搭建appium ui自动化测试框架尝试系列（一） 框架实现目标12345678910自动找设备，连接设备自动启动appium server使用yml编写用例配置信息储存在ini文件或conf文件中自定义log，断言失败截图用例框架使用unittest或者nose用例报告html，用例执行完成邮件发送，附件测试报告多线程执行用例，失败重跑机制android自动监控权限弹窗执行过程红性能捕获（adb或者其他形式） 基于ddt和nose的简单尝试当前我能实现的appium自动化测试还是需要手动去起appium server，这点后面需要改善，github上有很多已经实现了的框架，但是不是很想直接拿来用，还是希望能够自己去一点一点的搭建。 即使是简单的尝试，还是想尽量实现多模块。 配置模块邮箱配置：包含邮件收发件人，密码，服务器等信息配置；日志配置：包含日志级别，时间格式，流处理器等；文件夹创建：包含获取当前日期，时间，创建文件夹等； 其实在之前的博客中已经实现，就不再贴代码了： 邮箱配置日志配置 文件夹创建是为了在测试过程中，出现断言失败的场景进行截图保存，文件夹使用两层，上一层为当前日期，下一层为当前时间，截图保存名字为断言失败的名字：MakeDirs.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;@author: kyle@time: 2018/2/7 10:17&quot;&quot;&quot;import time,osimport tracebackfrom datetime import datetime as dtdef getCurrentDate(): &quot;&quot;&quot;获取当前日期&quot;&quot;&quot; date = time.localtime() today = str(date.tm_year) + &quot;-&quot; + str(date.tm_mon) + &quot;-&quot; + str(date.tm_mday) return todaydef getCurrentTime(): &quot;&quot;&quot;获取当前时间&quot;&quot;&quot; time_str = dt.now() now = time_str.strftime(&apos;%H-%M-%S&apos;) return nowdef createDir(): &quot;&quot;&quot;获取当前文件所在路径绝对路径&quot;&quot;&quot; current_path = os.path.abspath(&apos;.&apos;) # 获取当前日期 today = getCurrentDate() # 构造以今天日期命名的目录的绝对路径 date_dir = os.path.join(current_path, today) print(date_dir) if not os.path.exists(date_dir): # 如果以今天日期命名的目录不存在则创建 os.mkdir(date_dir) # 获取当前时间字符串 now = getCurrentTime() # 构造以当前时间命名的目录的绝对路径 time_dir = os.path.join(date_dir, now) print(time_dir) if not os.path.exists(time_dir): # 如果以当前时间命名的目录不存在则创建 os.mkdir(time_dir) return time_dirdef takeScreenShot(driver, save_path, pic_name): &quot;&quot;&quot;截屏&quot;&quot;&quot; pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;) try: driver.get_screenshot_as_file(pic_path) except Exception as e: print(traceback.print_exc(), e) 执行模块实现思路是ddt获取数据对象，进行测试数据和代码分离，数据对象包含输入数据以及预期结果，对预期结果进行断言，实现测试实现。以百度搜索测试为例:DataDriverByObj.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env python3# -*- coding: utf-8 -*-import ddt,timeimport traceback,loggingfrom DdtTools.Log import *from selenium import webdriverfrom nose.tools import assert_truefrom selenium.common.exceptions import NoSuchElementExceptionfrom datetime import datetime as dtfrom DdtTools.MailSend import MailSend@ddt.ddtclass TestDDTByObj(): &quot;&quot;&quot;数据驱动测试&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; self.browser = webdriver.Chrome() @ddt.data( [u&quot;龙猫&quot;, &quot;宫崎骏&quot;], [u&quot;大话西游之月光宝盒&quot;, &quot;周星驰&quot;], [u&quot;卧虎藏龙&quot;, &quot;李安&quot;] ) @ddt.unpack def test_dataDrivenByObj(self, testdata, expectdata): url = &quot;https://www.baidu.com&quot; self.browser.get(url) # 隐式等待10s self.browser.implicitly_wait(10) try: # 定位搜索输入框，并输入测试数据 self.browser.find_element_by_id(&apos;kw&apos;).send_keys(testdata) # 定位搜索按键，单击 self.browser.find_element_by_id(&apos;su&apos;).click() time.sleep(3) # 断言期望结果是否出现在页面源码中 assert_true(expectdata in self.browser.page_source) except NoSuchElementException as e: logging.error(u&quot;查找的页面元素不存在，异常堆栈信息：&quot; + str(traceback.print_exc())) except AssertionError as e: info(u&quot;搜索：&#123;0&#125;，期望：&#123;1&#125;，失败&quot;.format(testdata, expectdata)) except Exception as e: logging.error(u&quot;未知错误，错误信息：&quot; + str(traceback.print_exc())) else: info(u&quot;搜索：&#123;0&#125;，期望：&#123;1&#125;，通过&quot;.format(testdata, expectdata)) time.sleep(2) self.browser.quit()if __name__ == &apos;__main__&apos;: # mail_subject, report_file mail_subject = &apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;)) report_file = &apos;D:/bug_things/selenium/report/DDTByObj.html&apos; mailsend = MailSend(mail_subject, report_file) print(&apos;开始执行自动化测试...&apos;) os.system(&apos;nosetests -v &#123;0&#125; --with-html --html-file=&#123;1&#125;&apos;.format(__file__, report_file)) # 发送测试报告邮件 print(&apos;开始发送测试报告...&apos;) mailsend.sendMail() print(&apos;测试报告发送完成...&apos;) 后记差不多现在还是实现到现在的程度，后面至少可以优化，测试数据从xls，xml，excel，mysql中读取。（感觉自己现在实现的还是好弱。。。） 附上github上已经实现的框架，供参考，建议还是自己去一点一点的搭建，直接用个人觉得是有点功利的做法了，写代码，还是慢慢来的好。 ATXAuto_AnalysisAPPIUM]]></content>
      <categories>
        <category>appium ui框架</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
        <tag>nose</tag>
        <tag>ddt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】python实现chrome伪装成M站]]></title>
    <url>%2F2018%2F02%2F06%2F%E3%80%90%E8%BD%AC%E3%80%91python%E5%AE%9E%E7%8E%B0chrome%E4%BC%AA%E8%A3%85%E6%88%90M%E7%AB%99%2F</url>
    <content type="text"><![CDATA[selenium实现Chrome伪装成M站，模拟手机端浏览器，并完成页面操作 原理：通过--user-agent=&quot;xxx&quot;来修改HTTP请求头部的Agent字符串，设置个人代理，使得PC端的Chrome浏览器伪装成手机浏览器，可以在地址栏输入”about:version”查看修改效果。 代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom Log import *import timeclass TestMobile(): &quot;&quot;&quot;测试chrome伪装成手机M站&quot;&quot;&quot; def test_iPadChrome(self): # 添加chrome设置 info(u&quot;===========伪装成ipad==========&quot;) info(u&quot;=====开始设置ipad个人代理=====&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0(iPad; CPU OS 5_0 like Mac OS X)&apos; &apos;AppleWebKit/534.46(KHTML, like Gecko) Version/5.1&apos; &apos;Mobile/9A334 Safari/7534.48.3&apos; ) browser = webdriver.Chrome(chrome_options=options) browser.get(&quot;https://www.baidu.com&quot;) time.sleep(3) browser.find_element_by_id(&apos;kw&apos;).send_keys(&quot;iPad&quot;) time.sleep(1) # 通过在Chrome浏览器地址栏输入about:version，查看伪装效果 browser.get(&quot;about:version&quot;) # 人工确认“用户代理”项配置信息是否和设置一致 time.sleep(10) info(u&quot;==========伪装ipad成功==========&quot;) browser.quit() def test_iPhoneChrome(self): # 添加chrome配置 info(u&quot;==========测伪装成iphone==========&quot;) info(u&quot;=====设置iphone个人代理=====&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0 (iPhone; CPU iPhone OS 5_0 like Mac OS X)&apos; &apos;AppleWebKit/534.46(KHTML, like Gecko) Version/5.1&apos; &apos;Mobile/9A334 Safari/7534.48.3&apos; ) browser = webdriver.Chrome(chrome_options=options) browser.get(&quot;https://www.baidu.com&quot;) time.sleep(3) # 定位搜索框 browser.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;iPhone&quot;) time.sleep(1) browser.get(&quot;about:version&quot;) time.sleep(10) info(u&quot;==========伪装成iphone成功==========&quot;) browser.quit() def testAndroid236Chrome(self): info(u&quot;==========测试伪装成android2.3.6==========&quot;) info(u&quot;=====设置android2.3.6个人代理=====&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0 (Linux; U; Android 2.3.5; en-us)&apos; &apos;Nexus S Build/GRK39F) AppleWebKit/533.1&apos; &apos;(KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&apos; ) brower = webdriver.Chrome(chrome_options=options) brower.get(&quot;https://www.baidu.com&quot;) # 定位搜索输入框 brower.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;Android 2.3.6&quot;) time.sleep(1) brower.get(&quot;about:version&quot;) time.sleep(10) info(u&quot;==========伪装成android2.3.6成功==========&quot;) brower.quit() def testAndroid402Chrome(self): info(u&quot;==========测试伪装成android4.0.2==========&quot;) info(u&quot;=====设置android4.0.2个人代理&quot;) options = webdriver.ChromeOptions() options.add_argument( &apos;--user-agent=Mozilla/5.0 (Linux; U; Android 4.0.2;&apos; &apos;en-us; Galaxy Nexus Build/ICL53F) AppleWebKit/534.30&apos; &apos;(KHTML, like Gecko) Version/4.0 Mobile Safari/534.30&apos; ) browser = webdriver.Chrome(chrome_options=options) browser.get(&quot;http://www.baidu.com&quot;) time.sleep(3) browser.find_element_by_id(&quot;index-kw&quot;).send_keys(&quot;Android 4.0.2&quot;) time.sleep(1) browser.get(&quot;about:version&quot;) time.sleep(10) info(u&quot;==========伪装成android4.0.2成功==========&quot;) browser.quit()if __name__ == &apos;__main__&apos;: testmobile = TestMobile() testmobile.testAndroid402Chrome() testmobile.testAndroid236Chrome() testmobile.test_iPhoneChrome() testmobile.test_iPadChrome() 偶然看见这个实现，目前没想到应用场景。。直接使用appium进行移动自动化好像也能实现啊。。（可能工作中遇见的太少了）]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logging模块使用简介]]></title>
    <url>%2F2018%2F02%2F02%2Flogging%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[python3日志模块，logging使用简介 日志打印python3使用logging进行日志打印，很简单，直接引logging包即可：123456789import logginglogging.warning(&quot;This is warning message&quot;)logging.critical(&quot;This is critical message&quot;)logging.error(&quot;This is error message&quot;)# 打印结果WARNING:root:This is warning messageCRITICAL:root:This is critical messageERROR:root:This is error message 默认情况下只显示了大于等于WARNING级别的日志。日志级别：1critical(50) &gt; error(40) &gt; warning(30) &gt; info(20) &gt; debug(10) 简单应用通过logging.basicConfig函数对日志的输出格式及方式做相关配置1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-import logginglogging.basicConfig( filename=&apos;test.log&apos;, format=&apos;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H-%M-%S&apos;, level=logging.DEBUG, #level=10)logging.critical(&quot;This ia critical message&quot;)logging.error(&quot;This is error message&quot;)logging.warning(&quot;This is warning message&quot;)logging.info(&quot;This is info message&quot;)logging.debug(&quot;This is debug message&quot;) logging.basicConfig函数各参数 1.filename：指定日志文件名2.filemode：和file函数意义相同，指定日志文件的打开模式，’w’或’a’；默认为’a’表示“append”。3.format：指定输出的格式和内容，format可以输出很多有用信息： 12345678910111213141516format参数中可能用到的格式化串：%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名%(funcName)s 调用日志输出函数的函数名%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s用户输出的消息 4.datefmt：指定时间格式，同time.strftime()5.level：设置日志级别，默认为logging.WARNING6.stream：指定将日志的输出流，可以指定输出到sys.stderr，sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略 模块介绍若要对logging进行更多灵活的控制，必须了解Logger，Handler，Formatter，Filter的概念：logger提供了应用程序可以直接使用的接口；handle将（logger创建的）日志记录发送到合适的目的输出；filter提供了细度设备来决定输出哪条日志记录；formatter决定日志记录的最终输出格式； Logger每个程序在输出信息之前都要获得一个Logger。Logger通常对应了程序的模块名，比如聊天工具的图形界面模块可以这样获得它的Logger：LOG=logging.getLogger(”chat.gui”)而核心模块可以这样：LOG=logging.getLogger(”chat.kernel”) Logger.setLevel(lel):指定最低的日志级别，低于lel的级别将被忽略。debug是最低的内置级别，critical为最高Logger.addFilter(filt)、Logger.removeFilter(filt):添加或删除指定的filterLogger.addHandler(hdlr)、Logger.removeHandler(hdlr)：增加或删除指定的handlerLogger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()：可以设置的日志级别 Handlerhandler对象负责发送相关的信息到指定目的地。Python的日志系统有多种Handler可以使用。有些Handler可以把信息输出到控制台，有些Logger可以把信息输出到文件，还有些Handler可以把信息发送到网络上。如果觉得不够用，还可以编写自己的Handler。可以通过addHandler()方法添加多个多handlerHandler.setLevel(lel):指定被处理的信息级别，低于lel级别的信息将被忽略Handler.setFormatter()：给这个handler选择一个格式Handler.addFilter(filt)、Handler.removeFilter(filt)：新增或删除一个filter对象 每个Logger可以附加多个Handler。接下来我们就来介绍一些常用的Handler： 1) logging.StreamHandler使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息。它的构造函数是:StreamHandler([strm])其中strm参数是一个文件对象。默认是sys.stderr 2) logging.FileHandler和StreamHandler类似，用于向一个文件输出日志信息。不过FileHandler会帮你打开这个文件。它的构造函数是：FileHandler(filename[,mode])filename是文件名，必须指定一个文件名。mode是文件的打开方式。参见Python内置函数open()的用法。默认是’a’，即添加到文件末尾。 3) logging.handlers.RotatingFileHandler这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。它的构造函数是：RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])其中filename和mode两个参数和FileHandler一样。maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。 4) logging.handlers.TimedRotatingFileHandler这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。它的构造函数是：TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。interval是时间间隔。when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：S 秒M 分H 小时D 天W 每星期（interval==0时代表星期一）midnight 每天凌晨 实例日志的一般操作顺序为：1.创建一个流类型handler用于输出日志到控制台(控制器)2.定义输出日志级别3.定义handler的输出格式formatter4.将handler添加到logging对象 同时输出日志到控制台和文件1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-import logginglogging.basicConfig( filename=&apos;test.log&apos;, format=&apos;%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s&apos;, datefmt=&apos;%Y-%m-%d %H-%M-%S&apos;, level=10)# 定义一个StreamHandler(日志流处理器)，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象console = logging.StreamHandler()console.setLevel(logging.INFO)# 格式化，设置控制台的日志输出格式formatter = logging.Formatter(&apos;%(name)-12s: %(levelname)-8s %(message)s&apos;)# 定义控制器的日志输出格式console.setFormatter(formatter)# 将控制器添加到logging对象logging.getLogger(&apos;&apos;).addHandler(console)logging.critical(&quot;This is critical message&quot;)logging.error(&quot;This is error message&quot;)logging.warning(&quot;This is warning message&quot;)logging.info(&quot;This is info message&quot;)logging.debug(&quot;This is debug message&quot;) 配置文件用法类似于java中的log4j的logging.config，我们也可以自己配置logger.conf文件： Logger.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950###############################################[loggers]keys=root,example01,example02[logger_root]level=DEBUGhandlers=hand01,hand02[logger_example01]handlers=hand01,hand02qualname=example01propagate=0[logger_example02]handlers=hand01,hand03qualname=example02propagate=0###############################################[handlers]keys=hand01,hand02,hand03[handler_hand01]class=StreamHandlerlevel=INFOformatter=form02args=(sys.stderr,)[handler_hand02]class=FileHandlerlevel=DEBUGformatter=form01args=(&apos;D:/bug_things/selenium/logs/AutoTest.log&apos;, &apos;a&apos;, &apos;utf-8&apos;)[handler_hand03]class=handlers.RotatingFileHandlerlevel=INFOformatter=form02args=(&apos;D:/bug_things/selenium/logs/AutoTest.log&apos;, &apos;a&apos;, 10*1024*1024, 5, &apos;utf-8&apos;)###############################################[formatters]keys=form01,form02[formatter_form01]format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)sdatefmt=%a, %d %b %Y %H:%M:%S[formatter_form02]format=%(name)-12s: %(levelname)-8s %(message)sdatefmt=%Y %m %d %H %M %S 封装方法将配置文件中定义的日志打印的配置进行封装，生成debug，info，message方法：Log.py1234567891011121314151617181920#!/usr/bin/env python3# -*- coding: utf-8 -*-import logging.configlogging.config.fileConfig(&quot;Logger.conf&quot;)def debug(message): # 打印debug级别的日志方法 logging.debug(message)def warning(message): # 打印warning级别的日志方法 logging.warning(message)def info(message): # 打印info级别的日志方法 logging.info(message) 应用以百度搜索为例:BaiDu.py1234567891011121314151617181920212223242526272829#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom Log import *import timeclass TestBaiDuSearch(): def __init__(self): # 启动浏览器 self.browser = webdriver.Chrome() def test_baidu_search(self): info(u&quot;===================搜索====================&quot;) url = &quot;https://www.baidu.com&quot; self.browser.get(url) info(u&quot;访问百度首页&quot;) self.browser.find_element_by_id(&apos;kw&apos;).send_keys(u&quot;自动化测试&quot;) info(u&quot;在输入框中搜索关键字“自动化测试”&quot;) self.browser.find_element_by_id(&apos;su&apos;).click() info(u&quot;单击搜索按键&quot;) info(u&quot;=================测试执行结束================&quot;) time.sleep(3) self.browser.quit()if __name__ == &apos;__main__&apos;: testbaidu = TestBaiDuSearch() testbaidu.test_baidu_search() 执行BaiDu.py文件，在D:/bug_things/selenium/logs目录下会生成AutoTest.log日志文件，文件内容：12345Fri, 02 Feb 2018 17:10:52 Log.py[line:20] INFO ===================搜索====================Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 访问百度首页Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 在输入框中搜索关键字“自动化测试”Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO 单击搜索按键Fri, 02 Feb 2018 17:10:53 Log.py[line:20] INFO =================测试执行结束================ 同时控制台打印信息：12345root : INFO ===================搜索====================root : INFO 访问百度首页root : INFO 在输入框中搜索关键字“自动化测试”root : INFO 单击搜索按键root : INFO =================测试执行结束================ 参考文章]]></content>
      <categories>
        <category>python黑科技</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python3</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码简单总结]]></title>
    <url>%2F2018%2F02%2F02%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[python字符串和编码 首先，字符串是一种数据类型，我们还经常会用到，然后，最常见的字符串问题就是字符编码问题，经常会看见文件打开一堆乱码，然后手工转utf-8啥的。 字符编码计算机基础计算机能够处理的只有数字，所以其他类型的数据想要被计算机识别并处理，首先要进行的就是字符编码，转换成数字之后处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是(11111111,二进制的255)，如果要表示更大的整数，就必须更多的字节，比如两个字节可以表示最大整数是65535。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。 字库表字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。 字符集字符集是一个系统支持的所有抽象字符的集合。常见的字符集有ASCII，UTF-8，UTG-16，GB2313等。 字符编码字符编码可以看成是一套规则，目的就是在符号集合和数字系统直接建立对应关系。常见的字符编码有Unicode，ASCII，UTF-8等 三者关系字库表可以看成是一个全球统一的可读可用的字符库，但是实际使用过程中，很少需要用到这么多字符，例如，中文系统基本就用不到日文的字符，所以也就不需要日文字符的那一部分集合；因此就会诞生一个个的类似于定制的字符集合，这就是字符集，集合中包含了数据和字母的一个个对应关系，这就是字符编码。以ASCII为例： ASCIIASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以勉强显示其他西欧语言。它是现今最通用的单字节编码系统（但是有被Unicode追上的迹象），并等同于国际标准ISO/IEC 646。 ASCII字符集：主要包括控制字符（回车键、退格、换行键等）；可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 ASCII编码：将ASCII字符集转换为计算机可以接受的数字系统的数的规则。使用7位（bits）表示一个字符，共128字符；但是7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。 python字符编码ASCII是出现比较早的字符编码，但是其中只包含了数字和英文大小写字符，对于中文，日文等字符就不适用了，国内学者为了能够完成中文编码，就指定了GB2312编码，同样的，很多国家都有指定自己的编码，这样就会遇到一个问题，中文编码到日文编码的环境查看，会发生乱码，因为根本就不支持这样的字符，为了解决这个问题，一个统一的编码就诞生了Unicode，Unicode编码不同于ASCII的使用一个字节表示一个字符，它使用的是两个字节表示一个字符（中文至少需要两个字节），生僻字符就需要4个字符。字母’A’用ASCII编码，十进制是65，二进制是01000001；用Unicode编码结果是00000000 01000001。当全部都使用Unicode编码时，乱码问题肯定是得到解决了，但是有个问题，Unicode编码时连个字节表示的一个字符，那么就会比原来使用ASCII编码多出了至少一倍的内存空间占用，怎么都觉得很亏。所以，为了节约内存空间，又出现了把Unicode编码转换为“可变长编码”的utf-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。 下面来弄清楚python的字符编码：在python3中，字符串是以Unicode编码的，也就是说，支持多语言。由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示：1x = b&apos;ABC&apos; 注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。 编码及解码首先python使用的是Unicode编码，字符串进行网络或者磁盘存储时，需要先编码成指定类型bytes，使用encode()方法即可。例如：12print(&apos;中文&apos;.encode(&apos;utf-8&apos;))b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 反过来，从网络或者磁盘上读取字节流，那么读到的数据是bytes，要把bytes转换为str，就需要使用decode()方法进行解码，例如：12print(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;))中文 在进行日常python编程中，在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上:12#!/usr/bin/env python3# -*- coding: utf-8 -*- pycharm设置方法：File-Settings-Editor-File and Code Templates-Python Script设置中添加上这两行即可。 以前曾经写过一篇博，关于设置python编码的:python编码 参考链接 廖雪峰的python教程字符集合字符编码 后记：由于昨天公司发生的很无语加无理取闹的一些事，整个办公室氛围都是压抑的，网上的教程资料也没怎么细致的看进去，写出来的总结也就是乱七八糟的，估计静下来之后我自己都看不懂。。。以后再来修改吧。唉，做技术的，干嘛不追求技术的进步，弄一些有的没的办公室政治呢，有意思吗？]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现断言失败截图]]></title>
    <url>%2F2018%2F02%2F02%2F%E5%AE%9E%E7%8E%B0%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5%E6%88%AA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[python基于selenium进行自动化测试，实现断言失败进行截图 进行自动化测试过程中，经常会遇见断言失败，时候补查失败的场景，要么是保存日志，要么就是保存失败的截图。尝试实现，在断言失败时候，加入实时截图： 编码出错遇到问题：截图文件名编码格式转换时候，会报错（以下写法在python 2.7可以使用）1pic_path = os.path.join(save_path, str(pic_name).decode(&quot;utf-8&quot;).encode(&quot;gbk&quot;) + &quot;.png&quot;) 报错：1AttributeError: &apos;str&apos; object has no attribute &apos;decode&apos; 查找原因：既然python 2.7可以正常执行，那就应该是python 3对于编码进行了变更。 Stack Overflow上大家好像都是经常踩我踩过的所有坑..又找到答案了：这位大哥的回答：1234Begin with Python 3, all string is unicode object. a = &apos;Happy New Year&apos; # Python 3 b = unicode(&apos;Happy New Year&apos;) # Python 2the code before are same. So I think you should remove the .decode(&apos;utf-8&apos;). Because you have already get the unicode object. python3的普通字符串是str，所以python3的str就相当于python2的Unicode。大致意思好像就是python3使用的str类型并不关心你最终是什么编码，无论是utf-8还是gb2312，它只是用Unicode字符集编码来表示每一个字符，直到输出到文件流，需要转换为bytes类型时，才用encode指定具体的编码实现方式。 python的中间编码是Unicode，所以python2就需要先进行解码（decode）到中间编码，再进行编码（encode）到指定编；，而python3直接可以转换到指定编码（encode）1在python3中，str-- encode -&gt; bytes-- decode -&gt; str python3编码系统编码123456789101112import sys# 系统默认编码print(sys.getdefaultencoding())# 字符串编码s = &quot;中文&quot;s_utf8 = s.encode(&apos;utf-8&apos;)print(type(s))print(type(s_utf8))utf-8&lt;class &apos;str&apos;&gt;&lt;class &apos;bytes&apos;&gt; 可以看到，python3的系统编码就是utf-8，为了避免自找麻烦，牢记使用utf-8即可！所以上述报错代码可以更改为：1pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;) 断言失败截图实例实现目标是在进行自动化测试过程中，一旦发生断言失败，就根据当前时间，在工程下创建名称为当前日期的目录，，目录下创建名称为当前时间的文件夹，文件夹中保存断言失败的屏幕截图 获取当前日期和时间123456789101112131415161718192021#!/usr/bin/env python3# -*- coding: utf-8 -*-import timefrom datetime import datetime as dt&quot;&quot;&quot;用于获取当前的日期以及时间用于生成保存截图文件目录名&quot;&quot;&quot;def current_date(): date = time.localtime() # 构造今天的日期字符串 today = str(date.tm_year) + &quot;-&quot; + str(date.tm_mon) + &quot;-&quot; + str(date.tm_mday) return todaydef current_time(): time_str = dt.now() # 构建当期时间字符串 now = time_str.strftime(&apos;%H-%M-%S&apos;) return now 创建目录和文件夹123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- coding: utf-8 -*-from DateUtil import current_time, current_dateimport os&quot;&quot;&quot;用于创建目录，用于存放异常截图&quot;&quot;&quot;def create_dir(): # 获得当前文件所在目录的绝对路径 current_path = os.path.abspath(&apos;.&apos;) # 获取今天的日期字符串 today = current_date() # 构造以今天日期命名的目录的绝对路径 date_dir = os.path.join(current_path, today) print(date_dir) if not os.path.exists(date_dir): # 如果以今天日期命名的目录不存在则创建 os.mkdir(date_dir) # 获取当前的时间字符串 now = current_time() # 构造以当前时间命名的目录的绝对路径 time_dir = os.path.join(date_dir, now) print(time_dir) if not os.path.exists(time_dir): # 如果以当前时间命名的目录不存在则创建 os.mkdir(time_dir) return time_dir 百度搜索示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom FileUtil import create_dirfrom nose.tools import assert_trueimport time,osimport traceback# 创建存放异常截图的目录，并得到本次实例中存放图片目录的绝对路径，作为全局变量，供本次所有测试用例调用pic_dir = create_dir()def take_screenshot(driver, save_path, pic_name): # 封装截屏方法 # 构造屏幕截图路径及图片名 # 因为windows默认编码是GBK，而传入的图片名是utf-8编码，所以需要进行转码，以便让图片名中的中文字符能够正常显示 pic_path = os.path.join(save_path, str(pic_name) + &quot;.png&quot;) try: # 调用webdriver提供的get_screenshot_as_file()方法，将截取的屏幕图片保存为本地文件 driver.get_screenshot_as_file(pic_path) except Exception as e: print(traceback.print_exc(), e)class TestFailCaptureScreen(): def __init__(self): &quot;&quot;&quot;启动浏览器&quot;&quot;&quot; self.browser = webdriver.Chrome() def test_baidu_search(self): url = &quot;https://www.baidu.com&quot; self.browser.get(url) try: self.browser.find_element_by_id(&apos;kw&apos;).send_keys(u&quot;自动化测试&quot;) self.browser.find_element_by_id(&apos;su&apos;).click() time.sleep(3) # 断言页面的代码中是否存在“自动化测试框架_百度百科”这几个字 assert_true(u&quot;纯净方糖&quot; in self.browser.page_source) # 页面中没有断言的几个字，所以会触发except语句的执行，并触发截图操作 except AssertionError as e: take_screenshot(self.browser, pic_dir, e) except Exception as e: take_screenshot(self.browser, pic_dir, e) time.sleep(2) self.browser.quit()if __name__ == &apos;__main__&apos;: testfailscreen = TestFailCaptureScreen() testfailscreen.test_baidu_search() 感觉是时候研究一波python字符编码了…]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现自动化测试数据分离]]></title>
    <url>%2F2018%2F02%2F01%2F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[使用数据分离自动化测试，测试执行完成自动邮件发送 配置文件配置文件中的内容为工程所有配置信息，各个模块的元素定位的方法以及值，服务器（应用服务器和数据库服务器）配置信息，用户账号密码等信息 实例，cashier.ini 1234567891011121314[login]storeNo = id &gt; com.anmav.cashierdesk:id/etStoreNousername = id &gt; com.anmav.cashierdesk:id/login_accountEdtpwd = id &gt; com.anmav.cashierdesk:id/login_paswEdtlogin = id &gt; com.anmav.cashierdesk:id/tvLoginlogin_store = ***login_user = ***login_pwd = ***[mailmsg]mail_user = ***mail_pwd = ***mail_to = ***mail_host = *** 该配置文件包含了login模块进行元素定位需要的方法以及值，在工程中进行元素定位值，只需要使用configparser模块完成配置文件读取即可。 邮件发送数据分离封装数据分离之后的邮件发送类(MailSend.py)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python3# -*- coding: utf-8 -*-from email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartimport smtplibimport configparserimport osclass MailSend(): &quot;&quot;&quot;邮件发送&quot;&quot;&quot; def __init__(self, mail_subject, report_file): self.mail_subject = mail_subject self.report_file = report_file self.settings = os.path.abspath(&apos;..&apos;) + &quot;\cashier_conf\cashier_setting.ini&quot; def send_mail(self): &quot;&quot;&quot;读取测试报告&quot;&quot;&quot; cf = configparser.ConfigParser() cf.read(self.settings) cf.sections() # 获取邮箱发件人，密码，收件人，邮件服务器 mail_user = cf.get(&apos;mailmsg&apos;, &apos;mail_user&apos;) mail_pwd = cf.get(&apos;mailmsg&apos;, &apos;mail_pwd&apos;) mail_to = cf.get(&apos;mailmsg&apos;, &apos;mail_to&apos;) mail_host = cf.get(&apos;mailmsg&apos;, &apos;mail_host&apos;) # 发送邮件配置 with open(self.report_file, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f_obj: content = f_obj.read() msg = MIMEMultipart(&apos;mixed&apos;) # 添加邮件内容 msg_html = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg.attach(msg_html) # 添加附件 msg_attachment = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg_attachment[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&#123;0&#125;&apos;.format(self.report_file) msg.attach(msg_attachment) msg[&apos;Subject&apos;] = self.mail_subject msg[&apos;Form&apos;] = mail_user msg[&apos;To&apos;] = mail_to try: # 连接邮箱服务器 s = smtplib.SMTP() s.connect(mail_host) # 登录 s.login(mail_user, mail_pwd) # 发送邮件 s.sendmail(mail_user, mail_to, msg.as_string()) s.quit() except Exception as e: print(&quot;发送邮件异常：&quot;, e) 元素定位数据分离封装了元素定位的方法（find_element_by…），实现在工程中进行元素定位时，直接调用方法(GetElement.py)：123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium.webdriver.support.ui import WebDriverWaitimport osimport configparserimport tracebackclass GetElement(): &quot;&quot;&quot;获取元素定位方法和值&quot;&quot;&quot; def __init__(self): # 读取配置文件 self.settings = os.path.abspath(&apos;..&apos;) + &quot;/cashier_conf/cashier_setting.ini&quot; self.cf = configparser.ConfigParser() self.cf.read(self.settings) self.cf.sections() def get_elementId(self, driver, webSiteName, webelement): try: # 获取配置文件中的定位方法以及定位元素 webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;) webelement_method = webElemnt[0].strip() webelement_expression = webElemnt[1].strip() element = WebDriverWait(driver, 10).until\ (lambda x: x.find_element(webelement_method, webelement_expression)) except Exception as e: print(traceback.print_exc(), e) else: return element 自动化测试实现数据分离使用数据分离的方式完成系统登录的自动化测试，方便维护，后期只需要维护cashier_setting.ini文件即可(testlogin.py)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparser, osimport tracebackfrom datetime import datetime as dtfrom appium import webdriverfrom nose.tools import assert_truefrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.common.exceptions import NoSuchElementException,TimeoutExceptionfrom cashier_tools.GetElement import GetElementfrom cashier_tools.MailSend import MailSendclass Login(): &quot;&quot;&quot;登录&quot;&quot;&quot; def __init__(self): # 初始化，配置环境 self.desired_caps = &#123;&#125; self.desired_caps[&apos;platformName&apos;] = &apos;Android&apos; self.desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos; self.desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos; self.desired_caps[&apos;noReset&apos;] = True self.desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos; self.desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.login.activity.LoginActivity&apos; self.driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, self.desired_caps) self.elementid = GetElement() def test_login(self): settings = os.path.abspath(&apos;..&apos;) + &quot;/cashier_conf/cashier_setting.ini&quot; cf = configparser.ConfigParser() cf.read(settings) cf.sections() # 定位门店编号输入框 storeno = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;storeNo&apos;) storeno.click() storeno.clear() store_no = cf.get(&apos;login&apos;, &apos;login_store&apos;) storeno.send_keys(store_no) self.driver.hide_keyboard() # 定位用户名 username = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;username&apos;) username.click() username.clear() user = cf.get(&apos;login&apos;, &apos;login_user&apos;) username.send_keys(user) self.driver.hide_keyboard() # 定位密码 pwd = self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;pwd&apos;) pwd.click() pwd.clear() password = cf.get(&apos;login&apos;, &apos;login_pwd&apos;) pwd.send_keys(password) self.driver.hide_keyboard() # 登录 self.elementid.get_elementId(self.driver, &apos;login&apos;, &apos;login&apos;).click() try: # 显示等待，门店名称出现 WebDriverWait(self.driver, 10).until(lambda x:x.find_element_by_id(cf.get(&apos;order&apos;, &apos;store_name&apos;))) # 断言登录成功 assert_true(u&quot;点餐&quot; in self.driver.page_source) except NoSuchElementException as e: print(traceback.print_exc(), e) except TimeoutException as e: print(traceback.print_exc(), e)if __name__ == &apos;__main__&apos;: mail_subject = &apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;)) report_file = &apos;Login.html&apos; mailsend = MailSend(mail_subject, report_file) print(&apos;开始执行自动化测试...&apos;) os.system(&apos;nosetests -v &#123;0&#125; --with-html --html-file=&#123;1&#125;&apos;.format(__file__, report_file)) # 发送测试报告邮件 print(&apos;开始发送测试报告...&apos;) mailsend.send_mail() print(&apos;测试报告发送成功&apos;) 单独的邮件发送模块可参照之前一篇：python实现自动化测试报告邮件实时发送]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>python3</tag>
        <tag>数据分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】python元类介绍]]></title>
    <url>%2F2018%2F01%2F31%2F%E3%80%90%E8%BD%AC%E3%80%91python%E5%85%83%E7%B1%BB%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[python元类 转自stackoverflow 神级人物e-satis的神级回复，以及国内翻译组汉化结果： 写在前面：经常在stackoverflow上看见一些神一般的回答，也看到过很多次创建Foo类，特意上维基百科搜了，解释如下：123foobar是计算机程序领域里的术语炒作，并无实际用途和参考意义。 在计算机程序设计与计算机技术的相关文档中，术语foobar是一个常见的无名氏化名，常被作为“伪变量”使用。单词“foobar”或分离的“foo”与“bar”常出现于程序设计的案例中，如同Hello World程序一样，它们常被用于向学习者介绍某种程序语言。“foo”常被作为函数／方法的名称，而“bar”则常被用作变量名。 正题类也是对象（Classes as objects）在理解元类之前，需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：123456class ObjectCreator(object): passmy_object = ObjectCreator()print(my_object)&lt;__main__.ObjectCreator object at 0x000001899B36E550&gt; 但是python中的类远不止如此。类同样也是一种对象 这个对象（类）自身用创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它本质上仍然是一个对象，所以，你可以对它进行如下操作：1、将它赋值给一个变量2、拷贝它3、为它增加属性4、将它作为函数参数进行传递 示例：12345678910111213141516171819202122class ObjectCreator(object): pass# 打印一个类，因为它其实也是一个对象print(ObjectCreator)&lt;class &apos;__main__.ObjectCreator&apos;&gt;# 将类作为参数传给函数def echo(o): print(o)echo(ObjectCreator)&lt;class &apos;__main__.ObjectCreator&apos;&gt;# 为类增加属性print(hasattr(ObjectCreator, &apos;new_attribute&apos;))ObjectCreator.new_attribute = &apos;foo&apos;print(hasattr(ObjectCreator, &apos;new_attribute&apos;))print(ObjectCreator.new_attribute)FalseTruefoo# 将类赋值给一个变量ObjectCreatorMirror = ObjectCreatorprint(ObjectCreatorMirror())&lt;__main__.ObjectCreator object at 0x000002C21DF1E550&gt; 动态地创建类因为类也是对象，你可以在运行时动态地创建它们，就想其他任何时候一样。首先，你可以在函数中创建类，使用class关键字即可。1234567891011121314def choose_class(name): if name == &apos;foo&apos;: class Foo(object): pass return Foo else: class Bar(object): pass return BarMyClass = choose_class(&apos;foo&apos;)print(MyClass)print(MyClass())&lt;class &apos;__main__.choose_class.&lt;locals&gt;.Foo&apos;&gt;&lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x000002B57928B518&gt; 但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是用过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象，但就和python中的大多数事情一样，python仍然提供给你手动处理的方法。內建函数type，可以让你知道一个对象的类型是什么：12345678print(type(1))print(type(&quot;1&quot;))print(type(ObjectCreator))print(type(ObjectCreator()))&lt;class &apos;int&apos;&gt;&lt;class &apos;str&apos;&gt;&lt;class &apos;type&apos;&gt;&lt;class &apos;__main__.ObjectCreator&apos;&gt; 这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类（同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后的兼容性） type可以像这样工作：1type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称知道）) 比如如下的代码：12class MyShinyClass(object): pass 可以手动像这样创建：123456# 返回一个对象MyShinyClass = type(&apos;MyShinyClASS&apos;, (), &#123;&#125;)print(MyShinyClass)print(MyShinyClass())&lt;class &apos;__main__.MyShinyClASS&apos;&gt;&lt;__main__.MyShinyClASS object at 0x00000214ED6FE5F8&gt; type接受一个字典来为类定义属性，因此12class Foo(object): bar = True 可以翻译为：1Foo = type(&apos;Foo&apos;, (), &#123;&apos;bar&apos;:True&#125;) 并且可以将Foo当做一个普通的类一样使用：123456789print(Foo)print(Foo.bar)f = Foo()print(f)print(f.bar)&lt;class &apos;__main__.Foo&apos;&gt;True&lt;__main__.Foo object at 0x000002C77F0FD4E0&gt;True 当然，你可以向这个类继承，所以，如下的代码：12class FooChild(Foo): pass 就可以写成：123FooChild = type(&apos;FooChild&apos;, (Foo,), &#123;&#125;)print(FooChild)print(FooChild.bar) 到底什么是元类元类就是用来创建类的“东西”，你创建类就是为了创建类的实例对象，但是我们知道python中的类也是对象，而元类就是用来创建这些类（对象）的，所以，元类就是类的类，可以这样理解：12MyClass = MetaClass()MyObject = MyClass() 你可以看到了type可以让你像这样做：1MyClass = type(&apos;MyClass&apos;, (), &#123;&#125;) 这是因为函数type实际上是一个元类，type就是python背后用来创建所有类的元类，所以type为什么不写成Type也就知道了吧，或许就是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type即使创建类对象的类。你可以通过class属性来看到这一点。Python中的所有的东西，注意，所有的东西——都是对象。这包含整数、字符串、函数和类。它们都是对象，而且它们都是从一个类创建来的。 12345678910age = 24print(age.__class__)name = &apos;bob&apos;print(name.__class__)def foo(): passprint(foo.__class__)&lt;class &apos;int&apos;&gt;&lt;class &apos;str&apos;&gt;&lt;class &apos;function&apos;&gt; 现在，对于任何一个class的class属性又是什么呢？123456print(age.__class__.__class__)print(name.__class__.__class__)print(foo.__class__.__class__)&lt;class &apos;type&apos;&gt;&lt;class &apos;type&apos;&gt;&lt;class &apos;type&apos;&gt; 因此，元类就是窗累类这种对象的东西，如果你喜欢的话，可以把元类称谓”类工厂”（不是工厂类）,type就是python內建的元类，当然了，你也可以创建自己的元类。 __metaclass__属性你可以在写一个类的时候为其添加metaclass属性。 123class Foo(object): __metaclass__ = somethind,.,[...] 如果你这么做了，python就会用元类来创建类Foo。这里面有技巧，你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它创建类Foo，如果没找到，就会用內建的type来创建这个类。 当你写下如下代码时：12class Foo(Bar): pass Python做了如下的操作： Foo中有__metaclass__这个属性吗？如果有，python会在内存中通过__metaclass__创建一个名字为Foo的类对象（注意是类对象）。如果python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果python在任何父类中都找不到__metaclass__，它就会在模块层面中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__，python就会用内置的type来创建这个类对象。 现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案是：可以是可以创建一个类的东西。那什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东西都可以。 自定义元类元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定你的模块里所有的类的属性都应该是大写形式，有好几种方法可以实现，单其中一种就是通过在模块级别设定__metaclass__，采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改写成大写形式就解决了。 幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我们都知道，名字里面带’class’的东西，并不一定是个class） 我们这里先以一个简单的函数作为例子开始：12345678910111213141516171819202122232425# 元类会自动将你通常传给&apos;type&apos;的参数作为自己的参数传入def upper_attr(future_class_name, future_class_parents, future_class_attr): &quot;&quot;&quot; 返回一个类对象，将属性都转为大写形式 &quot;&quot;&quot; # 识别所有不以&apos;__&apos;开头的属性，将它转换为大写 uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # type创建这个类 return type(future_class_name, future_class_parents, uppercase_attr)# 这行会影响模块中的所有类__metaclass__ = upper_attrclass Foo(): # 全局 __metaclass__不会和&apos;object&apos;一起生效，但是我们可以在这里定义__metaclass__来只对这个类生效 bar = &apos;bip&apos;print(hasattr(Foo, &apos;bar&apos;))print(hasattr(Foo, &apos;BAR&apos;)) 现在让我们再做一次，这一次用一个真正的class来当元类123456789101112131415161718192021# 请记住，&apos;type&apos;实际上是一个类，就像&apos;str&apos;和&apos;int&apos;一样# 所以，你可以从type继承class UpperAttrMetaclass(type): # __new__ 是在 __init__之前被调用的特殊方法 # __new__是用来创建对象并返回的方法 # __init__只是用来把传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type(future_class_name, future_class_parents, uppercase_at 但是这不是OOP（Object-oriented programming，面向对象编程）。我们直接调用了type，而且我们没有改写父类的new方法。现在，我们这样去处理：12345678910111213141516class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = &#123;&#125; for name, val in future_class_attr.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # 复用type.__new__方法 # 这就是基本的OOP编程，没什么魔法 return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr) 你可以已经注意到了有个额外的参数uppersttr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就想在普通的类方法中的self参数一样。当然了，为了清晰起见，这边将名字起的比较长。但是就想self一样，所有的参数都有它们的传统名称。因此，在真是的产品代码中一个元类应该像这样：123456789101112class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = &#123;&#125; for name, val in dct.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type.__new__(cls, clsname, bases, uppercase_attr) 如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）123456789101112class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = &#123;&#125; for name, val in dct.items(): if not name.startswith(&apos;__&apos;): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr) 就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒不是因为元类本身，二十因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑魔法”是特别有用的，因而会搞出些复杂的东西来。但是元类本身而言，它们其实是很简单的： 1，拦截类的创建2，修改类3，返回修改之后的类 为什么要用metaclass类而不是函数由于__metaclass__可以接受任何可调用的对象，那为什么还要使用类呢，因为很显然使用类会更加复杂，这里有好几个原因： 1，意图会更加清晰，当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么2，你可以使用OOP编程。元类可以从元类中继承，改写父类方法，甚至可以使用元类3，你可以把代码组织的更好，当你使用元类的时候肯定不会像上述的简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。4，你可以使用__new__，__init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服点。 究竟为什么要使用元类现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，根本用不上它： “元类就是深度的魔法，99%的用户根本不必为此操心。如果你想搞清楚究竟是否需要用来元类，那么你就不需要它。那么实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类” ——Python界的领袖Tim Peters 元类的主要用途是创建API，一个典型的例子是Django ORM。它允许你像这样定义：123class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() 但是如果你像这样做的话：12guy = Person(name=&apos;bob&apos;, age=&apos;35&apos;)print guy.age 这并不会返回一个IntegerFied对象，而是会放回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__，并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 结语首先，你知道了类其实是能够创建出类实例的对象。事实上，类本身也是实例，当然，它们是元类的实例：1234class Foo(object): passprint(id(Foo))1973075749880 Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：12Monkey patchingclass decorators 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然，其实在99%的时间里你根本就不需要动态修改类。 原链接 stackoverflow原链接国内翻译站]]></content>
      <categories>
        <category>python黑科技</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS重建记]]></title>
    <url>%2F2018%2F01%2F24%2FVPS%E9%87%8D%E5%BB%BA%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[VPS重新部署日常环境，及hexo博客快速重建 VPS受灾记大早上来发现stackoverflow首页都打不开，对于天天科学上网的我来说，简直莫名其妙。 本地网络原因本地windows PC机，控制台ping IP：1ping VPS_IP 直接就超时了，匪夷所思。。VPS服务器 ping自己：1ping 127.0.0.1 好歹能通，那就是中间路由断了。 手机下载个网络工具，尝试在手机端ping VPS的IP（排除公司DNS搞的鬼），手机上ping也直接超时了，好吧，可以去检查是不是在某个不知名的时候自己把防火墙开了，还把22等端口关了。。 VPS排查我的VPS是在LA的CENTOS7主机，centos7查看防火墙状态：1firewall-cmd --state 发现是关着的。。。为了排除自己之前装过iptables的服务，查看iptables.service：1systemctl status iptables.service 这个果然是开着的，查看启用的端口：1cat /etc/sysconfig/iptables 该开的端口也都开了，好吧，无语了。 大环境排查基于大家都懂的网络环境，怀疑是IP被墙了，检测：1http://ping.chinaz.com 果然，除了香港和国外，其他都ping不通VPS，好吧，可以下结论了:IP被墙了… 真的很想骂人啊！到底是哪个JR没事瞎玩，搞出个异常流量，害的无辜躺枪！！！hexo还在VPS上，小飞机也在VPS上，没有梯子，科学上网个鬼啊！！！ 骂人几轮，该弄得还是得弄，方案嘛，无非就是换IP，还好Vultr重建台服务还是很方便的。 VPS重建Vultr重买服务器，这次比较幸运，居然有$2.5的，直接买：Vultr官网拿到IP之后，第一件事，肯定是ping IP，还好，可以ping通，就是你了！ VPS简单设置 防火墙设置xshell远程连接上VPS之后，习惯性操作，第一步，更新yum1yum update firewall设置由于centos7默认的防火墙服务时firewalld的，很不习惯，改！ 查看防火墙状态1firewall-cmd --state 关闭防火墙1systemctl stop firewalld.service 禁止开机启动启动防火墙1systemctl disable firewalld.service iptables设置安装iptables服务：1yum install iptables-services 开启iptables防火墙:1systemctl start iptables.service 开启特定端口：编辑文件：/etc/sysconfig/iptables，加入想要开放的端口即可，例如开放8090端口：1-A INPUT -p tcp -m tcp --dport 8090 -j ACCEPT 保存，退出之后，重启防火墙完成设置:1systemctl restart iptables.service ShadowsocksR（小飞机）配置科学上网必不可少的工具，ShadowsocksR 安装：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 完成配置：12345服务器端口：自己设定（如不设定，默认为 8989）密码：自己设定（如不设定，默认为 teddysun.com）加密方式：自己设定（如不设定，默认为 aes-256-cfb）协议（Protocol）：自己设定（如不设定，默认为 origin）混淆（obfs）：自己设定（如不设定，默认为 plain） 附上我的配置，仅供参考：123456Your Server IP : ***.***.***.*** Your Server Port : ***** Your Password : ******* Your Protocol : auth_sha1_v4 Your obfs : tls1.2_ticket_auth Your Encryption Method: aes-256-cfb 配置完成之后就可以在本地PC机使用客户端进行梯子配置，完了就可以科学上网啦！！！客户端度娘盘链接 Hexo重建预备动作：原来VPS上面的hexo所在目录，直接打成压缩包scp出来 安装node.js首先安装gcc用于编译：1yum -y install gcc gcc-c++ kernel-devel 开始安装node.js12wget https://nodejs.org/dist/v4.5.0/node-v4.5.0.tar.gztar -xf node-v4.5.0.tar.gz 解压缩之后，进入目录，编译：1234cd node-v4.5.0./configuremakemake install 完成！验证：12node -vnpm 安装完成的是4.5的版本，升级：12npm install -g nn stable 安装git由于买的VPS已经集成了git，所以怎么安装，怎么配置环境变量啥的就不废话了。1、VPS设置git：12git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 邮箱和用户名都对应于github 2、生成ssh秘钥1ssh-keygen -t rsa -C example@163.com 默认保存路径是/root/.ssh下：1cat /root/.ssh/id_rsa.pub 获取秘钥，然后到github的web页面将秘钥配置进去，完成！ 安装hexo1、安装hexo创建目录1mkdir blog 安装1234cd blognpm install -g hexo-cli#初始化hexo init 2、安装插件12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 3、修改Hexo配置文件，完成！ 或者，直接把原来VPS上面hexo的压缩包解压，再配置安装hexo即可1npm install hexo --save 环境测试12hexo new &quot;安装测试&quot;hexo g -d 执行不报错，进入博客可以看见安装测试该文章，部署成功！ 真的是坑啊，又重布环境，国内的网络环境啊，ε=(´ο｀*)))唉~ 参考链接 centos搭建hexo博客]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现自动化测试报告邮件实时发送]]></title>
    <url>%2F2018%2F01%2F23%2Fpython%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E9%82%AE%E4%BB%B6%E5%AE%9E%E6%97%B6%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[实现自动化用例执行完成之后，自动发送带html附件的邮件到邮箱 实现思路：读取html附件内容，添加到邮件正文中，添加html附件，实现用例执行完成，测试报告自动发送到邮箱。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env python3# -*- coding: utf-8 -*-import osimport smtplibfrom datetime import datetime as dtfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom nose.tools import assert_equaldef send_mail(): &quot;&quot;&quot;读取测试报告&quot;&quot;&quot; with open(report_file, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f_obj: content = f_obj.read() msg = MIMEMultipart(&apos;mixed&apos;) # 添加邮件内容 msg_html = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg.attach(msg_html) #添加附件 msg_attachment = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;) msg_attachment[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;&#123;0&#125;&quot;&apos;.format(report_file) msg.attach(msg_attachment) msg[&apos;Subject&apos;] = mail_subject msg[&apos;Form&apos;] = mail_user msg[&apos;To&apos;] = mail_to try: # 连接邮件服务器 s = smtplib.SMTP() s.connect(mail_host) # 登录 s.login(mail_user, mail_pwd) # 发送邮件 s.sendmail(mail_user, mail_to, msg.as_string()) # 退出 s.quit() except Exception as e: print(&quot;Exception&quot;, e)class Mailsend(): def test_mul(self): a = 1 b = 2 res = 3 assert_equal(res, a+b)if __name__ == &apos;__main__&apos;: # 邮件服务器 mail_host = &apos;smtp.163.com&apos; # 发件人地址 mail_user = &apos;***&apos; # 发件人密码 mail_pwd = &apos;***&apos; # 邮件标题 mail_subject = u&apos;NoseTests_测试报告_&#123;0&#125;&apos;.format(dt.now().strftime(&apos;%Y%m%d&apos;)) # 收件人地址 mail_to = &apos;***&apos; # 测试报告名称 report_file = &apos;NoseTestReport.html&apos; # 运行nosetests进行自动化测试并生成测试报告 print(&apos;Run NoseTests Now...&apos;) os.system(&apos;nosetests -v mail_html.py:Mailsend --with-html --html-file=NoseTestReport.html&apos;) # 发送测试报告邮件 print(&apos;Send Test Report Mail Now...&apos;) send_mail() tips:123python客户端进行163,126邮箱邮件发送前，需要在web版邮箱中设置允许客户端访问，设置客户端授权码设置完授权码之后，此时的客户端登录密码为授权码，不是原来的邮箱密码]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>smtplib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分离]]></title>
    <url>%2F2018%2F01%2F20%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[python数据分离——读取配置文件 版本：python 3.6 进行数据/配置和代码分离时，python3.6 可以使用configparser进行配置信息读取或创建。可以实现程序和数据的分离，便于后期维护程序，也能在一定程序上满足不会编码的人进行自动化测试（只需改配置文件。） 以创建/读取ini格式配置文件为例： 创建配置文件：每个ini文件都是有n个sections组成（可以理解为组成部分或者是段落。。我是这么理解的），每个sections包含若干个键值对（keys:values），所以某种程度上，你可以把每个section看成是个字典（dictionary），虽然这俩意义上完全无关。python3.6创建ini配置文件代码示例：1234567891011121314151617181920212223#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparsercf = configparser.ConfigParser()cf[&apos;DEFAULT&apos;] = &#123;&quot;browser&quot; : &quot;Chrome&quot;, &quot;version&quot; : &quot;63.0.3239.132&quot;, &quot;driver&quot; : &quot;chromedriver.exe&quot;, &#125;cf[&apos;tokyle.com&apos;] = &#123;&#125;cf[&apos;tokyle.com&apos;][&apos;Author&apos;] = &apos;kyle&apos;cf[&apos;baidu.com&apos;] = &#123;&#125;baiduSearch = cf[&apos;baidu.com&apos;]baiduSearch[&apos;searchBox&apos;] = &apos;id &gt; kw&apos;baiduSearch[&apos;searchButton&apos;] = &apos;id &gt; su&apos;cf[&apos;DEFAULT&apos;][&apos;noRetry&apos;] = &apos;yes&apos;with open(&apos;test.ini&apos;, &apos;w&apos;) as configfile: cf.write(configfile) 上述代码执行完成之后会在该.py文件所在目录下创建一个test.ini的配置文件，内容如下：123456789101112[DEFAULT]browser = Chromeversion = 63.0.3239.132driver = chromedriver.exenoretry = yes[tokyle.com]author = kyle[baidu.com]searchbox = id &gt; kwsearchbutton = id &gt; su 每个ini文件可以包含一个[&#39;DEFAULT&#39;] section，也可以没有，[&#39;DEFAULT&#39;]部分定义了默认设置，例如默认使用的浏览器，浏览器版本等。 读取配置信息1234import configparsercf = configparser.ConfigParser()cf.read(&apos;test.ini&apos;) 获取所有sections使用1cf.sections() 即可，需要注意的是，这样，是默认不会获取都[‘DEFAULT’]的，可以实验一下：12section = cf.sections()print(section) 打印出的结果：1[&apos;tokyle.com&apos;, &apos;baidu.com&apos;] 可以看见默认不包含[‘DEFAULT’]。 其实读取配置信息就和读取字典里的数据做法一样，使用for循环就可以打印出全部信息，例如进行自动化测试时想获取[‘baidu.com’]里存的百度搜索输入框以及百度一下按键，可以：123baidu_msg = cf[&apos;baidu.com&apos;]for key,value in baidu_msg.items(): print(key + &apos; : &apos; + value) 打印出的信息：123456searchbox : id &gt; kwsearchbutton : id &gt; subrowser : Chromeversion : 63.0.3239.132driver : chromedriver.exenoretry : yes 可以看见，这样不仅会把[‘baidu.com’]模块的信息全部打印，[‘DEFAULT’]模块的信息也会被打印出来。 使用配置文件实例(简单的数据分离)：123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python3# -*- coding: utf-8 -*-import configparserimport traceback,timefrom selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom nose.tools import assert_trueclass ElementId(): def __init__(self): #读取配置文件 self.cf = configparser.ConfigParser() self.cf.read(&apos;test.ini&apos;) self.cf.sections() def get_elementId(self, driver, webSiteName, webelement): try: #获取配置文件中的定位方法以及定位元素 webElemnt = self.cf.get(webSiteName, webelement).split(&apos;&gt;&apos;) webelement_method = webElemnt[0].strip() webelement_expression = webElemnt[1].strip() element = WebDriverWait(driver, 10).until\ (lambda x: x.find_element(webelement_method, webelement_expression)) except Exception as e: print(traceback.print_exc(), e) else: return elementif __name__ == &apos;__main__&apos;: &quot;&quot;&quot;测试百度搜索&quot;&quot;&quot; #打开百度首页 browser = webdriver.Chrome() browser.get(&quot;https://www.baidu.com&quot;) #获取定位元素 elementid = ElementId() searchBox = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbox&apos;) searchBox.send_keys(&apos;selenium&apos;) searchButton = elementid.get_elementId(browser, &apos;baidu.com&apos;, &apos;searchbutton&apos;) searchButton.click() time.sleep(3) #断言完成百度搜索&quot;selenium&quot; assert_true(u&quot;Selenium - Web Browser Automation&quot; in browser.page_source) browser.quit() （我在执行上述示例之前，把test.ini中的[‘DEFAULT’]注释掉了，此例不需要[‘DEFAULT’]中的信息）]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自娱自乐一]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%87%AA%E5%A8%B1%E8%87%AA%E4%B9%90%E4%B8%80%2F</url>
    <content type="text"><![CDATA[自娱自乐系列一： 为了过年提前回家，周六过来加班调休，又不大想干活，就想着捣鼓点自娱自乐的东西： 输入年龄判断是否有投票资格：1234567891011121314151617def judge_age(): while True: try: age = int(input(&quot;\nPlease enter your age：&quot;)) except ValueError: print(&quot;Sorry,I can&apos;t understand what you entered.Please enter a correct number.&quot;) continue else: break if age &gt;= 18: print(&quot;You are able to vote in the United States!&quot;) else: print(&quot;You are too young to vote in the United States!&quot;)if __name__ == &apos;__main__&apos;: judge_age() 判断输入的正整数:12345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-def get_non_negative_int(prompt): try: value = int(input(prompt)) except ValueError: print(&quot;Sorry,I can&apos;t understand that.&quot;) return get_non_negative_int(prompt) if value &lt; 0: print(&quot;Sorry,your response must not be negative.&quot;) return get_non_negative_int(prompt) else: return valuedef guess_number(): number = get_non_negative_int(&quot;Please enter a number to guess: (only positive integer can work,thanks!)&quot;) while True: guess = get_non_negative_int(&quot;guess the number.&quot;) if guess &gt; number: print(&quot;You could enter a lower one.&quot;) elif guess &lt; number: print(&quot;I think it could be higher.&quot;) else: print(&quot;Congratulations! You got it!&quot;) breakif __name__ == &apos;__main__&apos;: guess_number() 纯属自娱自乐，毫无技术含量 Thanks?(?ω?)? 顺便贴个常识坑：文件夹不能取名是code，否则pycharm的debug模式会报错！！！（stackoverflow真是个好网站！什么坑都能找到填的办法。。）原因：debug模式会引个包：1from code import InteractiveConsole 工程中有code文件夹，会找不到debug需要的方法]]></content>
      <categories>
        <category>just for fun</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>lives</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium应用简介]]></title>
    <url>%2F2018%2F01%2F19%2Fappium%E5%BA%94%E7%94%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[appium应用篇，简单介绍自己工作中用到的一些appium应用。 Appium等待类型固定时间等待123import timetime.sleep(3) 固定等待时间3秒，强制等待，必须等完3秒之后才会进行下一步操作。 隐式等待1driver.implicitly_wait(5) 隐式等待的好处是不用想固定时间（time.sleep()）一样死等固定时间，可以在一定程度上提高执行效率，但是这种等待方式也是需要等页面所有元素都加载完成才会去进行下一步操作，例如有的时候，页面你需要的元素已经加载完成，但是必须还是要等待个别资源加载完才会执行下一步，一定程度上来说还是效率降低。 显示等待1234from selenium.webdriver.support.ui import WebDriverWaitWebDriverWait(driver, 10).\ until(lambda x:x.find_element_by_id(&apos;com.anmav.cashierdesk:id/tvOpenTable&apos;)) 显示等待原理是每隔一段时间（默认0.5秒），执行一次判断条件，如果条件成立，就执行下一步，直到超过设定的最大等待时间，抛出TimeoutException异常 Appium定位弹窗切换webview原理和selenium一样，类似于selenium中先获取页面句柄，再切换。1234driver.contexts方法一：driver.switch_to.context(&quot;contextname&quot;) #contextname为想切换到的上下文方法二：driver.switch_to.context(contexts[1]) # 从contexts里取第二个参数]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python项目依赖管理工具-pipenv]]></title>
    <url>%2F2018%2F01%2F18%2Fpython%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pipenv%2F</url>
    <content type="text"><![CDATA[偶然发现一个很好用的python项目包管理工具pipenv github上简介是一句话Pipenv: Python Development Workflow for Humans 现在已经是python.org官方推荐的工具。 具体功能：pipenv能够自动创建和管理你工程的虚拟环境，当你安装/卸载包时，会自动从你的Pipfile中添加/移除包；为啥要用这个工具，python的特点，python进行工程环境创建，一般是创建一个Virtualenv虚拟环境，然后列出所需要的工具包，pip安装，但是这样你就要手动去添加你需要的包，删除你已经不需要的包，并且由于工具包的更新，你可能还需要手动去更新你的工具包，而且，类似于单元测试这样的场景，需要安装nose包，但是生产环境又不需要该包，也就无法做到生产环境和开发环境安装包的分离，而以上这些，pipenv都可以解决。 使用简介首先安装pipenv使用pip安装pipenv及其依赖项1pip install pipenv macOS安装则使用1brew install pipenv 进入你项目所在文件夹，启动Pipenv12cd your_projectpipenv install 启动之后，项目文件夹下会多出两个文件Pipfile，Pipfile.lockPipfile文件包含项目的依赖包信息。 管理依赖包要为项目安装依赖包，跟pip类似1pipenv install nose 卸载1pipenv uninstall nose 可以通过更新Pipfile.lock来冻结软件包名称及其版本以及其自己的依赖关系的列表。 这是使用lock关键字完成:1pipenv lock 如果你同事或者朋友想clone你的依赖库，直接拿你的Pipfile，然后他本地安装pipenv之后，pipenv install即可完成依赖库安装 环境分离只为开发环境安装包：1pipenv install --dev nose 这样，在生产环境执行pipenv install是不会安装nose的，想要安装开发环境的依赖，执行：1pipenv install --dev 用法pipenv所有关键字及解释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ pipenvUsage: pipenv [OPTIONS] COMMAND [ARGS]...Options: --update Update Pipenv &amp; pip to latest. --where Output project home information. --venv Output virtualenv information. --py Output Python interpreter information. --envs Output Environment Variable options. --rm Remove the virtualenv. --bare Minimal output. --completion Output completion (to be eval&apos;d). --man Display manpage. --three / --two Use Python 3/2 when creating virtualenv. --python TEXT Specify which version of Python virtualenv should use. --site-packages Enable site-packages for the virtualenv. --jumbotron An easter egg, effectively. --version Show the version and exit. -h, --help Show this message and exit.Usage Examples: Create a new project using Python 3.6, specifically: $ pipenv --python 3.6 Install all dependencies for a project (including dev): $ pipenv install --dev Create a lockfile containing pre-releases: $ pipenv lock --pre Show a graph of your installed dependencies: $ pipenv graph Check your installed dependencies for security vulnerabilities: $ pipenv check Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e .Commands: check Checks for security vulnerabilities and... graph Displays currently–installed dependency graph... install Installs provided packages and adds them to... lock Generates Pipfile.lock. open View a given module in your editor. run Spawns a command installed into the... shell Spawns a shell within the virtualenv. uninstall Un-installs a provided package and removes it... update Uninstalls all packages, and re-installs... 定位工程展示工程路径以及环境路径，进入工程(类似于linux)：1pipenv --where 1pipenv --venv 定位python解释器：1pipenv --py 其他使用激活工程环境1pipenv shell 运行python脚本1pipenv run python main.py 展示依赖关系图1pipenv graph 卸载所有1pipenv uninstall --all 参考地址 github项目地址python.org官网推荐地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder简介]]></title>
    <url>%2F2018%2F01%2F18%2Fcmder%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[windows小工具介绍 windows系统cmd工具，说实话，用的还是有点不舒服的，用习惯vim之后，真的是很想在windows上用类似的，还好，找到个小工具cmder。 下载地址：照旧，官方下载地址是托管在github上 github下载地址 但是不知道最近抽什么疯，github上n多项目下载页面直接404，索性提供本地度娘盘地址： 度娘盘地址 使用说明下载完成之后，解压缩，然后将cmder.exe所在目录添加到系统环境变量中，完成~双击打开即可使用。 简单设置解决中文乱码问题：类似于linux，alias文件中添加设置即可；alias文件位置：cmder/config/aliases添加：123l=ls --show-control-charsla=ls -aF --show-control-charsll=ls -alF --show-control-chars 中文字重叠在一起cmder进入设置（快捷键win+alt+p），找到main，取消monospace(固定宽度)勾选 基本就是设置完成了，可以进行使用了，后续再发现什么其他的好功能再更新。123456789#切换盘D:#展示文件lsll#查看文件内容cat xxx.txt#编辑文件内容vim xxx.txt]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium键盘事件]]></title>
    <url>%2F2018%2F01%2F17%2Fappium%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[appium键盘事件 语法：1driver.keyevent(keyCode) 电话键1234567891011121314KEYCODE_CALL 拨号键 5KEYCODE_ENDCALL 挂机键 6KEYCODE_HOME 按键Home 3KEYCODE_MENU 菜单键 82KEYCODE_BACK 返回键 4KEYCODE_SEARCH 搜索键 84KEYCODE_CAMERA 拍照键 27KEYCODE_FOCUS 拍照对焦键 80KEYCODE_POWER 电源键 26KEYCODE_NOTIFICATION 通知键 83KEYCODE_MUTE 话筒静音键 91KEYCODE_VOLUME_MUTE 扬声器静音键 164KEYCODE_VOLUME_UP 音量增加键 24KEYCODE_VOLUME_DOWN 音量减小键 25 控制键123456789101112131415161718192021KEYCODE_ENTER 回车键 66KEYCODE_ESCAPE ESC键 111KEYCODE_DPAD_CENTER 导航键 确定键 23KEYCODE_DPAD_UP 导航键 向上 19KEYCODE_DPAD_DOWN 导航键 向下 20KEYCODE_DPAD_LEFT 导航键 向左 21KEYCODE_DPAD_RIGHT 导航键 向右 22KEYCODE_MOVE_HOME 光标移动到开始键 122KEYCODE_MOVE_END 光标移动到末尾键 123KEYCODE_PAGE_UP 向上翻页键 92KEYCODE_PAGE_DOWN 向下翻页键 93KEYCODE_DEL 退格键 67KEYCODE_FORWARD_DEL 删除键 112KEYCODE_INSERT 插入键 124KEYCODE_TAB Tab键 61KEYCODE_NUM_LOCK 小键盘锁 143KEYCODE_CAPS_LOCK 大写锁定键 115KEYCODE_BREAK Break/Pause键 121KEYCODE_SCROLL_LOCK 滚动锁定键 116KEYCODE_ZOOM_IN 放大键 168KEYCODE_ZOOM_OUT 缩小键 169 组合键123456KEYCODE_ALT_LEFT Alt+LeftKEYCODE_ALT_RIGHT Alt+RightKEYCODE_CTRL_LEFT Control+LeftKEYCODE_CTRL_RIGHT Control+RightKEYCODE_SHIFT_LEFT Shift+LeftKEYCODE_SHIFT_RIGHT Shift+Right 基本123456789101112131415161718192021222324252627282930313233343536KEYCODE_0 按键&apos;0&apos; 7KEYCODE_1 按键&apos;1&apos; 8KEYCODE_2 按键&apos;2&apos; 9KEYCODE_3 按键&apos;3&apos; 10KEYCODE_4 按键&apos;4&apos; 11KEYCODE_5 按键&apos;5&apos; 12KEYCODE_6 按键&apos;6&apos; 13KEYCODE_7 按键&apos;7&apos; 14KEYCODE_8 按键&apos;8&apos; 15KEYCODE_9 按键&apos;9&apos; 16KEYCODE_A 按键&apos;A&apos; 29KEYCODE_B 按键&apos;B&apos; 30KEYCODE_C 按键&apos;C&apos; 31KEYCODE_D 按键&apos;D&apos; 32KEYCODE_E 按键&apos;E&apos; 33KEYCODE_F 按键&apos;F&apos; 34KEYCODE_G 按键&apos;G&apos; 35KEYCODE_H 按键&apos;H&apos; 36KEYCODE_I 按键&apos;I&apos; 37KEYCODE_J 按键&apos;J&apos; 38KEYCODE_K 按键&apos;K&apos; 39KEYCODE_L 按键&apos;L&apos; 40KEYCODE_M 按键&apos;M&apos; 41KEYCODE_N 按键&apos;N&apos; 42KEYCODE_O 按键&apos;O&apos; 43KEYCODE_P 按键&apos;P&apos; 44KEYCODE_Q 按键&apos;Q&apos; 45KEYCODE_R 按键&apos;R&apos; 46KEYCODE_S 按键&apos;S&apos; 47KEYCODE_T 按键&apos;T&apos; 48KEYCODE_U 按键&apos;U&apos; 49KEYCODE_V 按键&apos;V&apos; 50KEYCODE_W 按键&apos;W&apos; 51KEYCODE_X 按键&apos;X&apos; 52KEYCODE_Y 按键&apos;Y&apos; 53KEYCODE_Z 按键&apos;Z&apos; 54]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium定位]]></title>
    <url>%2F2018%2F01%2F17%2Fappium%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[appium的常用操作以及元素定位的简单介绍 appium常用操作锁屏1driver.lock(5) 切换应用至后台123driver.background_app(5) # 置于后台，持续5秒driver.background_app(-1) # 持续置于后台driver.background_app(&#123;&apos;timeout&apos;: None&#125;) # 持续置于后台 收起键盘1driver.hide_keyboard() 启动Activity1driver.start_activity(&apos;com.example.android.apis&apos;, &apos;.Foo&apos;) 检测应用是否被安装1driver.is_app_installed(&apos;com.example.android.apis&apos;) 安装应用1driver.install_app(&apos;path/to/my.apk&apos;) 卸载应用1driver.remove_app(&apos;com.example.android.apis&apos;) 模拟设备摇一摇1driver.shake() 关闭应用1driver.close_app() 启动应用使用前提是desired capabilities设置了 autoLaunch=false 关键字1driver.launch_app() 操作上下文（Contexts）获取所有1driver.contexts 获取当前1driver.current_context 切换至默认1driver.switch_to.context(None) 按键事件1driver.keyevent(176) 具体键值 点击操作/多点触控操作12action = TouchAction(driver)action.press(element=el, x=10, y=10).release().perform() 滑动屏幕1driver.swipe(start_x=75, start_y=500, end_x=75, end_y=0, duration=800) 从设备拉去文件1driver.pull_file(&apos;Library/AddressBook/AddressBook.sqlitedb&apos;) 推送文件到设备123data = &quot;some data for the file&quot;path = &quot;/data/local/tmp/file.txt&quot;driver.push_file(path, data.encode(&apos;base64&apos;)) appium元素定位使用id，class等和selenium基本没差别的定位就不介绍了，主要介绍appium独有uiautomator UiSelector 页面class和id等都不能唯一确定元素，但是元素有text属性时，可以使用以下进行定位：1234driver.find_element_by_android_uiautomator(&apos;new UiSelector().text(&quot;Custom View&quot;)&apos;).click() #textdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textContains(&quot;View&quot;)&apos;).click() #textContainsdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textStartsWith(&quot;Custom&quot;)&apos;).click() #textStartsWithdriver.find_element_by_android_uiautomator(&apos;new UiSelector().textMatches(&quot;^Custom.*&quot;)&apos;).click() #textMatches 也可以加上class属性：12driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.TextView&quot;).text(&quot;Custom View&quot;)&apos;).click() #classNamedriver.find_element_by_android_uiautomator(&apos;new UiSelector().classNameMatches(&quot;.*TextView$&quot;).text(&quot;Custom View&quot;)&apos;).click() #classNameMatches 多条件精准定位1driver.find_element_by_android_uiautomator(&apos;new UiSelector().className(&quot;android.widget.EditText&quot;).resourceId(&quot;com.anmav.cashierdesk:id/etToPayPrice&quot;)&apos;) 操作坐标appium在进行元素定位时，定位不到唯一标志的元素，可以获取元素的坐标，使用坐标进行操作 appium以及uiautomatorviewer都可以很容易获取到坐标 appium操作坐标 1driver.tap([(100, 20), (100, 60), (100, 100)], 500) 三个坐标表示模拟三根手指，只需要一个手指，改成一个坐标即可，500表示持续时间500ms 或者使用adb命令也可实现同样效果：1os.popen(&quot;adb shell input tap &quot; + str(100) + &quot; &quot; + str(20)) 参考文章 appium 基础之键盘处理appium-bindings]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app安装卸载]]></title>
    <url>%2F2018%2F01%2F17%2Fapp%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[appium-模拟器安装卸载app 模拟器安装apk1adb install XXX.apk 卸载apk1adb uninstall your_package 例子： 启动android模拟器，参数：12345desired_caps[&apos;platformName&apos;] = &apos;Android&apos;desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;desired_caps[&apos;appPackage&apos;] = &apos;com.anmav.cashierdesk&apos;desired_caps[&apos;appActivity&apos;] = &apos;com.anmav.cashierdesk.view.LoginActivity&apos; win10打开控制台，进入apk文件所在目录，执行命令1adb install cashierdesk.apk 在模拟器中可以发现该app已完成安装。 控制台执行命令：1adb uninstall com.anmav.cashierdesk 模拟器中可以看见该app完成卸载]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appium入门篇]]></title>
    <url>%2F2018%2F01%2F16%2Fappium%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[appium环境搭建及简单使用 测试人员进行app自动化测试的可选框架之一—— appium 平台说明：12WIN10_64python 3.6 appium环境安装安装Android Studio网上之前的教程基本都是安装SDK或者ADT来进行安装，开始我也是这么装的，在最后创建完虚拟机，开启虚拟机时候报错了，报错信息只记得是建议安装Android Studio，索性也就换成了Android Studio。 Android Studio下载链接 如果下载的是不包含SDK的版本，还需要另外下载SDK。安装Android Studio很简单，和Pycharm一模一样，有使用Pycharm经验或者IntelliJ IDEA的应该很熟悉，安装完成之后，找到SDK Manager1File-Settings-Appearance&amp;Behavior &gt; System Settings &gt; Android SDK 如果本地有SDK，可以在此选择本地的SDK路径，该设置页也支持下载各种SDK Platforms。对应的SDK安装完成之后就可以进行创建虚拟机，找到AVD Manager按键，点击创建。 安装Android SDK（和安装Android Studio任选一种方式即可）官方下载地址 但是由于国内众所周知的某种原因，不能科学上网貌似无法保证可以下载~ 国内优质android工具网站 搜索android-sdk找到对应系统版本，进行下载。 配置android环境变量与配置JAVA环境变量类似，新增系统变量123456变量名：ANDROID_HOME 变量值：D:\android\android-sdk-windows变量名：PATH变量值：;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; SDK Manager安装模拟器在你本地解压完成之后的android-sdk-windows目录下找到SDK Manager.exe，双击打开； 配置参考 安装SDK Platform-Tools在AndroidDevTools.cn 网站上找到Android SDK Platform-tools下载链接，下载，解压，把解压出来的 platform-tools 文件夹放在android-sdk-windows目录下 安装Appium安装方式一： 使用NodeJS 安装1，首先到官网下载安装最新的NodeJS，Windows下属于傻瓜安装。安装完成验证npm或者node -v不报错表明安装完成 2，安装appium，npm install -g appium命令安装appium（个人实验的效果不好，太慢了，建议采用第二种，安装包安装） 安装方式二：安装包安装建议直接安装appium-desktop，appium server在2015年就不再更新，取而代之的是appium-desktop的出现。 Appium安装包托管在github上，下载地址 但是个人实验，很多版本都是跳转404页面。。。无语。。。 个人网盘地址，密码：v3lt（版本1.2.7） 下载完成后，安装即可。 appium环境检查可以使用appium-doctor工具进行环境检查，npm install -g appium-doctor进行安装。 Appium-desktop使用简介打开appium-desktop，点击“放大镜”图标进行设置， 设置完成后点击 Start Session 直接单击最左栏的元素，在中间和右边会显示该元素属性，找到对应的ID值等，定位方式和selenium类似。 查找appPackage和appActivityappium进行自动化测试，需要appPackage和appActivity两个参数，下面是从apk文件获取的方法： apk反编译apktool 地址： apktool 用法1java -jar apktool.jar d yourApkFile.apk 获取appPackage和appActivity打开apk反编译之后的文件夹，打开AndroidManifest.xml文件 package获取 appPackage，activity获取appActivity。 appium Demo实现计算器计算，代码：1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding: utf-8 -*-from appium import webdriverimport timedesired_caps = &#123;&#125;desired_caps[&apos;platformName&apos;] = &apos;Android&apos;desired_caps[&apos;platformVersion&apos;] = &apos;7.1.1&apos;desired_caps[&apos;deviceName&apos;] = &apos;Android Emulator&apos;desired_caps[&apos;appPackage&apos;] = &apos;com.android.calculator2&apos;desired_caps[&apos;appActivity&apos;] = &apos;.Calculator&apos;desired_caps[&apos;noReset&apos;] = Truedriver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;, desired_caps)driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()driver.find_element_by_accessibility_id(&apos;multiply&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_9&apos;).click()driver.find_element_by_accessibility_id(&apos;plus&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_1&apos;).click()driver.find_element_by_id(&apos;com.android.calculator2:id/digit_4&apos;).click()driver.find_element_by_accessibility_id(&apos;equals&apos;).click()time.sleep(3)driver.quit()]]></content>
      <categories>
        <category>appium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>自动化测试</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[smtp发邮件]]></title>
    <url>%2F2018%2F01%2F12%2Fsmtp%E5%8F%91%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用python3发送网易邮箱邮件 代码：12345678910111213141516import smtplibfrom email.mime.text import MIMETextfrom email.header import Headerdef send_email(mail_host, from_account, from_passwd, to_account, subject, content): mail = smtplib.SMTP() mail.connect(mail_host) mail.login(from_account, from_passwd) # 发送邮件 message = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;) message[&apos;From&apos;] = from_account message[&apos;To&apos;] = to_account message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) mail.sendmail(from_account, to_account, message.as_string()) 菜鸟教程上有一种写法12345678910111213141516171819202122232425262728293031#!/usr/bin/python3 import smtplibfrom email.mime.text import MIMETextfrom email.header import Header # 第三方 SMTP 服务mail_host=&quot;smtp.XXX.com&quot; #设置服务器mail_user=&quot;XXXX&quot; #用户名mail_pass=&quot;XXXXXX&quot; #口令 sender = &apos;from@runoob.com&apos;receivers = [&apos;429240967@qq.com&apos;] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)message[&apos;To&apos;] = Header(&quot;测试&quot;, &apos;utf-8&apos;) subject = &apos;Python SMTP 邮件测试&apos;message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;) try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print (&quot;邮件发送成功&quot;)except smtplib.SMTPException: print (&quot;Error: 无法发送邮件&quot;) 这样执行，会报错smtplib.SMTPDataError: (554, &#39;DT:SPM 126 smtp5,jtKowAD3MJz2c1JXLcK2AA--.52114S2 1465021431,please see http://mail.163.com/help/help_spam_16.htm?ip=123.114.121.110&amp;hostid=smtp5&amp;time=1465021431&#39;) 解决办法就是指定收发件人12message[&apos;From&apos;] = from_accountmessage[&apos;To&apos;] = to_account p.s 网易邮箱客户端默认授权码是关闭的，直接执行python调用会失败，要先进客户端，把客户授权码打开位置：设置-客户端授权密码设置完成之后，登录密码就使用你设置的授权码]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>smtplib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium无干预下载]]></title>
    <url>%2F2018%2F01%2F10%2Fselenium%E6%97%A0%E5%B9%B2%E9%A2%84%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[selenium自带了无人工干预实现下载功能的模块，下载时不需要弹窗点击确定下载 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverimport timeclass MacDownload(): def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; # 创建一个FirefoxProfile实例，用于存放自定义配置 profile = webdriver.FirefoxProfile() # 指定下载路径，默认自动创建一级目录 profile.set_preference(&apos;browser.download.dir&apos;, &apos;G:\idownload&apos;) # 将browser.download.folderLis设置为2，表示将文件下载到指定目录（0表示桌面，1表示默认路径） profile.set_preference(&quot;browser.download.folderList&quot;, 2) # browser.helperApps.alwaysAsk.force对于未知的MIME类型文件会弹出窗口 # 让用户处理，默认值为True，设定为False表示不会记录打开未知MIME类型文件的方式 profile.set_preference(&quot;browser.helperApps.alwaysAsk.force&quot;, False) # 在开始下载时是否显示下载管理器 profile.set_preference(&quot;browser.download.manager.showWhenStarting&quot;, False) # 设定为False会把下载狂隐藏 profile.set_preference(&quot;browser.download.manager.useWindow&quot;, False) # 默认为True，设定为False表示不获取焦点 profile.set_preference(&quot;browser.download.manager.focusWhenStarting&quot;, False) # 下载.exe文件弹出警告，默认值为True，设定为False则不会弹出警告 profile.set_preference(&quot;browser.download.manager.alertOnEXEOpen&quot;, False) # browser.helperApps.neverAsk.openFile表示直接打开下载文件，不显示确定框 # 默认值为空字符串，下行代码行设定了多种文件的MIME类型， # 例如application/exe,表示 .exe类型的文件；application/excel表示excel类型的文件 profile.set_preference(&quot;browser.helperApps.neverAsk.openFile&quot;, &quot;application/pdf&quot;) # 对所给出文件类型不在弹出提示框进行询问，直接保存到本地磁盘 profile.set_preference(&quot;browser.helperApps.neverAsk.saveToDisk&quot;, &quot;application/zip, application/octet-stream&quot;) # browser.download.manager.showAlertOnComplete设定下载文件结束后是否显示下载完成提示框 # 默认为True，设定为False表示下载完成后不显示下载完成提示框 profile.set_preference(&quot;browser.download.manager.showAlertOnComplete&quot;, False) # browser.download.manager.closeWhenDone设定下载结束后是都自动关闭下载框 # 默认为True，设定为False表示不关闭下载管理器 profile.set_preference(&quot;browser.download.manager.closeWhenDone&quot;, False) # 启动浏览器，通过firfox_profile参数将自动配置添加到FirefoxProfile对象中sef.driver = webdriver.Firefox(firefox_profile=profile) self.driver = webdriver.Firefox(firefox_profile=profile) def test_dataPicker(self): #访问WebDriver驱动firefox的驱动文件下载网址 # url1 = &quot;https://github.com/mozilla/geckodriver/releases&quot; # self.driver.get(url1) # #选择下载ZIP类型的文件，使用application/zip指代此类型文件 # self.driver.find_element_by_xpath(&apos;//strong[. = &quot;geckodriver-v0.19.1-win32.zip&quot;]&apos;).click() # time.sleep(10) #访问Python2.7.12文件下载页面，下载扩展名为msi的文件 #使用application/octet - stream来指明次文件类型 url = &quot;https://www.python.org/downloads/release/python-2712/&quot; self.driver.get(url) self.driver.find_element_by_link_text(&apos;Windows x86-64 MSI installer&apos;).click() time.sleep(100) self.driver.quit()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306余票监控]]></title>
    <url>%2F2018%2F01%2F10%2F12306%E4%BD%99%E7%A5%A8%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[翻日历突然意识到，好像要放假了，又是一年春运时，就想着可不可以用selenium做个自己的监控12306余票的程序。 动手：思路也就是输入起点，终点，选择列车，选择座位，查询是否有余票。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timeclass monitorTickets(): &quot;&quot;&quot; 查询12306硬座，硬卧，软卧余票 &quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;初始化&quot;&quot;&quot; #使用chrome浏览器打开查询12306查询页面 self.browser = webdriver.Chrome() url = &apos;https://kyfw.12306.cn/otn/leftTicket/init&apos; self.browser.get(url) def search_tickets(self,train_name, start_stations, end_stations, ticket_id): &quot;&quot;&quot;循环获取余票&quot;&quot;&quot; print(&quot;开始查询【%s】次列车余票信息&quot; % train_name) for start_station in start_stations: try: for end_station in end_stations: #输入起点 starts = self.browser.find_element_by_id(&quot;fromStationText&quot;) starts.click() starts.clear() starts.send_keys(start_station) starts.send_keys(Keys.ENTER) #输入到站 ends = self.browser.find_element_by_id(&quot;toStationText&quot;) ends.click() ends.clear() ends.send_keys(end_station) ends.send_keys(Keys.ENTER) #选择时间 #使用js将只读属性去除，完成选择时间 js = &apos;document.getElementById(&quot;train_date&quot;).removeAttribute(&quot;readonly&quot;);&apos; self.browser.execute_script(js) date = self.browser.find_element_by_id(&apos;train_date&apos;) date.clear() date.send_keys(&apos;2018-02-10&apos;) date.click() self.browser.find_element_by_id(&quot;query_ticket&quot;).click() time.sleep(2) text = self.browser.find_element_by_id(ticket_id).text if text == u&quot;无&quot;: print(u&quot;【%s】到【%s】的余票为0，节哀～&quot; % (start_station, end_station)) time.sleep(1) elif text == u&quot;*&quot;: print(u&quot;【%s】到【%s】的车票还未开售，请耐心等待～&quot; % (start_station, end_station)) time.sleep(1) else: print(u&quot;发现【%s】到【%s】的余票，抢!&quot; % (start_station, end_station)) except: continue print(&quot;结束查询【%s】次列车余票信息&quot; % train_name) def close_browser(self): &quot;&quot;&quot;关浏览器&quot;&quot;&quot; time.sleep(3) self.browser.quit()if __name__ == &apos;__main__&apos;: #查票 time.sleep(1) search_ticket = monitorTickets() while True: print(&quot;监控硬座&quot;) search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YZ_550000T11671&apos;) search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;YZ_550000Z21605&apos;) search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YZ_560000T11251&apos;) search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YZ_550000T20450&apos;) search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YZ_5500000Z4061&apos;) print(&quot;监控硬座结束&quot;) # print(&quot;监控硬卧&quot;) # search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YW_550000T11671&apos;) # search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;YW_550000Z21605&apos;) # search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;YW_560000T11251&apos;) # search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YW_550000T20450&apos;) # search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;YW_5500000Z4061&apos;) # print(&quot;监控硬卧结束&quot;) # # print(&quot;监控软卧&quot;) # search_ticket.search_tickets(&apos;T116&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;RW_550000T11671&apos;) # search_ticket.search_tickets(&apos;Z216&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;甘谷&apos;], &apos;RW_550000Z21605&apos;) # search_ticket.search_tickets(&apos;T112&apos;, [&apos;嘉兴&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;陇西&apos;], &apos;RW_560000T11251&apos;) # search_ticket.search_tickets(&apos;T204&apos;, [&apos;上海&apos;, &apos;昆山&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;RW_550000T20450&apos;) # search_ticket.search_tickets(&apos;Z40&apos;, [&apos;上海&apos;, &apos;苏州&apos;], [&apos;宝鸡&apos;, &apos;天水&apos;, &apos;兰州&apos;], &apos;RW_5500000Z4061&apos;) # print(&quot;监控软卧结束&quot;) # msg = input(&quot;Enter &apos;q&apos; to quit&quot;) # if msg == &apos;q&apos;: # break # search_ticket.close_browser()]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录网易邮箱]]></title>
    <url>%2F2018%2F01%2F05%2F%E7%99%BB%E5%BD%95%E7%BD%91%E6%98%93%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[基于python3的自动化测试框架selenium3实践 登录网易邮箱（126,163） 登录163123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timebrowser = webdriver.Chrome()browser.get(&apos;http://mail.163.com/&apos;)browser.maximize_window()#切换进iframebrowser.implicitly_wait(5)browser.switch_to.frame(&apos;x-URS-iframe&apos;)time.sleep(1)#定位账号username = browser.find_element_by_name(&apos;email&apos;)username.clear()username.send_keys(&apos;***&apos;)time.sleep(1)#定位密码pwd = browser.find_element_by_name(&apos;password&apos;)pwd.clear()pwd.send_keys(&apos;***&apos;)#登录pwd.send_keys(Keys.ENTER)time.sleep(3)browser.quit() 或者123456789101112131415#coding:utf-8from selenium import webdriverfrom selenium.webdriver.common.keys import Keysimport timedriver = webdriver.Firefox()driver.get(&apos;http://mail.163.com/&apos;)driver.implicitly_wait(10)#切换iframeiframe = driver.find_elements_by_tag_name(&apos;iframe&apos;)driver.switch_to_frame(iframe)#driver.switch_to.frame(&apos;x-URS-iframe&apos;)driver.find_element_by_name(&apos;email&apos;).send_keys(&apos;123&apos;)driver.find_element_by_name(&apos;password&apos;).send_keys(&apos;456&apos;)brower.find_element_by_name(&quot;password&quot;).send_keys(Keys.ENTER) 登录12612345678910111213141516171819202122232425262728293031#!/usr/bin/env python3# -*- coding: utf-8 -*-import timefrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysbrowser = webdriver.Chrome()browser.get(&apos;http://mail.126.com/&apos;)browser.maximize_window()# 切换iframebrowser.implicitly_wait(5)browser.switch_to.frame(&apos;x-URS-iframe&apos;)time.sleep(1)# 定位用户名username = browser.find_element_by_name(&apos;email&apos;)username.clear()username.send_keys(&apos;***&apos;)time.sleep(1)#定位密码pwd = browser.find_element_by_name(&apos;password&apos;)pwd.clear()pwd.send_keys(&apos;***&apos;)#登录pwd.send_keys(Keys.ENTER)time.sleep(3)browser.quit() ~记小白入坑selenium]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nose跳过测试]]></title>
    <url>%2F2018%2F01%2F04%2Fnose%E8%B7%B3%E8%BF%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[nose进行单元测试，和unittest一样，有跳过某个方法，指定特定类进行测试的功能。 识别规则使用nose进行单元测试，测试用例识别规则如下：12345nosetests only_test_this.pynosetests test.modulenosetests another.test:TestCase.test_methodnosetests a.test:TestCasenosetests /path/to/test/file.py:test.function 示例执行全部测试直接代码示例：12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-import tracebackfrom nose.tools import eq_from nose.plugins.attrib import attrfrom nose.plugins.skip import SkipTestfrom functools import reduceclass test_nosetests(): #测试加法 def test_sum(self): a = 1 b = 2 res = 3 eq_(a+b,res) #测试乘法 def test_mul(self): a = 1 b = 2 res = 2 eq_(a*b, res) #测试除法 def test_div(self): a = 2 b = 0 res = 1 try: eq_(a/b, res) except ZeroDivisionError as e: print(traceback.print_exc()) #测试reduce函数 def test_reduce(self): req = range(1,6) a = 120 res = reduce(lambda x, y: x*y, req) eq_(a, res) 想要对test_nosetests该方法进行测试，可以： 121. nosetests -v NoseTestsexercise.py --with-html --html-file=G:/workstation/report/test_nosetests.html2. nosetests -v NoseTestsexercise.py:test_nosetests --with-html --html-file=G:/workstation/report/test_nosetests.html 由于该python文件只有这一个测试类，所以直接nosetests该python文件即可以进行测试，或者是指定该python文件的测试类如NoseTestsexercise.py:test_nosetests方式 测试结果： 执行指定方法的测试执行指定的一个方法：1nosetests -v NoseTestsexercise.py:test_nosetests.test_reduce --with-html --html-file=G:/workstation/report/test_nosetests.html 示例执行了test_nosetests类下的test_reduce方法的测试 测试结果： 跳过指定方法的测试有的时候，只需要跳过某个方法：例如想跳过test_mul该方法，只需要在代码上增加跳过标志即可1234567#测试乘法 def test_mul(self): a = 1 b = 2 res = 2 eq_(a*b, res) raise SkipTest 执行：1nosetests -v NoseTestsexercise.py:test_nosetests --with-html --html-file=G:/workstation/report/test_nosetests.html 测试结果： 其他另外，nosetests也有用例执行优先级的功能1234from nose.plugins.attrib import attr @attr(speed=&apos;slow&apos;) def test_big_download(self): print(&apos;pass&apos;) 执行只需要：nosetests -a speed=slow即可 参考用法]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python单元测试框架-nose]]></title>
    <url>%2F2018%2F01%2F03%2Fpython%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6-nose%2F</url>
    <content type="text"><![CDATA[python单元测试框架 nose简介 简介nose是python单元测试的另一框架，nose可以自动识别继承于unittest.TestCase的测试单元，并执行测试，而且，nose也可以测试非继承于unittest.TestCase的测试单元。nose提供了丰富的API便于编写测试代码。 安装及使用安装：1pip install nose 基本语法：1nosetests [options] [(optional) test files or directories] 扩展使用nose自动收集单元测试，收集它当前工作目录下的源代码文件、目录以及包。任何的源代码文件、目录或者包只要匹配正则表达式，他们就会被自动收集。包的测试收集按照树的层级级别一级一级进行，因此package.tests、package.sub.tests、package.sub.sub2.tests将会被收集。 扩展插件nose支持多种插件，可完成基本大部分测试需要。nose拥有很多内置的插件帮助进行输出抓取、错误查找、代码覆盖、文档测试（doctest）等等。 命令行执行命令可查看插件：1nosetests –plugins 若想查看详细信息，可执行12nosetests –plugins -vnosetests –plugins -vv nose使用nose使用和unittest类似，unittest的断言，nose.tools中都可以选择使用使用示例：unittest：123456789101112131415161718import unittestclass NoseTest(unittest.TestCase): def setUp(self): print(&quot;=============setUp===============&quot;) def test_Pass(self): print(&quot;==========begin test=========&quot;) a = 1 b = 2 self.assertTrue(a == b, &apos;断言失败, %a != %a&apos;% (a, b)) def tearDown(self): print(&quot;==============tearDown===============&quot;)if __name__ == &apos;__main__&apos;: unittest.main() nose:12345678from nose.tools import eq_from nose.tools import assert_equalclass noseTest(): a = 1 b = 2 #assert_equal(a, b, &apos;%a != %a&apos;%(a,b)) eq_(a, b) nose也支持在代码中直接运行nose.main()或者nose.run()这样类似于unittest的方式，但是还是建议在命令行中运行nosetests来执行单元测试参考示例：1nosetests -v HandleFrameByPageSource.py:test_handleFrameByPageSource --with-html --html-file=G:\workstation\report\handleframe.html 说明：1234nosetests -v: 显示详细的运行信息和调试信息HandleFrameByPageSource.py:test_handleFrameByPageSource ：测试对象为该python文件下的test_handleFrameByPageSource类--with-html ：使用html插件,生成标准HTML格式测试报告--html-file=G:\workstation\report\handleframe.html ：测试结果输出为该路径下handleframe.html文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>nose</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win32api_VK_CODE]]></title>
    <url>%2F2018%2F01%2F02%2Fwin32api-VK-CODE%2F</url>
    <content type="text"><![CDATA[python使用win32api模块，可模拟键盘按键，应用于爬虫及自动化测试。 键盘按键对应的Vitual keystroke如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535#Giant dictonary to hold key name and VK valueVK_CODE = &#123;&apos;backspace&apos;:0x08, &apos;tab&apos;:0x09, &apos;clear&apos;:0x0C, &apos;enter&apos;:0x0D, &apos;shift&apos;:0x10, &apos;ctrl&apos;:0x11, &apos;alt&apos;:0x12, &apos;pause&apos;:0x13, &apos;caps_lock&apos;:0x14, &apos;esc&apos;:0x1B, &apos;spacebar&apos;:0x20, &apos;page_up&apos;:0x21, &apos;page_down&apos;:0x22, &apos;end&apos;:0x23, &apos;home&apos;:0x24, &apos;left_arrow&apos;:0x25, &apos;up_arrow&apos;:0x26, &apos;right_arrow&apos;:0x27, &apos;down_arrow&apos;:0x28, &apos;select&apos;:0x29, &apos;print&apos;:0x2A, &apos;execute&apos;:0x2B, &apos;print_screen&apos;:0x2C, &apos;ins&apos;:0x2D, &apos;del&apos;:0x2E, &apos;help&apos;:0x2F, &apos;0&apos;:0x30, &apos;1&apos;:0x31, &apos;2&apos;:0x32, &apos;3&apos;:0x33, &apos;4&apos;:0x34, &apos;5&apos;:0x35, &apos;6&apos;:0x36, &apos;7&apos;:0x37, &apos;8&apos;:0x38, &apos;9&apos;:0x39, &apos;a&apos;:0x41, &apos;b&apos;:0x42, &apos;c&apos;:0x43, &apos;d&apos;:0x44, &apos;e&apos;:0x45, &apos;f&apos;:0x46, &apos;g&apos;:0x47, &apos;h&apos;:0x48, &apos;i&apos;:0x49, &apos;j&apos;:0x4A, &apos;k&apos;:0x4B, &apos;l&apos;:0x4C, &apos;m&apos;:0x4D, &apos;n&apos;:0x4E, &apos;o&apos;:0x4F, &apos;p&apos;:0x50, &apos;q&apos;:0x51, &apos;r&apos;:0x52, &apos;s&apos;:0x53, &apos;t&apos;:0x54, &apos;u&apos;:0x55, &apos;v&apos;:0x56, &apos;w&apos;:0x57, &apos;x&apos;:0x58, &apos;y&apos;:0x59, &apos;z&apos;:0x5A, &apos;numpad_0&apos;:0x60, &apos;numpad_1&apos;:0x61, &apos;numpad_2&apos;:0x62, &apos;numpad_3&apos;:0x63, &apos;numpad_4&apos;:0x64, &apos;numpad_5&apos;:0x65, &apos;numpad_6&apos;:0x66, &apos;numpad_7&apos;:0x67, &apos;numpad_8&apos;:0x68, &apos;numpad_9&apos;:0x69, &apos;multiply_key&apos;:0x6A, &apos;add_key&apos;:0x6B, &apos;separator_key&apos;:0x6C, &apos;subtract_key&apos;:0x6D, &apos;decimal_key&apos;:0x6E, &apos;divide_key&apos;:0x6F, &apos;F1&apos;:0x70, &apos;F2&apos;:0x71, &apos;F3&apos;:0x72, &apos;F4&apos;:0x73, &apos;F5&apos;:0x74, &apos;F6&apos;:0x75, &apos;F7&apos;:0x76, &apos;F8&apos;:0x77, &apos;F9&apos;:0x78, &apos;F10&apos;:0x79, &apos;F11&apos;:0x7A, &apos;F12&apos;:0x7B, &apos;F13&apos;:0x7C, &apos;F14&apos;:0x7D, &apos;F15&apos;:0x7E, &apos;F16&apos;:0x7F, &apos;F17&apos;:0x80, &apos;F18&apos;:0x81, &apos;F19&apos;:0x82, &apos;F20&apos;:0x83, &apos;F21&apos;:0x84, &apos;F22&apos;:0x85, &apos;F23&apos;:0x86, &apos;F24&apos;:0x87, &apos;num_lock&apos;:0x90, &apos;scroll_lock&apos;:0x91, &apos;left_shift&apos;:0xA0, &apos;right_shift &apos;:0xA1, &apos;left_control&apos;:0xA2, &apos;right_control&apos;:0xA3, &apos;left_menu&apos;:0xA4, &apos;right_menu&apos;:0xA5, &apos;browser_back&apos;:0xA6, &apos;browser_forward&apos;:0xA7, &apos;browser_refresh&apos;:0xA8, &apos;browser_stop&apos;:0xA9, &apos;browser_search&apos;:0xAA, &apos;browser_favorites&apos;:0xAB, &apos;browser_start_and_home&apos;:0xAC, &apos;volume_mute&apos;:0xAD, &apos;volume_Down&apos;:0xAE, &apos;volume_up&apos;:0xAF, &apos;next_track&apos;:0xB0, &apos;previous_track&apos;:0xB1, &apos;stop_media&apos;:0xB2, &apos;play/pause_media&apos;:0xB3, &apos;start_mail&apos;:0xB4, &apos;select_media&apos;:0xB5, &apos;start_application_1&apos;:0xB6, &apos;start_application_2&apos;:0xB7, &apos;attn_key&apos;:0xF6, &apos;crsel_key&apos;:0xF7, &apos;exsel_key&apos;:0xF8, &apos;play_key&apos;:0xFA, &apos;zoom_key&apos;:0xFB, &apos;clear_key&apos;:0xFE, &apos;+&apos;:0xBB, &apos;,&apos;:0xBC, &apos;-&apos;:0xBD, &apos;.&apos;:0xBE, &apos;/&apos;:0xBF, &apos;`&apos;:0xC0, &apos;;&apos;:0xBA, &apos;[&apos;:0xDB, &apos;\\&apos;:0xDC, &apos;]&apos;:0xDD, &quot;&apos;&quot;:0xDE, &apos;`&apos;:0xC0&#125;def press(*args): &apos;&apos;&apos; one press, one release. accepts as many arguments as you want. e.g. press(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)def pressAndHold(*args): &apos;&apos;&apos; press and hold. Do NOT release. accepts as many arguments as you want. e.g. pressAndHold(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) def pressHoldRelease(*args): &apos;&apos;&apos; press and hold passed in strings. Once held, release accepts as many arguments as you want. e.g. pressAndHold(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). this is useful for issuing shortcut command or shift commands. e.g. pressHoldRelease(&apos;ctrl&apos;, &apos;alt&apos;, &apos;del&apos;), pressHoldRelease(&apos;shift&apos;,&apos;a&apos;) &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) for i in args: win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0) time.sleep(.1) def release(*args): &apos;&apos;&apos; release depressed keys accepts as many arguments as you want. e.g. release(&apos;left_arrow&apos;, &apos;a&apos;,&apos;b&apos;). &apos;&apos;&apos; for i in args: win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0)def typer(string=None,*args):## time.sleep(4) for i in string: if i == &apos; &apos;: win32api.keybd_event(VK_CODE[&apos;spacebar&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;spacebar&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;!&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;1&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;1&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;@&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;2&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;2&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&#123;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;[&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;[&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;?&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;/&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;/&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;:&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;;&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;;&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&quot;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;\&apos;&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;\&apos;&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&#125;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;]&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;]&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;#&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;3&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;3&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;$&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;4&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;4&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;%&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;5&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;5&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;^&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;6&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;6&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&amp;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;7&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;7&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;*&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;8&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;8&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;(&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;9&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;9&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;)&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;0&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;0&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;_&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;-&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;-&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;=&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;+&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;+&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;~&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;`&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;`&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&lt;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;,&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;,&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;&gt;&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;.&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;.&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;A&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;a&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;a&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;B&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;b&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;b&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;C&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;c&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;c&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;D&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;d&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;d&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;E&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;e&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;e&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;F&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;f&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;f&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;G&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;g&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;g&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;H&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;h&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;h&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;I&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;i&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;i&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;J&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;j&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;j&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;K&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;k&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;k&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;L&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;l&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;l&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;M&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;m&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;m&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;N&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;n&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;n&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;O&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;o&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;o&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;P&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;p&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;p&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Q&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;q&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;q&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;R&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;r&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;r&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;S&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;s&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;s&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;T&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;t&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;t&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;U&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;u&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;u&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;V&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;v&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;v&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;W&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;w&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;w&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;X&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;x&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;x&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Y&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;y&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;y&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) elif i == &apos;Z&apos;: win32api.keybd_event(VK_CODE[&apos;left_shift&apos;], 0,0,0) win32api.keybd_event(VK_CODE[&apos;z&apos;], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[&apos;left_shift&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) win32api.keybd_event(VK_CODE[&apos;z&apos;],0 ,win32con.KEYEVENTF_KEYUP ,0) else: win32api.keybd_event(VK_CODE[i], 0,0,0) time.sleep(.05) win32api.keybd_event(VK_CODE[i],0 ,win32con.KEYEVENTF_KEYUP ,0) 参考地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
        <tag>win32api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3.6安装pywin32]]></title>
    <url>%2F2017%2F12%2F28%2Fpython3-6%E5%AE%89%E8%A3%85pywin32%2F</url>
    <content type="text"><![CDATA[python3.6装载win32api模块 使用pip安装win32报错 1Could not find a version that satisfies the requirement win32api (from versions: )No matching distribution found for win32api stack overflow上面有两种回答 pip install pypiwin32 从windowsapi官网下载安装程序，点击安装 首先尝试了第一种方式，没啥用，还是找不到win32api尝试第二种方法，直接报错：1Python version 3.6-32 required, which was not found in the registry. 找半天问题，首先本地python是64位版本，下载的也是64位安装包，报这莫名其妙的注册表错误。后来在注册表里加了个python3.6-32就能安装了，莫名其妙。。1HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\3.6-32 导入了个奇奇怪怪的win32api，貌似用不了12345#!/usr/bin/env python3# -*- coding: utf-8 -*-import win32.win32apiimport win32.win32clipboardimport win32com 根据以往踩坑经验，改注册表好像都没什么好下场，于是乎，把装好的win32全部删除，注册表还原，重新下载更新版本的pywin32：下载链接 重新安装之后，重启pycharm，这次好像是成功了。。123456import win32apiimport win32condef keyDown(keyName): win32api.keybd_event() win32con.KEYEVENTF_KEYUP 反正过程是挺无语的，莫名其妙的就好了。 附上环境信息：123WIN-10 64位python-3.6 64位pywin32-221.win-amd64-py3.6]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pywin32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3_map()函数]]></title>
    <url>%2F2017%2F12%2F27%2Fpython3-map-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[坑爹python3改动之map()函数 做自动化测试，获取并校验下拉列表中所有值，由于实在不想先写个空列表，再来个for循环全部加到列表中，就想到了map()函数，折腾半天，各种报错，墙里墙外翻半天，终于找到跟我一样入坑的人。 map()函数，python3改动 在python2中，以下代码可输出一个列表[1, 2, 3, 4, 5]12a = map(lambda x:x, [1, 2, 3, 4, 5])print(a) 但是python3，这玩意只能输出个map对象：&lt;map object at 0x00000278CB45D4E0&gt; 遇到这玩意也很多次了，直接加list：12a = list(map(lambda x: x, [1, 2, 3, 4, 5]))print(a) 这样，在python3就可以输出[1, 2, 3, 4, 5] 附自动化测试比较下拉列表值是否符合预期示例代码（百度新闻高级设置-显示条数为例）：12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverfrom selenium.webdriver.support.ui import Selectimport unittestimport timeclass News_Baidu(unittest.TestCase): def setUp(self): #打开浏览器 self.brower = webdriver.Chrome() def test_Checklist(self): #打开百度新闻页面 self.brower.get(&quot;http://news.baidu.com/&quot;) #定位“高级设置”，并点击 self.brower.find_element_by_link_text(&quot;高级搜索&quot;).click() #定位“搜索结果显示条数” select_element = Select(self.brower.find_element_by_name(&apos;rn&apos;)) #获取下拉列表所有元素对象 select_options = select_element.options #声明一个期望下拉列表值的列表(百度也是够坑的，值前面还有一个空格) expect_optionlist = [&apos; 每页显示10条&apos;, &apos; 每页显示20条&apos;, &apos; 每页显示50条&apos;] #获取实际的下拉列表值的列表 actual_optionlist = list(map(lambda option:option.text, select_options)) #断言结果是否适合期望 self.assertListEqual(actual_optionlist, expect_optionlist) def tearDown(self): #休眠 time.sleep(5) #退出浏览器 self.brower.quit()if __name__ == &apos;__main__&apos;: unittest.main()]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html报告乱码]]></title>
    <url>%2F2017%2F12%2F26%2Fhtml%E6%8A%A5%E5%91%8A%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[使用HTMLTestRunner进行测试报告输出时，错误说明，中午乱码，版本：12python3.6HTMLTestRunner 1.1.1 网上搜了一堆，全是用python2.x的，心痛，2.X到2020年不就不支持了嘛，为啥一个个的都在2.X上面，没办法，自己去捣鼓源码。 报告输出的html文件，使用类似于notepad的编辑器打开，编码格式改为UTF-8，重新在浏览器中打开，错误描述的中文显示就是正常文字。所以，只要在输出时，设置编码为“utf-8”应该就可以。 找到本地的HTMLTestRunner安装路径，一般都是在G:\skills\python36\Lib\site-packages\HtmlTestRunner类似这样的路径下，毕竟扩展包。下面有三个文件，和一个文件夹，文件夹里是报告的模板，不考虑，三个文件，一个是HtmlTestRunner的介绍，一个是runner.py，一个是result.py，输出报告，应该就在result.py文件中。 编辑器打开result.py，找到第350行1with open(path_file, &apos;w&apos;) as report_file: 只要修改成1with open(path_file, &apos;w&apos;,encoding=&apos;utf-8&apos;) as report_file: 即可。 附上百度搜索自动化测试代码 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3# -*- coding: utf-8 -*-import unittestimport timefrom selenium import webdriverfrom HtmlTestRunner import HTMLTestRunnerclass GloryRoad(unittest.TestCase): def setUp(self): #启动chrome浏览器 self.brower = webdriver.Chrome() def test_baidu(self): #访问百度首页 self.brower.get(&quot;https://www.baidu.com&quot;) #清空输入框内容 self.brower.find_element_by_id(&apos;kw&apos;).clear() #搜索框输入“selenium3” self.brower.find_element_by_id(&apos;kw&apos;).send_keys(&apos;selenium3&apos;) #点击“百度一下”按键 self.brower.find_element_by_id(&apos;su&apos;).click() #休眠3s time.sleep(3) assert &quot;google&quot; in self.brower.page_source, &quot;页面中不存在要寻找的关键字！&quot; def tearDown(self): #退出浏览器 self.brower.quit()if __name__ == &apos;__main__&apos;: suite = unittest.TestLoader().loadTestsFromTestCase(GloryRoad) runner = HTMLTestRunner(output=&apos;G:/workstation/report&apos;, report_title=&apos;Test Result&apos;) runner.run(suite)]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm单元测试]]></title>
    <url>%2F2017%2F12%2F25%2Fpycharm%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用pycharm编写/执行单元测试用例 python单元测试用例，调用方式使用1unittest.main() 该方式，在python shell中可执行成功，在pycharm中会一直报错，参考网上的写法，最后校验调用改为：12if _name_ == &apos;_main_&apos;: unittest.main() 结果一直报错，NameError: name &#39;_name_&#39; is not defined 简直了，找了半天，还是在墙外找到跟我有一样经历的哥们的求救，报错原因是_name_和_main都是双下划线，正确写法是： 12if __name__ == &apos;__main__&apos;: unittest.main() 真是日常坑自己…]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>unittest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium3+python3.6搭建测试]]></title>
    <url>%2F2017%2F12%2F25%2Fselenium3-python3-6%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[python3.6selenium3chrome64firefox57 selenium3开始，需要浏览器驱动，加载驱动方式：121，驱动放在任意位置，代码中，引驱动，打开浏览器（webdriver.Chrome(executable_path=&quot;驱动路径&quot;）2，将驱动放到浏览器安装目录下，和浏览器启动程序同级，将浏览器安装路径加到环境变量Path中，重启pycharm 自动化测试示例： 12345678910111213141516171819202122232425262728#!/usr/bin/env python3# -*- coding: utf-8 -*-from selenium import webdriverimport time#加载驱动程序#firefox(驱动放到浏览器安装目录，目录加到Path)#driver = webdriver.Firefox()#chrome(驱动放到浏览器安装目录，目录加到Path)driver = webdriver.Chrome()#chrome默认安装路径，驱动指定路径#driver = webdriver.Chrome(executable_path=&quot;G:/Selenium/drivers/chromedriver.exe&quot;)#打开百度首页driver.get(&quot;https://www.baidu.com&quot;)#清空搜索输入框默认内容driver.find_element_by_id(&quot;kw&quot;).clear()#输入框中输入“自动化测试”driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;自动化测试&quot;)#单击搜索按钮driver.find_element_by_id(&quot;su&quot;).click()#等待3秒time.sleep(3)#退出浏览器driver.quit()]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world_map]]></title>
    <url>%2F2017%2F12%2F21%2Fworld-map%2F</url>
    <content type="text"><![CDATA[pygal-2.4pygal-maps-world-1.0.2 世界地图模块位置变更 pygal内置世界地图模块，包括国别码模块COUNTRIES以及世界地图模块World。 当前版本下，绘制世界地图，需要从pygal_maps_world.i18n中引国别码，需要从pygal_maps_world.maps中引世界地图。 参考代码如下： countries.py12345678910#!/usr/bin/env python3# -*- coding: utf-8 -*-from pygal_maps_world.i18n import COUNTRIESdef get_country_code(country_name): &quot;&quot;&quot;根据指定国家，返回国别码&quot;&quot;&quot; for code, name in COUNTRIES.items(): if name == country_name or name == country_name.title(): return code return None population_data.py123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python3# -*- coding: utf-8 -*-from settings import Settingsfrom countries import get_country_codefrom pygal.style import RotateStyle as RS,LightColorizedStyle as LCSimport pygal_maps_world.mapsimport jsondata_setting = Settings()filename = data_setting.json_populationwith open(filename) as f_obj: pop_data = json.load(f_obj)#打印每个国家2010年的人口cc_population = &#123;&#125;for pop_dict in pop_data: if pop_dict[&apos;Year&apos;] == &apos;2010&apos;: country_name = pop_dict[&apos;Country Name&apos;] population = int(float(pop_dict[&apos;Value&apos;])) code = get_country_code(country_name) if code: cc_population[code] = population#按人口给国家分组cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;for cc, pop in cc_population.items(): if pop &lt; 10000000: cc_pops_1[cc] = pop elif pop &lt; 1000000000: cc_pops_2[cc] = pop else: cc_pops_3[cc] = popwm_style = RS(&apos;#336699&apos;,base_style=LCS)wm = pygal_maps_world.maps.World(style=wm_style)wm.title = &quot;World Population in 2010.by Country&quot;wm.add(&apos;0-10m&apos;, cc_pops_1)wm.add(&apos;10m-1bn&apos;, cc_pops_2)wm.add(&apos;&gt;1bn&apos;, cc_pops_3)wm.render_to_file(&apos;world_population.svg&apos;)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pygal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制随机漫步图]]></title>
    <url>%2F2017%2F12%2F20%2F%E7%BB%98%E5%88%B6%E9%9A%8F%E6%9C%BA%E6%BC%AB%E6%AD%A5%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[matplotlib可绘制随机漫步图，取随机X个数，在画布上绘制，并加入渐变颜色，效果还是挺好看的 代码如下： random_walk.py1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python3# -*- coding: utf-8 -*-from random import choiceclass RandomWalk(): &quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot; def __init__(self,num_point=5000): &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot; self.num_point = num_point #所有随机漫步的点都始于（0,0） self.x_values = [0] self.y_values = [0] def get_step(self): &quot;&quot;&quot;设置前进方向及距离&quot;&quot;&quot; direction = choice([1, -1]) distance = choice([0, 1, 2, 3, 4]) step = distance * direction return step def fill_walk(self): &quot;&quot;&quot;计算随机漫步的所有点&quot;&quot;&quot; while len(self.x_values) &lt; self.num_point: x_step = self.get_step() y_step = self.get_step() #排除原地踏步情况 if x_step == 0 and y_step == 0: continue #计算下一个点的位置 next_x = self.x_values[-1] + x_step next_y = self.y_values[-1] + y_step self.x_values.append(next_x) self.y_values.append(next_y) rw_visual.py123456789101112131415161718192021222324252627#!/usr/bin/env python3# -*- coding: utf-8 -*-import matplotlib.pyplot as pltfrom random_walk import RandomWalkwhile True: #创建一个随机漫步实例，并将所有包含的点绘制出 rw = RandomWalk(30000) rw.fill_walk() point_num = list(range(rw.num_point)) plt.scatter(rw.x_values, rw.y_values, c=point_num, cmap=plt.cm.Blues, s=5) #突出起点和终点 plt.scatter(0, 0, c=&apos;green&apos;, s=100) plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, s=100) #隐藏坐标轴 plt.axes().get_xaxis().set_visible(False) plt.axes().get_yaxis().set_visible(False) #plt.subplot().set_xticks([]) #plt.subplot().set_yticks([]) plt.show() keep_drawing = input(&quot;Make another walk?y/n&quot;) if keep_drawing == &apos;n&apos;: break 可成功绘制随机漫步图，然而有个警告报错：1MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance. In a future version, a new instance will always be created and returned. Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.warnings.warn(message, mplDeprecation, stacklevel=1) 原因是matplotlib版本问题，出在隐藏坐标轴plt.axes().get_yaxis()处，尝试修改为：12plt.subplot().set_xticks([])plt.subplot().set_yticks([]) 然而没啥用，还是在警告，暂时没解决。。好在不影响功能，不是强迫症也就无视这红字了。。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib绘制渐变图]]></title>
    <url>%2F2017%2F12%2F20%2Fmatplotlib%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[使用matplotlib绘制1-1000所有整数立方值图形报错 绘制1~1000所有整数的立方图，颜色采用渐变蓝色，点越接近坐标原点，颜色越浅。代码：123456789101112131415161718import matplotlib.pyplot as pltx_values = list(range(1,1001))y_values = [x**3 for x in x_values]plt.scatter(x_values, y_values, c=y_values,cmap=plt.cm.Blues,s=40)#设置图表坐标并设置坐标标签plt.title(&quot;Square Numbers&quot;,fontsize=24)plt.xlabel(&quot;Values&quot;,fontsize=14)plt.ylabel(&quot;Square of Value&quot;,fontsize=14)#设置坐标轴刻度plt.tick_params(axis=&apos;both&apos;, labelsize=14)#设置坐标轴取值plt.axes([0,1100,0,1100000])plt.show() 可以成功绘制图形，但是有警告报错：1UserWarning: Unable to find pixel distance along axis for interval padding of ticks; assuming no interval padding needed.warnings.warn(&quot;Unable to find pixel distance along axis &quot; 原因：设置坐标轴取值时，使用的是plt.axes，该函数创建的是一个轴对象，并将输入解释为指定位置的矩形，绘制的坐标轴中取值0在绘制的图形之外，超出了限制范围，所以警告报错。 解决方案：使用plt.axis()代替plt.axes()123#设置坐标轴取值plt.axis([0,1100,0,1100000])plt.show()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.0更新内容记录]]></title>
    <url>%2F2017%2F12%2F19%2FDjango2-0%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Django 2.0 变更内容(不按版本敲着实是有点坑o(╥﹏╥)o) 外键Django 1.9在创建models.ForeignKey外键时，可写成1topic = models.ForeignKey(Topic） Django 2.0需要多传一个字段on_delete，且可给定默认值models.CASCADE所以上述可写为：1topic = models.ForeignKey(Topic,on_delete=models.CASCADE) 指定app_nameDjango 1.9在映射URL时，工程的urls.py可写成：1234567from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;&apos;,include(&apos;learning_logs.urls&apos;, namespace=&apos;learning_logs&apos;))] 应用的urls.py可写成：12345678&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsurlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 该写法在Django 2.0中会出现报错：12&apos;Specifying a namespace in include() without providing an app_name &apos;django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead. 意思是缺少了app_name，所以需要指定app_name，我的做法是在应用的urls.py文件中指定app_name，也就是工程的urls.py保持不变，应用的urls.py增加app_name指定：123456789&quot;&quot;&quot;定义learning_logs的URL模式&quot;&quot;&quot;from django.urls import pathfrom . import viewsapp_name = &apos;learning_logs&apos;urlpatterns = [ #主页 path(&apos;&apos;, views.index, name=&apos;index&apos;)] 映射URL对于django.urls.path()函数，允许有简单的表示方法： 1url(r’^articles/(?P[0-9]&#123;4&#125;)/$’, views.year_archive), 可以写成： 1path(‘articles//‘, views.year_archive), 用法参见前博客记录]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试-理发师模型]]></title>
    <url>%2F2017%2F12%2F15%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E7%90%86%E5%8F%91%E5%B8%88%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[性能测试有个有名的模型，理发店模型，理发店标配：一间或大或小的店面，一个或几个理发师，几张理发的椅子和顾客休息的椅子。本文介绍一下理发店模型（相关资料网上一堆，只是为了自己记录） 场景假设 1234该理发店：1. 理发店共有3名理发师；2. 每位理发师剪一个发的时间都是1小时；3. 我们顾客们都是很有时间观念的人而且非常挑剔，他们对于每次光顾理发店时所能容忍的等待时间+剪发时间是3小时，而且等待时间越长，顾客的满意度越低。如果3个小时还不能剪完头发，我们的顾客会立马生气的走人。 场景模拟1231. 当理发店内只有1位顾客时，只需要有1名理发师为他提供服务，其他两名理发师可能继续等着，也可能会帮忙打打杂。1小时后，这位顾客剪完头发出门走了。那么在这1个小时里，整个理发店只服务了1位顾客，这位顾客花费在这次剪发的时间是1小时；2. 当理发店内同时有两位顾客时，就会同时有两名理发师在为顾客服务，另外1位发呆或者打杂帮忙。仍然是1小时后，两位顾客剪完头发出门。在这1小时里，理发店服务了两位顾客，这两位顾客花费在剪发的时间均为1小时；3. 很容易理解，当理发店内同时有三位顾客时，理发店可以在1小时内同时服务三位顾客，每位顾客花费在这次剪发的时间仍然是均为1小时； 从上面几个场景中我们可以发现，在理发店同时服务的顾客数量从1位增加到3位的过程中，随着顾客数量的增多，理发店的整体工作效率在提高，但是每位顾客在理发店内所呆的时间并未延长。 当然，我们可以假设当只有1位顾客和2位顾客时，空闲的理发师可以帮忙打杂，使得其他理发师的工作效率提高，并使每位顾客的剪发时间小于1小时。不过即使根据这个假设，虽然随着顾客数量的增多，每位顾客的服务时间有所延长，但是这个时间始终还被控制在顾客可接受的范围之内，并且顾客是不需要等待的。 不过随着理发店的生意越来越好，顾客也越来越多，新的场景出现了。假设有一次顾客A、B、C刚进理发店准备剪发，外面一推门又进来了顾客D、E、F。因为A、B、C三位顾客先到，所以D、E、F三位只好坐在长板凳上等着。1小时后，A、B、C三位剪完头发走了，他们每个人这次剪发所花费的时间均为1小时。可是D、E、F三位就没有这么好运，因为他们要先等A、B、C三位剪完才能剪，所以他们每个人这次剪发所花费的时间均为2小时——包括等待1小时和剪发1小时。 通过上面这个场景我们可以发现，对于理发店来说，都是每小时服务三位顾客——第1个小时是A、B、C，第二个小时是D、E、F；但是对于顾客D、E、F来说，“响应时间”延长了。如果你可以理解上面的这些场景，就可以继续往下看了。 在新的场景中，我们假设这次理发店里一次来了9位顾客，根据我们上面的场景，相信你不难推断，这9位顾客中有3位的“响应时间”为1小时，有3位的“响应时间”为2小时（等待1小时+剪发1小时），还有3位的“响应时间”为3小时（等待2小时+剪发1小时）——已经到达用户所能忍受的极限。假如在把这个场景中的顾客数量改为10，那么我们已经可以断定，一定会有1位顾客因为“响应时间”过长而无法忍受，最终离开理发店走了。 抽象 这张图中展示的是1个标准的软件性能模型。在图中有三条曲线，分别表示资源的利用情况（Utilization，包括硬件资源和软件资源）、吞吐量（Throughput，这里是指每秒事务数）以及响应时间（Response Time）。图中坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。 在这张图中我们可以看到，最开始，随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。 根据这种性能表现，图中划分了三个区域，分别是Light Load（较轻的压力）、Heavy Load（较重的压力）和Buckle Zone（用户无法忍受并放弃请求）。在Light Load和Heavy Load 两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。 当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。 对应到我们上面理发店的例子，每小时3个顾客就是这个理发店的最佳并发用户数，而每小时9个顾客则是它的最大并发用户数。当每小时都有3个顾客到来时，理发店的整体工作效率最高；而当每小时都有9个顾客到来时，前几个小时来的顾客还可以忍受，但是随着等待的顾客人数越来越多，等待时间越来越长，最终还是会有顾客无法忍受而离开。同时，随着理发店里顾客人数的增多和理发师工作时间的延长，理发师会逐渐产生疲劳，还要多花一些时间来清理环境和维持秩序，这些因素将最终导致理发师的工作效率随着顾客人数的增多和工作的延长而逐渐的下降，到最后可能要1.5小时甚至2个小时才能剪完1个发了。当然，如果一开始就有10个顾客到来，则注定有1位顾客剪不到头发了。 大神原网址]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter系统监控配置]]></title>
    <url>%2F2017%2F12%2F15%2FJmeter%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Jmeter是测试人员经常会使用的一款压力测试工具，经常会使用来测试接口的性能；Jmeter同时具备监控服务器资源使用情况的功能。 主要介绍一下怎么使用Jmeter来监控服务器的CPU,内存,IO等信息。 下载使用Jmeter监控系统性能，实际上是插件的使用，可以认为是在Jmeter中装载了一个小型监控系统的客户端，同时在需要监控的系统内装载服务端，在允许Jmeter时，同时打开监控服务端，进行系统资源的监控。 12客户端：JMeterPlugins-Standard服务端：ServerAgent 下载地址： 官网下载 百度云链接： JMeterPlugins-Standard-1.4.0ServerAgent-2.2.1 配置说明将 JMeterPlugins-Standard-1.4.0.zip 中 lib\ext 目录下的 JmeterPlugins-Standard.jar 文件都放到apache-jmeter-2.13\lib\ext目录中。将 ServerAgent-2.2.1.zip 解压后放到要监控的服务器中待使用。 监控设置 启动Jmeter后，右击线程组，选择添加- 监听器- jp@gc-PerfMon Metrics Collector 打开jp@gc - PerfMon Metrics Collector，点击Add Row选择相应监控对象（服务器IP和监控内容），端口默认4444即可。 开启监控 设置永远循环，否则监控会运行一次就断开，设置方式：线程组-循环次数（选择永远） 服务端运行ServerAgent，Linux系统运行shell脚本，windows系统执行bat脚本（系统需事先完成jdk配置） 成功完成系统资源监控]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客中加入图片]]></title>
    <url>%2F2017%2F12%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[好不容易搭好了hexo，插个图片各种错 本地引用绝对路径markdown语法实现 12source/images/image.jpg ![](/images/image.jpg) 这样，图片既可以在首页内容访问，也可以在文章正文中使用 相对路径首先在/blog/_config.yml 中设置 post_asset_folder: true ，这样在 hexo new “文章” 时会生成与文章标题一样的目录，将文章中需要使用的图片存在该目录下（source//_posts/文章） 12_posts/post_name/image.jpg ![](image.jpg) CDN引用现在大多数做法是使用图床，自己也看过七牛云之类的做为图床，但是，七牛云个流氓，还要手持身份证认证，所以暂时放弃。（该方法就是在图床中生成链接，直接引链接即可） Markdown 语法介绍]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码]]></title>
    <url>%2F2017%2F12%2F13%2Fpython%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列（二） 日常编写python脚本，鉴于java各种坑编码经历，首先就会把pycharm编码设置成utf-8，但是不知道什么鬼，设置完成之后，编译还是会报编码gbk的错误 问题如下： “UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 34: illegal multibyte sequence” 解决方案： 1，设置所有文件编码默认为utf-8（文件最前面指定） 2，处理数据时进行转码： with open(“population.json”,encoding=’UTF-8’) as data: –完 (#^.^#)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django获取不到特定链接]]></title>
    <url>%2F2017%2F12%2F13%2FDjango%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E7%89%B9%E5%AE%9A%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[python日常踩坑系列 按照教程方式打开本地特定链接报错源码如下： 12345678910111213from django.conf.urls import urlfrom . import viewsurlpatterns = [ # Home page. url(r'^$', views.index, name='index'), # Show all topics. url(r'^topics/$', views.topics, name='topics'), # Detail page for a single topic. url(r'^topics/(?P&lt;topic_id&gt;\d+)/$', views.topic, name='topic'),] 打开http://127.0.0.1:8000/topics/1/报错： 123456 Using the URLconf defined in learning_log.urls, Django tried these URL patterns, in this order: 1. admin/ 2. [name='index'] 3. topics [name='topics'] 4. topics/?P&lt;topic_id&gt;\d+/ [name='topic']The current path, topics/1/, didn't match any of these. 原因：Django2.0有更新对于django.urls.path()函数，允许有简单的表示方法： url(r’^articles/(?P[0-9]{4})/$’, views.year_archive), 可以写成： path(‘articles//‘, views.year_archive), 所以代码可更改为：12345678910111213from django.urls import pathfrom . import viewsapp_name = 'lerning_logs'urlpatterns = [ #主页 path('', views.index, name='index'), #显示所有主题 path('topics', views.topics, name='topics'), #特定主题的详细页面 #path('topics/?P&lt;topic_id&gt;\d+/', views.topic, name='topic'), path('topics/&lt;topic_id&gt;/', views.topic, name='topic'),]]]></content>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
